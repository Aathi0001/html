<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Software Engineering Notes</title>
     <style>
          body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      line-height: 1.6;
      padding: 20px;
      color: #333;
    max-width: 100%;
    word-wrap: break-word;
}

pre, table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}


    h1, h2, h3 {
      margin-top: 30px;
      border-left: 5px solid #ff6347;
      padding-left: 12px;
      color: #333;
    }

    h1 {
      font-size: 32px;
      color: #e91e63;
    }

    h2 {
      font-size: 26px;
      color: #3f51b5;
    }

    h3 {
      font-size: 22px;
      color: #009688;
    }

    h4 {
      font-size: 20px;
      color: #964800;
    }

    pre {
      background: #eee;
      padding: 10px 15px;
      border-left: 5px solid #607d8b;
      white-space: pre-wrap;
      font-family: 'Consolas', monospace;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin: 4px 0;
    }

    .section {
      margin-bottom: 40px;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 10px;
      border-left: 4px solid #ffc107;
    }
    code {
  background-color: #f0f0f0;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 0.95em;
  color: #c7254e;
}
a {
  color: #007acc;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
hr {
  border: none;
  border-top: 1px solid #ccc;
  margin: 40px 0;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

th, td {
  border: 1px solid #ccc;
  padding: 10px;
  text-align: left;
}

th {
  background-color: #f2f2f2;
}

.button {
  background-color: #4CAF50;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: inline-block;
}

.button:hover {
  background-color: #45a049;
}

.model {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin: 30px 0;
  width: 100%;
}

.step {
  background: #007bff;
  color: white;
  padding: 10px 25px;
  border-radius: 8px;
  font-weight: bold;
  min-width: 180px;
  text-align: center;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  flex-shrink: 0;
}

.arrow {
  font-size: 20px;
  color: #333;
  text-align: center;
}

.row,
.loop {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.loop {
  border: 2px dashed #007bff;
  padding: 15px;
  border-radius: 10px;
  background: #f9f9f9;
  max-width: 100%;
  box-sizing: border-box;
}

/* 📱 Responsive design */
@media (max-width: 600px) {
  .step {
    width: 100%;
    max-width: 280px;
  }

  .row,
  .loop {
    flex-direction: column;
    align-items: stretch;
  }

  .arrow {
    transform: rotate(90deg);
  }
}


.vmodel {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  flex-wrap: wrap;
  gap: 40px;
  margin: 40px 0;
}

.v-left, .v-right {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.v-left .arrow {
  transform: rotate(0deg);
}

.v-right .arrow {
  transform: rotate(180deg);
}

.v-middle {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.step {
  background: #007bff;
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  text-align: center;
  width: 200px;
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.arrow {
  font-size: 20px;
  color: #333;
}

@media (max-width: 768px) {
  .vmodel {
    flex-direction: column;
    align-items: center;
  }
  
  .v-left, .v-right {
    flex-direction: column;
  }
  
  .v-right .arrow {
    transform: rotate(90deg);
  }
  
  .v-left .arrow {
    transform: rotate(90deg);
  }
}

</style>
</head>
<body>

  <section id="introduction-to-software-engineering">
  <h2>1. Introduction to Software Engineering</h2>

  <h3>What is Software?</h3>
  <p>
    Software is a set of programs and instructions that tell a computer what to do.  <br>
    It helps the computer perform specific tasks like playing music, managing bank accounts, or browsing the internet.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Examples of software: MS Word, WhatsApp, Google Chrome, or a mobile banking app.
    </p>
  </div>

  <h3>What is Engineering?</h3>
  <p>
    Engineering means applying scientific and logical methods to design and build something useful, safe, and reliable.  <br>
    It focuses on solving real-world problems in a planned and systematic way.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Building a bridge using proper design and testing is engineering — not just putting materials together randomly.
    </p>
  </div>

  <h3>What is Software Engineering?</h3>
  <p>
    Software Engineering is the systematic approach to the design, development, operation, and maintenance of software. <br>
    Software Engineering means applying engineering principles to develop software.  <br>
    It ensures the software is <b>well-planned, reliable, cost-effective, and easy to maintain.</b>
  </p>

  <p>
    It follows a proper process like <b>Requirement → Design → Coding → Testing → Maintenance</b> to make sure the final product works correctly and meets user needs.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Simply creating a website by trial and error is programming.  
      But creating a website after proper planning, design, and testing is <b>Software Engineering</b>.
    </p>
  </div>

  <h3>In Short</h3>
  <p>
    <b>Software Engineering</b> = <b>Software</b> (instructions for computer) + <b>Engineering</b> (systematic method)  
    → Together, they create <b>high-quality software</b> that meets user needs effectively.
  </p>

  <h3>Need for Software Engineering</h3>
  <ul>
    <li><b>Increased Software Complexity:</b> Modern systems are large and complex, requiring structured methods to manage development.</li>
    <li><b>High Cost of Failure:</b> Errors in critical systems (like banking or aviation) can cause huge losses or risks.</li>
    <li><b>Quality and Reliability:</b> Engineering principles ensure that software meets performance and reliability standards.</li>
    <li><b>Team Collaboration:</b> Large software projects need coordination among multiple developers and teams.</li>
    <li><b>Timely Delivery:</b> Proper process models help deliver software on time and within budget.</li>
  </ul>

  <h3>Characteristics of Good Software</h3>
  <ul>
    <li><b>Correctness:</b> The software performs all tasks as specified.</li>
    <li><b>Reliability:</b> It operates without failure for a given time and condition.</li>
    <li><b>Efficiency:</b> Uses minimal resources such as memory, time, and power.</li>
    <li><b>Maintainability:</b> Easy to modify, update, and debug when requirements change.</li>
    <li><b>Usability:</b> Easy for users to learn and operate.</li>
    <li><b>Portability:</b> Can run on different hardware or operating systems with minimal change.</li>
    <li><b>Security:</b> Protects data and resists unauthorized access.</li>
  </ul>

  <h3>Software Crisis</h3>
  <p>
    The term <b>Software Crisis</b> refers to the challenges faced by developers in the early days of software development,
    especially during the 1960s and 1970s, when projects often:
  </p>
  <ul>
    <li>Exceeded budget and deadlines.</li>
    <li>Produced unreliable or low-quality software.</li>
    <li>Were difficult to maintain or update.</li>
    <li>Failed to meet user needs.</li>
  </ul>
  <p>
    Software Engineering emerged as a solution to this crisis — providing structured methods and best practices for building software effectively.
  </p>

  <h3>Software Myths</h3>
  <p>
    <b>Software Myths</b> are false beliefs about software development that often lead to project failures.  
    They are commonly categorized into <b>Management Myths, Customer Myths,</b> and <b>Developer Myths.</b>
  </p>

  <ul>
    <li><b>Management Myths:</b>
      <ul>
        <li>"If we fall behind schedule, we can add more people to catch up."</li>
        <li>"Once we write the code, our job is done."</li>
      </ul>
    </li>

    <li><b>Customer Myths:</b>
      <ul>
        <li>"Software requirements can be easily changed at any time."</li>
        <li>"All I need to do is say what I want; the developers will handle the rest."</li>
      </ul>
    </li>

    <li><b>Developer Myths:</b>
      <ul>
        <li>"The software will work perfectly once it’s coded."</li>
        <li>"Only the code matters — documentation is not important."</li>
      </ul>
    </li>
  </ul>

  <p>
    Understanding and avoiding these myths helps teams follow proper processes and ensures the success of software projects.
  </p>

</section>

<hr>

<section id="software-process-sdlc">
  <h2>2. SDLC (Software Development Life Cycle)</h2>

  <h3>Definition</h3>
  <p>
    The <b>Software Development Life Cycle (SDLC)</b> is a systematic process that defines the steps involved in developing a high-quality software product.    <br>
    It describes the <b>entire life span</b> of software — from planning to maintenance — ensuring that the final product meets user expectations.
  </p>
  <p>
    SDLC provides a <b>structured approach</b> to software development, helping teams manage time, cost, and quality effectively.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Suppose a company wants to build a bus ticket booking system.  
      They follow SDLC steps like analyzing user needs, designing the system, coding, testing, and finally deploying it for users.
    </p>
  </div>

  <h3>Phases of SDLC (8 Phases)</h3>
  <p>
    Each phase has a specific purpose to ensure smooth and successful software development.
  </p>

  <h4>1. Requirement</h4>
  <p>
    In this phase, we <b>gather client requirements</b> — what the client expects from the software.  
    All these details are clearly written in the <b>Software Requirement Specification (SRS)</b> document.
  </p>

  <div class="example">
    <b>Example:</b>
    <p>
      If a bank wants a mobile app for balance checking and fund transfers,  
      we note down every feature the client needs in the SRS.
    </p>
  </div>

  <h4>2. Analysis</h4>
  <p>
    After gathering requirements, the team studies them in detail to understand the <b>scope</b> of the project,  
    <b>identify challenges</b>, and <b>find suitable solutions</b>.
  </p>

  <b>Types of Requirements:</b>
  <ul>
    <li><b>Functional Requirements:</b> What the system should do — features, actions, and tasks.</li>
    <li><b>Non-Functional Requirements:</b> How the system should perform — speed, security, usability, etc.</li>
  </ul>

  <p>
    The final output of this phase is the <b>SRS (Software Requirement Specification)</b>,  
    which acts as a blueprint for all further stages of development.
  </p>

  <h4>3. Planning</h4>
  <p>
    Once requirements are clear, the next step is to plan how to achieve them.  
    The planning phase defines the <b>roadmap</b> for development.
  </p>
  <ul>
    <li>Project scheduling and resource allocation.</li>
    <li>Cost estimation and timeline preparation.</li>
    <li>Risk identification and management planning.</li>
    <li>Team roles and responsibilities are defined.</li>
  </ul>

  <h4>4. System Design</h4>
  <p>
    In this phase, the system’s architecture is designed based on the SRS.  
    The goal is to create a <b>blueprint</b> of the entire software system.
  </p>
  <ul>
    <li><b>High-Level Design (HLD):</b> Defines the overall architecture, modules, and data flow.</li>
    <li><b>Low-Level Design (LLD):</b> Specifies logic for each component, database structure, and interface details.</li>
  </ul>
  <p>
    Tools like <b>Data Flow Diagrams (DFD)</b>, <b>UML diagrams</b>, and <b>ER diagrams</b> are often used in this phase.
  </p>

  <h4>5. Coding (Implementation)</h4>
  <p>
    In this phase, the actual <b>source code</b> is written based on the design documents.  
    Developers use programming languages like Java, Python, or C++ depending on the project requirements.
  </p>
  <ul>
    <li>Follow coding standards and best practices.</li>
    <li>Code reviews are done to maintain quality.</li>
    <li>Version control tools (like Git) are used to manage code.</li>
  </ul>

  <h4>6. Testing</h4>
  <p>
    The testing phase ensures that the developed software is <b>error-free</b> and meets all requirements.  
    Testers execute various tests to identify and fix defects.
  </p>
  <ul>
    <li><b>Unit Testing:</b> Testing individual modules.</li>
    <li><b>Integration Testing:</b> Testing how modules work together.</li>
    <li><b>System Testing:</b> Testing the entire system as a whole.</li>
    <li><b>Acceptance Testing:</b> Ensures the system meets client expectations.</li>
  </ul>
  <b>Testing Phases:</b>
  <ul>
    <li><b>1. Dev Testing:</b> Initial testing done by the developer or tester to check the code functionality.</li>
    <li><b>2. UAT (User Acceptance Testing):</b> Conducted by the client to verify that the software meets business requirements.</li>
    <li><b>3. CUG / Pre-Production Testing:</b> Final testing done after installation at the client site to ensure the system works in the real environment.</li>
  </ul>

  <h4>7. Deployment</h4>
  <p>
    After successful testing, the software is <b>deployed</b> to the user environment.  
    This can be done in stages — first in a limited area (pilot release) and then to all users.
  </p>
  <ul>
    <li>Installation and configuration of the system.</li>
    <li>Migration of data from old systems.</li>
    <li>Training users and providing documentation.</li>
  </ul>

  <h4>8. Maintenance</h4>
  <p>
    After deployment, the software enters the <b>maintenance phase</b>.  
    Developers fix bugs, update features, and adapt the system to new environments or technologies.
  </p>
  <ul>
    <li><b>Corrective Maintenance:</b> Fixing discovered defects.</li>
    <li><b>Adaptive Maintenance:</b> Adjusting software for new hardware or OS.</li>
    <li><b>Perfective Maintenance:</b> Enhancing performance or adding new features.</li>
    <li><b>Preventive Maintenance:</b> Improving maintainability and preventing future problems.</li>
  </ul>

  <p>
    The SDLC process ensures that every stage of development is properly planned and executed, 
    leading to <b>high-quality, reliable, and efficient software</b>.
  </p>

</section>

<br>

<section id="software-process-model">
  <h2>Software Process Model</h2>

  <h3>Definition</h3>
  <p>
    A <b>Software Process Model</b> is a <b>structured method</b> that defines how to plan, design, develop, test, and deliver software.  
    It acts as a <b>roadmap</b> that guides the software development team through different phases of the project.
  </p>
  <p>
    In simple words, it is the <b>step-by-step approach</b> used to build software in an organized and efficient way.
  </p>

  <div class="example">
    <b>Example:</b>
    <p>
      Just like a builder follows a plan to construct a house, software engineers follow a <b>process model</b> to build software.
    </p>
  </div>
  <h2>Common Software Process Models</h2>

  <!-- Waterfall Model -->
  <h3>1. Waterfall Model</h3>
  <p>
    The <b>Waterfall Model</b> is the oldest and simplest Software Process Model that follows the SDLC in a linear, step-by-step sequence.  <br>
    It follows a <b>linear sequential flow</b> — each phase must be completed before moving to the next.
  </p>
  <ul>
    <li>Phases: Requirement → Design → Coding → Testing → Deployment → Maintenance</li>
    <li>Once a phase is completed, you cannot go back to make changes easily.</li>
    <li>Best suited for small projects with well-defined requirements.</li>
  </ul>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company developing a <b>college admission management system</b> with fixed features 
      like student registration, fee payment, and report generation.  
      Since requirements are clear and unlikely to change, Waterfall works well.
    </p>
  </div>
  <h4>Documentation at Each Phase:</h4>
  <p>
    Each stage must be <b>completed and approved</b> (with documentation) before moving to the next phase.  
    These documents act as a <b>contract between client and developer</b> — ensuring both agree on what is being built.
  </p>

  <ul>
    <li><b>Requirement Phase:</b> <i>Software Requirement Specification (SRS)</i> — approved by client.</li>
    <li><b>Design Phase:</b> <i>System Design Document (SDD)</i> — reviewed by project lead and sometimes shared with client.</li>
    <li><b>Development Phase:</b> <i>Code Documentation / Technical Document</i> — reviewed by technical lead.</li>
    <li><b>Testing Phase:</b> <i>Test Plan & Test Case Reports</i> — verified by QA team and signed off by client after UAT.</li>
    <li><b>Deployment Phase:</b> <i>Deployment Document</i> — reviewed and approved by client.</li>
    <li><b>Maintenance Phase:</b> <i>Change Logs, Issue Tracker</i> — maintained by support team.</li>
  </ul>
  <h4>Options When a Change Is Required:</h4>
  <ul>
    <li><b>Small change in early stages:</b> The team may manually revisit the relevant phase (requirement or design), make updates, and continue — but this is rare.</li>
    <li><b>Large or late-stage change:</b> Usually requires restarting the project or creating a new version with updated requirements.</li>
  </ul>

  <p>
    Waterfall suits projects with <b>stable and clearly defined requirements</b>.  
    For projects needing frequent updates or feedback, <b>Iterative or Agile models</b> are preferred.
  </p>

  <h4>Waterfall Model</h4>
  <div class="model">
    <div class="step">Requirement</div>
    <div class="arrow">⬇️</div>
    <div class="step">Design</div>
    <div class="arrow">⬇️</div>
    <div class="step">Implementation</div>
    <div class="arrow">⬇️</div>
    <div class="step">Testing</div>
    <div class="arrow">⬇️</div>
    <div class="step">Deployment</div>
    <div class="arrow">⬇️</div>
    <div class="step">Maintenance</div>
  </div>
  <h4>Advantages:</h4>
  <ul>
    <li>Simple and easy to understand.</li>
    <li>Phases are well defined and structured.</li>
    <li>Easy to manage due to clear documentation.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Not suitable for projects with changing requirements.</li>
    <li>Hard to go back to a previous phase once completed.</li>
    <li>Late discovery of issues (testing occurs at the end).</li>
  </ul>

<hr>

  <!-- Iterative Model -->
  <h3>2. Iterative Model</h3>
  <p>
    The <b>Iterative Model</b> develops the software in <b>repeated cycles (iterations)</b>.   <br>
    Each iteration produces a new version of the software — improving existing features or refining the system based on feedback.
  </p>
  <p>
    Instead of delivering the whole software at once, it is built gradually through multiple versions.
  </p>
  <ul>
    <li>Focuses on <b>enhancing and refining</b> the existing system rather than creating entirely new modules.</li>
    <li>Each iteration includes <b>planning, designing, coding, and testing</b>.</li>
    <li>Feedback from users is used to improve the next iteration.</li>
  </ul>


  <div class="example">
  <h4>Example:</h4>
  <p>
    A company is developing a <b>mobile banking app</b>.<br>
    - 1st iteration: Release basic features like login and balance check. <b><i>(Internal testing only / Feedback)</i></b><br>
    - 2nd iteration: Improve UI, make balance check faster,(add money transfer options). <b><i>(Still under development) and (Internal testing / limited feedback)</i></b><br>
    - 3rd iteration: Enhance security, optimize performance. <b><i>(Still under development) and (Internal testing / limited feedback)</i></b><br>
    - 4th iteration: Add better navigation, fix usability issues. <b><i>(Official deployment to users)</i></b><br> <br>
    Each version is released, tested, and refined based on user feedback (tested internally or by a small group). <br>
    Only final iteration is "deployed" to users
  </p>

  <p>
    <b>Important Note:</b> In iterative development, you may add minor features (like money transfer) as part of refining the system.  <br>
    The focus is <b>on improving the same system repeatedly</b>, not creating completely separate modules.
  </p>

  <p>
    In practice, iterative development doesn’t mean you cannot add new features —  
    it means the focus is on <b>rebuilding or improving existing parts</b> based on feedback.
  </p>

  <p>
    So when we say: <i>“Add money transfer in the next iteration”</i> —  
    it means we are building on the same base version by refining and extending it slightly, not creating a totally separate module.
  </p>
  </div>

  <p><b>Build a rough version of the whole app → get feedback → improve the whole app (and optionally add minor features) → repeat until final release.</b></p>
  <p>Iterative → Build → Evaluate → Improve</p>

  <h4>Documentation at Each Phase:</h4>
  <p>
    Each iteration produces updated documentation reflecting changes or improvements made.  <br>
    Documents are revised at the end of every cycle to track progress.
  </p>
  <h4>Client Involvement:</h4>
  <p>
    The <b>client is actively involved</b> after each iteration.  <br>
    They review progress, provide feedback, and suggest improvements for the next cycle.
  </p>

  <h4>Iterative Model</h4>
  <div class="model">
    <div class="loop">
      <div class="step">Planning</div>
      <div class="arrow">➡️</div>
      <div class="step">Design</div>
      <div class="arrow">➡️</div>
      <div class="step">Implement</div>
      <div class="arrow">➡️</div>
      <div class="step">Test</div>
    </div>
    <p>🔁 Each iteration improves the system</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Early working model available for feedback.</li>
    <li>Less risk — Easy to identify and fix issues in early stages.</li>
    <li>Improves software quality through gradual enhancement.</li>
    <li>Users can see working software after each iteration.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Needs more client involvement.</li>
    <li>May require extra time and cost due to multiple revisions.</li>
    <li>Proper planning and management are essential to control iterations.</li>
  </ul>

  <h4>When It’s Used:</h4>
  <p>
    Used when <b>requirements are not fully clear at the beginning</b> and may change over time.  <br>
    Common in projects where <b>continuous improvement</b> is expected — like mobile apps, web platforms, or e-commerce systems.
  </p>

  <hr>

  <!-- Incremental Model -->
  <h3>3. Incremental Model</h3>
  <p>
    The <b>Incremental Model</b> divides the software into separate <b>modules or components</b>.   <br>
    Each module (increment) is developed, tested, and deployed independently.  <br>
    New functionality is added step by step until the complete system is delivered. 
  </p>

  <ul>
    <li><b>Focus:</b> Deliver functional modules one by one.</li>
    <li><b>Deployment:</b> Each increment can be released to users after testing.</li>
    <li><b>Best suited for:</b> Large projects where requirements are clear but can be implemented in parts.</li>
  </ul>

  <div class="example">
    <h4>Example – Mobile Banking App</h4>
    <ul>
      <li><b>Increment 1:</b> Login module (users can log in)</li>
      <li><b>Increment 2:</b> Balance module (users can view balance)</li>
      <li><b>Increment 3:</b> Transaction module (users can transfer money)</li>
      <li><b>Increment 4:</b> UI/Navigation improvements and bill payment module</li>
    </ul>
    <p>
      Each increment is developed, tested, and deployed independently. Users can use the available functionality after each increment.
    </p>
  </div>

  <h4>Modules in Incremental Model</h4>
  <p>
    A <b>module</b> is a self-contained part of the system that performs a specific function (technical unit of the system).  <br>
    In incremental development, the system is split into <b>independent modules</b>.  <br>
    Each module is delivered as a separate increment, making it easier to manage, test, and deploy gradually.
  </p>

  <ul>
    <li><b>Login Module:</b> Handles user authentication</li>
    <li><b>Balance Module:</b> Shows account balance</li>
    <li><b>Transaction Module:</b> Handles money transfers</li>
  </ul>
  <p>
    In the <b>Incremental Model</b>, the system is delivered <b>module by module</b>.
  </p>

  <p>
    Each increment can be <b>developed, tested, and deployed independently</b>.
  </p>
  <ul>
    <li><b>Focus:</b> Deliver functional modules step by step.</li>
    <li><b>Deployment:</b> Each increment can be released independently.</li>
    <li><b>Iterations inside increment:</b> Optional — improve the module internally before release.</li>
    <li><b>Client Feedback:</b> Usually provided after each increment is delivered.</li>
  </ul>
  <div class="example">
    <h4>Example:</h4>
    <p>
      Login module → released → Balance module → released → Transaction module → released.
    </p>
  </div>

  <h4>Incremental Model</h4>
  <div class="model">
    <div class="row">
      <div class="step">Increment 1</div>
      <div class="step">Increment 2</div>
      <div class="step">Increment 3</div>
      <div class="step">Final Product</div>
    </div>
    <p>✅ Each increment adds more functionality</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Users get working functionality early.</li>
    <li>Faster deployment for individual modules.</li>
    <li>Easy to add or change features in future increments.</li>
    <li>Reduces risk — problems are isolated to a module.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires careful planning to split modules effectively.</li>
    <li>Integration between increments can be complex.</li>
    <li>Design changes late in development can affect multiple increments.</li>
  </ul>

  <hr>

  <h3>4. Agile Model</h3>
  <p>
    The <b>Agile Model</b> is an <b>iterative and incremental approach</b> that focuses on <b>customer collaboration</b> and <b>flexible development</b>.  <br>
    The project is divided into small, time-boxed cycles called <b>sprints</b>, usually 1–4 weeks long.
  </p>

  <ul>
    <li><b>Focus:</b> Deliver small features or user stories frequently.</li>
    <li><b>Iteration:</b> Every sprint involves planning, designing, developing, testing, and reviewing.</li>
    <li><b>Deployment:</b> Each sprint can deliver usable functionality to users.</li>
    <li><b>Client Feedback:</b> Continuous — client is involved in every sprint.</li>
    <li><b>Flexibility:</b> Easy to adapt to requirement changes in each sprint.</li>
  </ul>

  <div class="example">
    <h4>Example – Mobile Banking App</h4>
    <ul>
      <li><b>Sprint 1 / Iteration 1:</b> Login + basic balance display → client feedback</li>
      <li><b>Sprint 2 / Iteration 2:</b> Money transfer + improve UI → client feedback</li>
      <li><b>Sprint 3 / Iteration 3:</b> Bill payments + security improvements → client feedback</li>
      <li><b>Sprint 4 / Iteration 4:</b> Reports, notifications, final polish → final deployment</li>
    </ul>
    <p>
      Sprint 1: You deliver a small increment (e.g., login + balance check). <br>
      Customer Feedback: Client uses it and gives feedback — maybe UI is confusing, or speed is slow. <br>
      Sprint 2: You improve the existing features based on that feedback and may add new features (like money transfer).
    </p>

    <p>
      Each sprint delivers <b>small working features</b>, and client feedback is incorporated continuously. <br>
      A sprint can involve multiple modules or parts of the system. <br>
      Sprint is a time-boxed cycle delivering features.
    </p>
  </div>

  <h4>Agile Model</h4>
  <div class="model">
    <div class="loop">
      <div class="step">Sprint Planning</div>
      <div class="arrow">➡️</div>
      <div class="step">Req Analysis</div>
      <div class="arrow">➡️</div>
      <div class="step">Design</div>
      <div class="arrow">➡️</div>
      <div class="step">Development</div>
      <div class="arrow">➡️</div>
      <div class="step">Testing</div>
      <div class="arrow">➡️</div>
      <div class="step">Client Feedback</div>
      <div class="arrow">➡️</div>
      <div class="step">Team Review</div>
      <div class="arrow">➡️</div>
      <div class="step">Next Sprint Planning</div>
    </div>
    <p>🔁 Each sprint delivers a working increment and improves the system based on feedback</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Faster delivery of working software.</li>
    <li>Continuous client feedback ensures requirements are met.</li>
    <li>High flexibility to adapt to changes.</li>
    <li>Encourages collaboration and communication.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires frequent client involvement.</li>
    <li>Can be difficult to predict overall cost and timeline.</li>
    <li>Less emphasis on detailed documentation compared to traditional models.</li>
  </ul>

  <hr>

  <!-- Spiral Model -->
  <h3>5. Spiral Model</h3>
  <p>
    The <b>Spiral Model</b> combines the features of both <b>Iterative</b> and <b>Waterfall</b> models.  <br>  
    It focuses on <b>risk analysis</b> and is ideal for large, complex, and high-risk projects.
  </p>
  <p>
    Each spiral (loop) represents a phase that includes planning, risk analysis, development, and evaluation.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company is developing a <b>large banking software</b>.  
      - First spiral: Create a prototype of the account management module and identify risks. <br>
      - Second spiral: Develop the transaction module after addressing risks from the first spiral. <br>
      - Third spiral: Integrate reporting and security features, improving based on previous feedback.  
      Each spiral reduces risk and enhances the system gradually.
    </p>
  </div>

<h4>Spiral Model</h4>
<div class="model">
  <div class="loop">
    <div class="step">Requirement Identification</div>
    <div class="arrow">➡️</div>
    <div class="step">Risk Analysis & Planning</div>
    <div class="arrow">➡️</div>
    <div class="step">Design & Development</div>
    <div class="arrow">➡️</div>
    <div class="step">Testing / Evaluation</div>
    <div class="arrow">➡️</div>
    <div class="step">Customer Evaluation</div>
    <div class="arrow">➡️</div>
    <div class="step">Next Spiral / Refinement</div>
  </div>
  <p> Repeated in multiple spirals, each refining the system and document risks.</p>
</div>

  <h4>Advantages:</h4>
  <ul>
    <li>Excellent for high-risk and complex projects.</li>
    <li>Risk is identified and minimized early.</li>
    <li>Flexible — changes can be made in every cycle.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Can be expensive and time-consuming due to multiple iterations and risk analysis.</li>
    <li>Requires customer involvement at every spiral.</li>
  </ul>

  <hr>

  <!-- V-Model -->
  <h3>6. V-Model (Verification & Validation Model)</h3>
  <p>
    The <b>V-Model</b> is a <b>software process model</b> where <b>development and testing phases run in parallel</b>. 
    Each development phase has a corresponding testing phase, ensuring quality at every step.  
  </p>
  <p>
    Each development stage has a corresponding testing stage.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company is developing a <b>college management system</b>. <br>
      - Requirement Analysis → Create requirement document.<br>
      - System Design → Prepare system architecture.<br>
      - Module Design → Design student registration module.<br>
      - Coding → Implement the module.<br>
      - Unit Testing → Test the registration module.<br>
      - Integration Testing → Combine modules like registration + fee payment.<br>
      - System Testing → Test the entire system.<br>
      - Acceptance Testing → Client validates that the system meets requirements.
    </p>
  </div>

  <h4>V-Model (Verification & Validation)</h4>

  <div class="vmodel">
    <div class="v-left">
      <div class="step">Requirement Analysis</div>
      <div class="arrow">⬇️</div>
      <div class="step">System Design</div>
      <div class="arrow">⬇️</div>
      <div class="step">Architectural Design</div>
      <div class="arrow">⬇️</div>
      <div class="step">Module Design</div>
    </div>

    <div class="v-middle">
      <div class="step">Coding</div>
    </div>

    <div class="v-right">
      <div class="step">Unit Testing</div>
      <div class="arrow">⬆️</div>
      <div class="step">Integration Testing</div>
      <div class="arrow">⬆️</div>
      <div class="step">System Testing</div>
      <div class="arrow">⬆️</div>
      <div class="step">Acceptance Testing</div>
    </div>
  </div>

  <p style="text-align:center;"> Verification on the left side, validation on the right side. Each development step has a corresponding test step.</p>

  <h4>Advantages:</h4>
  <ul>
    <li>Structured and easy to understand.</li>
    <li>Each phase has a corresponding test, improving quality.</li>
    <li>Early detection of defects in design phases.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Not flexible for changing requirements.</li>
    <li>Better suited for small to medium projects.</li>
  </ul>
    
  <hr>

  <!-- Prototyping Model -->
  <h3>7. Prototyping Model</h3>
  <p>
    The <b>Prototype Model</b> is a <b>software process model</b> where a <b>quick working version</b> of the system is built first. <br> 
    The prototype is shown to the client for feedback, refined, and finally used to develop the complete system.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company is developing a <b>library management system</b>. <br>
      - Build a prototype showing basic features: book catalog, search, and issue/return. <br>
      - Client reviews and requests changes like adding fine calculation. <br>
      - Prototype is refined based on feedback. <br>
      - Once approved, the final system is developed with all requested features.
    </p>
  </div>

  <h4>Prototyping Model</h4>
  <div class="model">
    <div class="row">
      <div class="step">Requirement</div>
      <div class="arrow">➡️</div>
      <div class="step">Quick Design</div>
      <div class="arrow">➡️</div>
      <div class="step">Build Prototype</div>
      <div class="arrow">➡️</div>
      <div class="step">Client Evaluation / Feedback</div>
      <div class="arrow">➡️</div>
      <div class="step">Refine & Improve Prototype</div>
      <div class="arrow">➡️</div>
      <div class="step">Develop Final System</div>
    </div>
    <p>Repeat prototype refinement until the client is satisfied. Then finalize the system for deployment.</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Early client feedback ensures requirements are correct.</li>
    <li>Reduces misunderstanding and development risk.</li>
    <li>Reduces the risk of user dissatisfaction.</li>

  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Frequent changes can increase time and cost.</li>
    <li>May lead to confusion between prototype and final system.</li>
    <li>Not suitable for very large or complex projects.</li>
  </ul>

  <hr>

  <!-- RAD Model -->
  <h3>8. RAD (Rapid Application Development) Model</h3>
  <p>
    The <b>RAD Model</b> is a <b>software process model</b> focused on <b>fast development</b> using <b>reusable components</b> existing code, or purchased modules or prototypes. <br> 
    with constant user feedback. It emphasizes <b>speed over planning</b>, using reusable components and tools to build the software quickly. <br>
    It is suitable for small to medium projects where quick delivery is important.
  </p>

  <ul>
    <li>Build from existing code or modules if available.</li>
    <li>Buy from external vendors if it meets cost and time estimates.</li>
    <li>Otherwise, develop the required modules internally.</li>
  </ul>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Developing a <b>small e-commerce website</b>:<br>
      - Business Model: Analyze what the client wants (catalog, payment, shipping).<br>
      - Data Model: Identify products, users, orders entities.<br>
      - Process Model: Assemble modules like shopping cart, payment gateway.<br>
      - Application & Development: Integrate and code any missing modules.<br>
      - Testing & Turnover: Test and deliver to client quickly.
    </p>
  </div>

  <h4>RAD Model (Rapid Application Development)</h4>

  <div class="model">
    <div class="loop">
      <div class="step">Business Modeling</div>
      <div class="arrow">➡️</div>
      <div class="step">Data Modeling</div>
      <div class="arrow">➡️</div>
      <div class="step">Process Modeling</div>
      <div class="arrow">➡️</div>
      <div class="step">Application Generation</div>
      <div class="arrow">➡️</div>
      <div class="step">Testing & Turnover</div>
    </div>
    <p>⚙️ Each phase involves user feedback for faster delivery.</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Faster development and delivery.</li>
    <li>Users are actively involved, improving satisfaction.</li>
    <li>Reusable components reduce coding effort.</li>
    <li>Flexibility to make changes during development.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires highly skilled developers.</li>
    <li>Not suitable for large, complex systems with strict requirements.</li>
    <li>Too much user involvement may lead to scope creep.</li>
  </ul>

  <hr>

  <h3>9. Win-Win Spiral Model</h3>
  <p>
    The <b>Win-Win Spiral Model</b> is an <b>improved version of the Spiral Model</b> developed by <b>Barry Boehm</b>.  
    It focuses on achieving a <b>“win-win” situation</b> between all stakeholders — developers, clients, and users.  
    The goal is to make sure that <b>everyone’s objectives are satisfied</b> before moving to the next phase.
  </p>

  <div class="model">
    <div class="loop">
      <div class="step">Identify Objectives</div>
      <div class="arrow">➡️</div>
      <div class="step">Resolve Conflicts</div>
      <div class="arrow">➡️</div>
      <div class="step">Develop & Validate</div>
      <div class="arrow">➡️</div>
      <div class="step">Review & Agreement</div>
    </div>
    <p>🔁 Each cycle ensures that all parties “win” by agreeing on goals, risks, and deliverables before proceeding.</p>
  </div>

  <h4>Phases:</h4>
  <ul>
    <li><b>1. Objective Identification:</b> Identify goals, constraints, and success criteria for all stakeholders.</li>
    <li><b>2. Conflict Resolution:</b> Resolve any disagreements to ensure mutual understanding.</li>
    <li><b>3. Development & Validation:</b> Build, test, and validate the product increment.</li>
    <li><b>4. Customer Review:</b> Review progress and gain approval before the next cycle.</li>
  </ul>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company developing a <b>custom ERP system</b> for a client.  
      - The client wants low cost and faster delivery.  
      - Developers want enough time for testing and design quality.  
      - Management wants risk-free implementation.  
      All parties discuss and agree on priorities (cost, quality, timeline) before development begins — ensuring a “win-win” for everyone.
    </p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Encourages collaboration and open communication.</li>
    <li>Minimizes risk through continuous client-developer agreement.</li>
    <li>Reduces rework and misunderstandings.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires active involvement of all stakeholders.</li>
    <li>Time-consuming due to frequent discussions and approvals.</li>
    <li>Not suitable for small or simple projects.</li>
  </ul>

  <h3>🔹 Comparison of Software Process Models</h3>

  <table cellspacing="0" cellpadding="8">
    <tr>
      <th>Model</th>
      <th>Approach</th>
      <th>Flexibility</th>
      <th>Client Involvement</th>
      <th>Risk Handling</th>
      <th>Cost</th>
      <th>Best Suited For</th>
    </tr>

    <tr>
      <td><b>Waterfall</b></td>
      <td>Linear sequential</td>
      <td>Very low</td>
      <td>Only at start & end</td>
      <td>Poor</td>
      <td>Low</td>
      <td>Small projects with fixed requirements</td>
    </tr>

    <tr>
      <td><b>Iterative</b></td>
      <td>Repeated improvement cycles</td>
      <td>High</td>
      <td>Moderate (after each iteration)</td>
      <td>Better than Waterfall</td>
      <td>Medium</td>
      <td>Projects needing gradual refinement</td>
    </tr>

    <tr>
      <td><b>Incremental</b></td>
      <td>Build module by module</td>
      <td>High</td>
      <td>After each increment</td>
      <td>Good</td>
      <td>Medium</td>
      <td>Large projects divided into modules</td>
    </tr>

    <tr>
      <td><b>Agile</b></td>
      <td>Iterative + Incremental (Sprints)</td>
      <td>Very High</td>
      <td>Continuous (each sprint)</td>
      <td>Excellent</td>
      <td>Medium to High</td>
      <td>Dynamic projects needing frequent updates</td>
    </tr>

    <tr>
      <td><b>Spiral</b></td>
      <td>Iterative with risk analysis</td>
      <td>High</td>
      <td>Regular feedback</td>
      <td>Very Strong</td>
      <td>High</td>
      <td>Large, high-risk projects</td>
    </tr>

    <tr>
      <td><b>V-Model</b></td>
      <td>Development & testing in parallel</td>
      <td>Low</td>
      <td>Only at milestones</td>
      <td>Moderate</td>
      <td>Medium</td>
      <td>Projects needing strict quality control</td>
    </tr>

    <tr>
      <td><b>Prototype</b></td>
      <td>Build quick mock-ups for feedback</td>
      <td>High</td>
      <td>Very High (continuous feedback)</td>
      <td>Good (early error detection)</td>
      <td>Medium</td>
      <td>Unclear or evolving requirements</td>
    </tr>

    <tr>
      <td><b>RAD</b></td>
      <td>Rapid module development using existing code</td>
      <td>High</td>
      <td>Frequent</td>
      <td>Good</td>
      <td>Low</td>
      <td>Small to medium projects needing fast delivery</td>
    </tr>

    <tr>
      <td><b>Win-Win Spiral</b></td>
      <td>Spiral + stakeholder negotiation</td>
      <td>High</td>
      <td>Very High (every phase)</td>
      <td>Excellent (mutual agreement)</td>
      <td>High</td>
      <td>Complex projects needing collaboration</td>
    </tr>
  </table>

  <p><b>Summary:</b> Waterfall is simple but rigid; Agile and Win-Win Spiral are flexible and client-centric.  
  Spiral-based models are best for high-risk projects, while RAD suits quick, low-cost development.</p>

</section>

<hr>

<!-- SRS (Software Requirements Specification) -->
<h3>SRS (Software Requirements Specification)</h3>
<p>
  <b>Software Requirements Specification (SRS)</b> is a <b>document that describes the complete behavior, functionality, and constraints of a software system</b>.  <br>
  It serves as a communication bridge between stakeholders (like clients and users) and the development team.
</p>

<div class="example">
  <h4>Example:</h4>
  <p>
    While developing a <b>Library Management System</b>, the SRS document will include:
    <ul>
      <li>Functional requirements(What the system should do): e.g., Add new books, issue books to students, calculate fines.</li>
      <li>Non-functional requirements(How the system should perform): e.g., System must respond within 2 seconds, must support 100 concurrent users.</li>
      <li>Constraints(Limit or Restriction): e.g., Must work on Windows 10 and above, use MySQL as the database.</li>
    </ul>
  </p>
</div>

<h4>Components of SRS:</h4>
<ul>
  <li><b>Introduction:</b> Overview, purpose, scope of the system, and definitions.</li>
  <li><b>Overall Description:</b> System perspective, user characteristics, constraints, and assumptions.</li>
  <li><b>Specific Requirements:</b> Detailed functional and non-functional requirements, interface requirements, and performance specifications.</li>
  <li><b>External Interface Requirements:</b> User interfaces, hardware interfaces, software interfaces, and communication interfaces.</li>
  <li><b>Other Requirements:</b> Security, reliability, maintainability, scalability, and compliance requirements.</li>
</ul>

<h4>Advantages of SRS:</h4>
<ul>
  <li>Clear understanding of system requirements for both developers and clients.</li>
  <li>Reduces ambiguity and miscommunication.</li>
  <li>Serves as a reference for validation, verification, and future maintenance.</li>
</ul>

<h4>Disadvantages of SRS:</h4>
<ul>
  <li>Creating a detailed SRS can be time-consuming.</li>
  <li>Frequent requirement changes can make SRS outdated quickly.</li>
  <li>Too much detail may overwhelm developers or stakeholders.</li>
</ul>

<hr>

<h3>List of Documents Maintained in a Software Project</h3>
<div class="note">
  <p>The following documents are maintained during a software project to ensure clarity, tracking, and proper communication throughout the Software Development Life Cycle (SDLC).</p>

  <ol>
    <li>
      <b>Project Proposal / Feasibility Study</b><br>
      Defines the <b>scope, goal, and objectives</b> of the project. It also checks the <b>technical, operational, and economic feasibility</b> before development starts.
      <ul>
        <li><b>Technical Feasibility:</b> Can the project be built with current technology?</li>
        <li><b>Economic Feasibility:</b> Is it financially affordable?</li>
        <li><b>Operational Feasibility:</b> Will it solve the organization’s problems effectively?</li>
        <li><b>Legal Feasibility:</b> Are there any legal or regulatory issues?</li>
        <li><b>Schedule Feasibility:</b> Can it be completed on time?</li>
      </ul>
    </li>

    <li>
      <b>SRS (Software Requirement Specification)</b><br>
      Contains all <b>functional</b> and <b>non-functional requirements</b> of the software. It acts as an agreement between the <b>client and the developer</b>.
    </li>

    <li>
      <b>System Design Document (SDD)</b><br>
      Describes the <b>architecture, data flow, ER diagrams, components,</b> and <b>system structure</b>. It converts the requirements into a detailed design plan.
    </li>

    <li>
      <b>Project Plan / Schedule</b><br>
      Specifies the <b>timeline, milestones, resources, cost estimation,</b> and <b>team responsibilities</b> to manage and track project progress.
    </li>

    <li>
      <b>Test Case / Test Plan</b><br>
      Includes the <b>test inputs, expected outputs, and conditions</b> used to verify that the software meets the requirements and functions correctly.
    </li>

    <li>
      <b>Source Code Document</b><br>
      Contains the <b>actual program code, folder structure, naming conventions,</b> and <b>environment details</b> used for development.
    </li>

    <li>
      <b>User Manual / User Guide</b><br>
      Helps <b>end-users</b> understand how to <b>install, operate,</b> and <b>troubleshoot</b> the software effectively.
    </li>

    <li>
      <b>Maintenance Report / Log</b><br>
      Records all <b>post-deployment activities</b> such as <b>bug fixes, updates, performance improvements,</b> and version control.
    </li>
  </ol>
</div>

<hr>

<h3>Change Management</h3>
<div class="note">
  <p>
    Change Management is the process of handling <b>modifications in a software project</b>.  
    It is a systematic process for <b>planning, implementing, and monitoring</b> changes to software systems 
    to <b>minimize risks</b> and <b>maximize benefits</b>.
  </p>

  <h4>Steps in Change Management:</h4>
  <ol>
    <li><b>Request and Identification:</b> A change is requested due to <b>business needs, user feedback, or market shifts</b>.</li>
    <li><b>Analysis:</b> Evaluate the impact of the change on the system, users, project timeline, and budget.</li>
    <li><b>Approval / Rejection:</b> The <b>Change Control Board (CCB)</b> and stakeholders review and decide whether to approve or reject the change.</li>
    <li><b>Implementation:</b> If approved, developers make the necessary changes in code or design.</li>
    <li><b>Testing and Verification:</b> The new changes are tested to ensure they don't affect existing functionality.</li>
    <li><b>Deployment and Monitoring:</b> The updated feature is deployed and monitored to ensure it works as expected.</li>
    <li><b>Documentation and Review:</b> All relevant project documents are updated with the change details.</li>
  </ol>

  <h4>Example:</h4>
  <p>
    In a <b>mobile banking app</b>, users request to add a “Dark Mode” feature.
  </p>
  <ol>
    <li>A change request is raised.</li>
    <li>Developers analyze its feasibility, check UI impact, required resources, and budget.</li>
    <li>The Project Manager approves the change.</li>
    <li>The feature is implemented, tested, deployed, and recorded in the change log.</li>
  </ol>
</div>

<h3>Risk Management</h3>
<div class="note">
  <p>
    Risk Management involves <b>identifying, analyzing, and controlling potential risks</b> that could affect a project's success.
  </p>

  <h4>Steps in Risk Management:</h4>
  <ol>
    <li><b>Risk Identification:</b> List all possible risks that could impact the project.  
        <i>Example: schedule delay, budget overrun, technology failure.</i></li>
    <li><b>Risk Analysis:</b> Estimate the <b>probability</b> and <b>impact</b> of each risk.</li>
    <li><b>Risk Prioritization:</b> Rank risks based on their severity and likelihood.</li>
    <li><b>Risk Mitigation Planning:</b> Create strategies to reduce or avoid high-impact risks.</li>
    <li><b>Risk Monitoring and Control:</b> Continuously monitor risks and take corrective actions as needed.</li>
  </ol>

  <h4>Example:</h4>
  <p>
    In a <b>web application project</b>, a key developer may leave the team unexpectedly.<br>
    → Mitigation: Train backup developers and maintain proper documentation.
  </p>
</div>

</body>
</html>
