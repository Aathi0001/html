<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Software Engineering Notes</title>
     <style>
          body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      line-height: 1.6;
      padding: 20px;
      color: #333;
    max-width: 100%;
    word-wrap: break-word;
}

pre, table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}


    h1, h2, h3 {
      margin-top: 30px;
      border-left: 5px solid #ff6347;
      padding-left: 12px;
      color: #333;
    }

    h1 {
      font-size: 32px;
      color: #e91e63;
    }

    h2 {
      font-size: 26px;
      color: #3f51b5;
    }

    h3 {
      font-size: 22px;
      color: #009688;
    }

    h4 {
      font-size: 20px;
      color: #964800;
    }

    pre {
      background: #eee;
      padding: 10px 15px;
      border-left: 5px solid #607d8b;
      white-space: pre-wrap;
      font-family: 'Consolas', monospace;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin: 4px 0;
    }

    .section {
      margin-bottom: 40px;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 10px;
      border-left: 4px solid #ffc107;
    }
    code {
  background-color: #f0f0f0;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 0.95em;
  color: #c7254e;
}
a {
  color: #007acc;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
hr {
  border: none;
  border-top: 1px solid #ccc;
  margin: 40px 0;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

th, td {
  border: 1px solid #ccc;
  padding: 10px;
  text-align: left;
}

th {
  background-color: #f2f2f2;
}

.button {
  background-color: #4CAF50;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: inline-block;
}

.button:hover {
  background-color: #45a049;
}

.model {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  margin: 30px 0;
  width: 100%;
}

.step {
  background: #007bff;
  color: white;
  padding: 10px 25px;
  border-radius: 8px;
  font-weight: bold;
  min-width: 180px;
  text-align: center;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  flex-shrink: 0;
}

.arrow {
  font-size: 20px;
  color: #333;
  text-align: center;
}

.row,
.loop {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.loop {
  border: 2px dashed #007bff;
  padding: 15px;
  border-radius: 10px;
  background: #f9f9f9;
  max-width: 100%;
  box-sizing: border-box;
}

/* üì± Responsive design */
@media (max-width: 600px) {
  .step {
    width: 100%;
    max-width: 280px;
  }

  .row,
  .loop {
    flex-direction: column;
    align-items: stretch;
  }

  .arrow {
    transform: rotate(90deg);
  }
}


.vmodel {
  display: flex;
  justify-content: center;
  align-items: flex-end;
  flex-wrap: wrap;
  gap: 40px;
  margin: 40px 0;
}

.v-left {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.v-left .arrow {
  transform: rotate(0deg);
}

.v-right  {
  display: flex;
  flex-direction: column-reverse;
  align-items: center;
  gap: 12px;
}

.v-middle {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.step {
  background: #007bff;
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  text-align: center;
  width: 200px;
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.arrow {
  font-size: 20px;
  color: #333;
}



</style>
</head>
<body>

  <section id="introduction-to-software-engineering">
  <h2>1. Introduction to Software Engineering</h2>

  <h3>What is Software?</h3>
  <p>
    Software is a set of programs and instructions that tell a computer what to do.  <br>
    It helps the computer perform specific tasks like playing music, managing bank accounts, or browsing the internet.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Examples of software: MS Word, WhatsApp, Google Chrome, or a mobile banking app.
    </p>
  </div>

  <h3>What is Engineering?</h3>
  <p>
    Engineering means applying scientific and logical methods to design and build something useful, safe, and reliable.  <br>
    It focuses on solving real-world problems in a planned and systematic way.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Building a bridge using proper design and testing is engineering ‚Äî not just putting materials together randomly.
    </p>
  </div>

  <h3>What is Software Engineering?</h3>
  <p>
    Software Engineering is the systematic approach to the design, development, operation, and maintenance of software. <br>
    Software Engineering means applying engineering principles to develop software.  <br>
    It ensures the software is <b>well-planned, reliable, cost-effective, and easy to maintain.</b>
  </p>

  <p>
    It follows a proper process like <b>Requirement ‚Üí Design ‚Üí Coding ‚Üí Testing ‚Üí Maintenance</b> to make sure the final product works correctly and meets user needs.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Simply creating a website by trial and error is programming.  
      But creating a website after proper planning, design, and testing is <b>Software Engineering</b>.
    </p>
  </div>

  <h3>In Short</h3>
  <p>
    <b>Software Engineering</b> = <b>Software</b> (instructions for computer) + <b>Engineering</b> (systematic method)  
    ‚Üí Together, they create <b>high-quality software</b> that meets user needs effectively.
  </p>

  <h3>Need for Software Engineering</h3>
  <ul>
    <li><b>Increased Software Complexity:</b> Modern systems are large and complex, requiring structured methods to manage development.</li>
    <li><b>High Cost of Failure:</b> Errors in critical systems (like banking or aviation) can cause huge losses or risks.</li>
    <li><b>Quality and Reliability:</b> Engineering principles ensure that software meets performance and reliability standards.</li>
    <li><b>Team Collaboration:</b> Large software projects need coordination among multiple developers and teams.</li>
    <li><b>Timely Delivery:</b> Proper process models help deliver software on time and within budget.</li>
  </ul>

  <h3>Characteristics of Good Software</h3>
  <ul>
    <li><b>Correctness:</b> The software performs all tasks as specified.</li>
    <li><b>Reliability:</b> It operates without failure for a given time and condition.</li>
    <li><b>Efficiency:</b> Uses minimal resources such as memory, time, and power.</li>
    <li><b>Maintainability:</b> Easy to modify, update, and debug when requirements change.</li>
    <li><b>Usability:</b> Easy for users to learn and operate.</li>
    <li><b>Portability:</b> Can run on different hardware or operating systems with minimal change.</li>
    <li><b>Security:</b> Protects data and resists unauthorized access.</li>
  </ul>

  <h3>Software Crisis</h3>
  <p>
    The term <b>Software Crisis</b> refers to the challenges faced by developers in the early days of software development,
    especially during the 1960s and 1970s, when projects often:
  </p>
  <ul>
    <li>Exceeded budget and deadlines.</li>
    <li>Produced unreliable or low-quality software.</li>
    <li>Were difficult to maintain or update.</li>
    <li>Failed to meet user needs.</li>
  </ul>
  <p>
    Software Engineering emerged as a solution to this crisis ‚Äî providing structured methods and best practices for building software effectively.
  </p>

  <h3>Software Myths</h3>
  <p>
    <b>Software Myths</b> are false beliefs about software development that often lead to project failures.  
    They are commonly categorized into <b>Management Myths, Customer Myths,</b> and <b>Developer Myths.</b>
  </p>

  <ul>
    <li><b>Management Myths:</b>
      <ul>
        <li>"If we fall behind schedule, we can add more people to catch up."</li>
        <li>"Once we write the code, our job is done."</li>
      </ul>
    </li>

    <li><b>Customer Myths:</b>
      <ul>
        <li>"Software requirements can be easily changed at any time."</li>
        <li>"All I need to do is say what I want; the developers will handle the rest."</li>
      </ul>
    </li>

    <li><b>Developer Myths:</b>
      <ul>
        <li>"The software will work perfectly once it‚Äôs coded."</li>
        <li>"Only the code matters ‚Äî documentation is not important."</li>
      </ul>
    </li>
  </ul>

  <p>
    Understanding and avoiding these myths helps teams follow proper processes and ensures the success of software projects.
  </p>

</section>

<hr>

<section id="software-process-sdlc">
  <h2>2. SDLC (Software Development Life Cycle)</h2>

  <h3>Definition</h3>
  <p>
    The <b>Software Development Life Cycle (SDLC)</b> is a systematic process that defines the steps involved in developing a high-quality software product.    <br>
    It describes the <b>entire life span</b> of software ‚Äî from planning to maintenance ‚Äî ensuring that the final product meets user expectations.
  </p>
  <p>
    SDLC provides a <b>structured approach</b> to software development, helping teams manage time, cost, and quality effectively.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Suppose a company wants to build a bus ticket booking system.  
      They follow SDLC steps like analyzing user needs, designing the system, coding, testing, and finally deploying it for users.
    </p>
  </div>

  <h3>Phases of SDLC (8 Phases)</h3>
  <p>
    Each phase has a specific purpose to ensure smooth and successful software development.
  </p>

  <h4>1. Requirement</h4>
  <p>
    In this phase, we <b>gather client requirements</b> ‚Äî what the client expects from the software.  
    All these details are clearly written in the <b>Software Requirement Specification (SRS)</b> document.
  </p>

  <div class="example">
    <b>Example:</b>
    <p>
      If a bank wants a mobile app for balance checking and fund transfers,  
      we note down every feature the client needs in the SRS.
    </p>
  </div>

  <h4>2. Analysis</h4>
  <p>
    After gathering requirements, the team studies them in detail to understand the <b>scope</b> of the project,  
    <b>identify challenges</b>, and <b>find suitable solutions</b>.
  </p>

  <b>Types of Requirements:</b>
  <ul>
    <li><b>Functional Requirements:</b> What the system should do ‚Äî features, actions, and tasks.</li>
    <li><b>Non-Functional Requirements:</b> How the system should perform ‚Äî speed, security, usability, etc.</li>
  </ul>

  <p>
    The final output of this phase is the <b>SRS (Software Requirement Specification)</b>,  
    which acts as a blueprint for all further stages of development.
  </p>

  <h4>3. Planning</h4>
  <p>
    Once requirements are clear, the next step is to plan how to achieve them.  
    The planning phase defines the <b>roadmap</b> for development.
  </p>
  <ul>
    <li>Project scheduling and resource allocation.</li>
    <li>Cost estimation and timeline preparation.</li>
    <li>Risk identification and management planning.</li>
    <li>Team roles and responsibilities are defined.</li>
  </ul>

  <h4>4. System Design</h4>
  <p>
    In this phase, the system‚Äôs architecture is designed based on the SRS.  
    The goal is to create a <b>blueprint</b> of the entire software system.
  </p>
  <ul>
    <li><b>High-Level Design (HLD):</b> Defines the overall architecture, modules, and data flow.</li>
    <li><b>Low-Level Design (LLD):</b> Specifies logic for each component, database structure, and interface details.</li>
  </ul>
  <p>
    Tools like <b>Data Flow Diagrams (DFD)</b>, <b>UML diagrams</b>, and <b>ER diagrams</b> are often used in this phase.
  </p>

  <h4>5. Coding (Implementation)</h4>
  <p>
    In this phase, the actual <b>source code</b> is written based on the design documents.  
    Developers use programming languages like Java, Python, or C++ depending on the project requirements.
  </p>
  <ul>
    <li>Follow coding standards and best practices.</li>
    <li>Code reviews are done to maintain quality.</li>
    <li>Version control tools (like Git) are used to manage code.</li>
  </ul>

  <h4>6. Testing</h4>
  <p>
    The testing phase ensures that the developed software is <b>error-free</b> and meets all requirements.  
    Testers execute various tests to identify and fix defects.
  </p>
  <ul>
    <li><b>Unit Testing:</b> Testing individual modules.</li>
    <li><b>Integration Testing:</b> Testing how modules work together.</li>
    <li><b>System Testing:</b> Testing the entire system as a whole.</li>
    <li><b>Acceptance Testing:</b> Ensures the system meets client expectations.</li>
  </ul>
  <b>Testing Phases:</b>
  <ul>
    <li><b>1. Dev Testing:</b> Initial testing done by the developer or tester to check the code functionality.</li>
    <li><b>2. UAT (User Acceptance Testing):</b> Conducted by the client to verify that the software meets business requirements.</li>
    <li><b>3. CUG / Pre-Production Testing:</b> Final testing done after installation at the client site to ensure the system works in the real environment.</li>
  </ul>

  <h4>7. Deployment</h4>
  <p>
    After successful testing, the software is <b>deployed</b> to the user environment.  
    This can be done in stages ‚Äî first in a limited area (pilot release) and then to all users.
  </p>
  <ul>
    <li>Installation and configuration of the system.</li>
    <li>Migration of data from old systems.</li>
    <li>Training users and providing documentation.</li>
  </ul>

  <h4>8. Maintenance</h4>
  <p>
    After deployment, the software enters the <b>maintenance phase</b>.  
    Developers fix bugs, update features, and adapt the system to new environments or technologies.
  </p>
  <ul>
    <li><b>Corrective Maintenance:</b> Fixing discovered defects.</li>
    <li><b>Adaptive Maintenance:</b> Adjusting software for new hardware or OS.</li>
    <li><b>Perfective Maintenance:</b> Enhancing performance or adding new features.</li>
    <li><b>Preventive Maintenance:</b> Improving maintainability and preventing future problems.</li>
  </ul>

  <p>
    The SDLC process ensures that every stage of development is properly planned and executed, 
    leading to <b>high-quality, reliable, and efficient software</b>.
  </p>

</section>

<br>

<section id="software-process-model">
  <h2>Software Process Model</h2>

  <h3>Definition</h3>
  <p>
    A <b>Software Process Model</b> is a <b>structured method</b> that defines how to plan, design, develop, test, and deliver software.  
    It acts as a <b>roadmap</b> that guides the software development team through different phases of the project.
  </p>
  <p>
    In simple words, it is the <b>step-by-step approach</b> used to build software in an organized and efficient way.
  </p>

  <div class="example">
    <b>Example:</b>
    <p>
      Just like a builder follows a plan to construct a house, software engineers follow a <b>process model</b> to build software.
    </p>
  </div>
  <h2>Common Software Process Models</h2>

  <!-- Waterfall Model -->
  <h3>1. Waterfall Model</h3>
  <p>
    The <b>Waterfall Model</b> is the oldest and simplest Software Process Model that follows the SDLC in a linear, step-by-step sequence.  <br>
    It follows a <b>linear sequential flow</b> ‚Äî each phase must be completed before moving to the next.
  </p>
  <ul>
    <li>Phases: Requirement ‚Üí Design ‚Üí Coding ‚Üí Testing ‚Üí Deployment ‚Üí Maintenance</li>
    <li>Once a phase is completed, you cannot go back to make changes easily.</li>
    <li>Best suited for small projects with well-defined requirements.</li>
  </ul>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company developing a <b>college admission management system</b> with fixed features 
      like student registration, fee payment, and report generation.  
      Since requirements are clear and unlikely to change, Waterfall works well.
    </p>
  </div>
  <h4>Documentation at Each Phase:</h4>
  <p>
    Each stage must be <b>completed and approved</b> (with documentation) before moving to the next phase.  
    These documents act as a <b>contract between client and developer</b> ‚Äî ensuring both agree on what is being built.
  </p>

  <ul>
    <li><b>Requirement Phase:</b> <i>Software Requirement Specification (SRS)</i> ‚Äî approved by client.</li>
    <li><b>Design Phase:</b> <i>System Design Document (SDD)</i> ‚Äî reviewed by project lead and sometimes shared with client.</li>
    <li><b>Development Phase:</b> <i>Code Documentation / Technical Document</i> ‚Äî reviewed by technical lead.</li>
    <li><b>Testing Phase:</b> <i>Test Plan & Test Case Reports</i> ‚Äî verified by QA team and signed off by client after UAT.</li>
    <li><b>Deployment Phase:</b> <i>Deployment Document</i> ‚Äî reviewed and approved by client.</li>
    <li><b>Maintenance Phase:</b> <i>Change Logs, Issue Tracker</i> ‚Äî maintained by support team.</li>
  </ul>
  <h4>Options When a Change Is Required:</h4>
  <ul>
    <li><b>Small change in early stages:</b> The team may manually revisit the relevant phase (requirement or design), make updates, and continue ‚Äî but this is rare.</li>
    <li><b>Large or late-stage change:</b> Usually requires restarting the project or creating a new version with updated requirements.</li>
  </ul>

  <p>
    Waterfall suits projects with <b>stable and clearly defined requirements</b>.  
    For projects needing frequent updates or feedback, <b>Iterative or Agile models</b> are preferred.
  </p>

  <h4>Waterfall Model</h4>
  <div class="model">
    <div class="step">Requirement</div>
    <div class="arrow">‚¨áÔ∏è</div>
    <div class="step">Design</div>
    <div class="arrow">‚¨áÔ∏è</div>
    <div class="step">Implementation</div>
    <div class="arrow">‚¨áÔ∏è</div>
    <div class="step">Testing</div>
    <div class="arrow">‚¨áÔ∏è</div>
    <div class="step">Deployment</div>
    <div class="arrow">‚¨áÔ∏è</div>
    <div class="step">Maintenance</div>
  </div>
  <h4>Advantages:</h4>
  <ul>
    <li>Simple and easy to understand.</li>
    <li>Phases are well defined and structured.</li>
    <li>Easy to manage due to clear documentation.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Not suitable for projects with changing requirements.</li>
    <li>Hard to go back to a previous phase once completed.</li>
    <li>Late discovery of issues (testing occurs at the end).</li>
  </ul>

<hr>

  <!-- Iterative Model -->
  <h3>2. Iterative Model</h3>
  <p>
    The <b>Iterative Model</b> develops the software in <b>repeated cycles (iterations)</b>.   <br>
    Each iteration produces a new version of the software ‚Äî improving existing features or refining the system based on feedback.
  </p>
  <p>
    Instead of delivering the whole software at once, it is built gradually through multiple versions.
  </p>
  <ul>
    <li>Focuses on <b>enhancing and refining</b> the existing system rather than creating entirely new modules.</li>
    <li>Each iteration includes <b>planning, designing, coding, and testing</b>.</li>
    <li>Feedback from users is used to improve the next iteration.</li>
  </ul>


  <div class="example">
  <h4>Example:</h4>
  <p>
    A company is developing a <b>mobile banking app</b>.<br>
    - 1st iteration: Release basic features like login and balance check. <b><i>(Internal testing only / Feedback)</i></b><br>
    - 2nd iteration: Improve UI, make balance check faster,(add money transfer options). <b><i>(Still under development) and (Internal testing / limited feedback)</i></b><br>
    - 3rd iteration: Enhance security, optimize performance. <b><i>(Still under development) and (Internal testing / limited feedback)</i></b><br>
    - 4th iteration: Add better navigation, fix usability issues. <b><i>(Official deployment to users)</i></b><br> <br>
    Each version is released, tested, and refined based on user feedback (tested internally or by a small group). <br>
    Only final iteration is "deployed" to users
  </p>

  <p>
    <b>Important Note:</b> In iterative development, you may add minor features (like money transfer) as part of refining the system.  <br>
    The focus is <b>on improving the same system repeatedly</b>, not creating completely separate modules.
  </p>

  <p>
    In practice, iterative development doesn‚Äôt mean you cannot add new features ‚Äî  
    it means the focus is on <b>rebuilding or improving existing parts</b> based on feedback.
  </p>

  <p>
    So when we say: <i>‚ÄúAdd money transfer in the next iteration‚Äù</i> ‚Äî  
    it means we are building on the same base version by refining and extending it slightly, not creating a totally separate module.
  </p>
  </div>

  <p><b>Build a rough version of the whole app ‚Üí get feedback ‚Üí improve the whole app (and optionally add minor features) ‚Üí repeat until final release.</b></p>
  <p>Iterative ‚Üí Build ‚Üí Evaluate ‚Üí Improve</p>

  <h4>Documentation at Each Phase:</h4>
  <p>
    Each iteration produces updated documentation reflecting changes or improvements made.  <br>
    Documents are revised at the end of every cycle to track progress.
  </p>
  <h4>Client Involvement:</h4>
  <p>
    The <b>client is actively involved</b> after each iteration.  <br>
    They review progress, provide feedback, and suggest improvements for the next cycle.
  </p>

  <h4>Iterative Model</h4>
  <div class="model">
    <div class="loop">
      <div class="step">Planning</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Design</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Implement</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Test</div>
    </div>
    <p>üîÅ Each iteration improves the system</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Early working model available for feedback.</li>
    <li>Less risk ‚Äî Easy to identify and fix issues in early stages.</li>
    <li>Improves software quality through gradual enhancement.</li>
    <li>Users can see working software after each iteration.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Needs more client involvement.</li>
    <li>May require extra time and cost due to multiple revisions.</li>
    <li>Proper planning and management are essential to control iterations.</li>
  </ul>

  <h4>When It‚Äôs Used:</h4>
  <p>
    Used when <b>requirements are not fully clear at the beginning</b> and may change over time.  <br>
    Common in projects where <b>continuous improvement</b> is expected ‚Äî like mobile apps, web platforms, or e-commerce systems.
  </p>

  <hr>

  <!-- Incremental Model -->
  <h3>3. Incremental Model</h3>
  <p>
    The <b>Incremental Model</b> divides the software into separate <b>modules or components</b>.   <br>
    Each module (increment) is developed, tested, and deployed independently.  <br>
    New functionality is added step by step until the complete system is delivered. 
  </p>

  <ul>
    <li><b>Focus:</b> Deliver functional modules one by one.</li>
    <li><b>Deployment:</b> Each increment can be released to users after testing.</li>
    <li><b>Best suited for:</b> Large projects where requirements are clear but can be implemented in parts.</li>
  </ul>

  <div class="example">
    <h4>Example ‚Äì Mobile Banking App</h4>
    <ul>
      <li><b>Increment 1:</b> Login module (users can log in)</li>
      <li><b>Increment 2:</b> Balance module (users can view balance)</li>
      <li><b>Increment 3:</b> Transaction module (users can transfer money)</li>
      <li><b>Increment 4:</b> UI/Navigation improvements and bill payment module</li>
    </ul>
    <p>
      Each increment is developed, tested, and deployed independently. Users can use the available functionality after each increment.
    </p>
  </div>

  <h4>Modules in Incremental Model</h4>
  <p>
    A <b>module</b> is a self-contained part of the system that performs a specific function (technical unit of the system).  <br>
    In incremental development, the system is split into <b>independent modules</b>.  <br>
    Each module is delivered as a separate increment, making it easier to manage, test, and deploy gradually.
  </p>

  <ul>
    <li><b>Login Module:</b> Handles user authentication</li>
    <li><b>Balance Module:</b> Shows account balance</li>
    <li><b>Transaction Module:</b> Handles money transfers</li>
  </ul>
  <p>
    In the <b>Incremental Model</b>, the system is delivered <b>module by module</b>.
  </p>

  <p>
    Each increment can be <b>developed, tested, and deployed independently</b>.
  </p>
  <ul>
    <li><b>Focus:</b> Deliver functional modules step by step.</li>
    <li><b>Deployment:</b> Each increment can be released independently.</li>
    <li><b>Iterations inside increment:</b> Optional ‚Äî improve the module internally before release.</li>
    <li><b>Client Feedback:</b> Usually provided after each increment is delivered.</li>
  </ul>
  <div class="example">
    <h4>Example:</h4>
    <p>
      Login module ‚Üí released ‚Üí Balance module ‚Üí released ‚Üí Transaction module ‚Üí released.
    </p>
  </div>

  <h4>Incremental Model</h4>
  <div class="model">
    <div class="row">
      <div class="step">Increment 1</div>
      <div class="step">Increment 2</div>
      <div class="step">Increment 3</div>
      <div class="step">Final Product</div>
    </div>
    <p>‚úÖ Each increment adds more functionality</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Users get working functionality early.</li>
    <li>Faster deployment for individual modules.</li>
    <li>Easy to add or change features in future increments.</li>
    <li>Reduces risk ‚Äî problems are isolated to a module.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires careful planning to split modules effectively.</li>
    <li>Integration between increments can be complex.</li>
    <li>Design changes late in development can affect multiple increments.</li>
  </ul>

  <hr>

  <h3>4. Agile Model</h3>
  <p>
    The <b>Agile Model</b> is an <b>iterative and incremental approach</b> that focuses on <b>customer collaboration</b> and <b>flexible development</b>.  <br>
    The project is divided into small, time-boxed cycles called <b>sprints</b>, usually 1‚Äì4 weeks long.
  </p>

  <ul>
    <li><b>Focus:</b> Deliver small features or user stories frequently.</li>
    <li><b>Iteration:</b> Every sprint involves planning, designing, developing, testing, and reviewing.</li>
    <li><b>Deployment:</b> Each sprint can deliver usable functionality to users.</li>
    <li><b>Client Feedback:</b> Continuous ‚Äî client is involved in every sprint.</li>
    <li><b>Flexibility:</b> Easy to adapt to requirement changes in each sprint.</li>
  </ul>

  <div class="example">
    <h4>Example ‚Äì Mobile Banking App</h4>
    <ul>
      <li><b>Sprint 1 / Iteration 1:</b> Login + basic balance display ‚Üí client feedback and deployment</li>
      <li><b>Sprint 2 / Iteration 2:</b> Money transfer + improve UI ‚Üí client feedback and deployment</li>
      <li><b>Sprint 3 / Iteration 3:</b> Bill payments + security improvements ‚Üí client feedback and deployment</li>
      <li><b>Sprint 4 / Iteration 4:</b> Reports, notifications, final polish ‚Üí final deployment</li>
    </ul>
    <p>
      Sprint 1: You deliver a small increment (e.g., login + balance check). <br>
      Customer Feedback: Client uses it and gives feedback ‚Äî maybe UI is confusing, or speed is slow. <br>
      Sprint 2: You improve the existing features based on that feedback and may add new features (like money transfer).
    </p>

    <p>
      Each sprint delivers <b>small working features</b>, and client feedback is incorporated continuously. <br>
      A sprint can involve multiple modules or parts of the system. <br>
      Sprint is a time-boxed cycle delivering features.
    </p>
  </div>

  <h4>Agile Model</h4>
  <div class="model">
    <div class="loop">
      <div class="step">Sprint Planning</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Req Analysis</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Design</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Development</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Testing</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Client Feedback</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Team Review</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Deployment (Optional)</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Next Sprint Planning</div>
    </div>
    <p>üîÅ Each sprint delivers a working increment and improves the system based on feedback</p>

  </div>

  <p>
    <b>Note:</b> Each sprint produces a <b>potentially shippable product increment</b>. 
    Deployment to end users may occur after every sprint (in continuous delivery) 
    or after several sprints (in a release cycle), depending on the project strategy.
  </p>


  <h4>Advantages:</h4>
  <ul>
    <li>Faster delivery of working software.</li>
    <li>Continuous client feedback ensures requirements are met.</li>
    <li>High flexibility to adapt to changes.</li>
    <li>Encourages collaboration and communication.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires frequent client involvement.</li>
    <li>Can be difficult to predict overall cost and timeline.</li>
    <li>Less emphasis on detailed documentation compared to traditional models.</li>
  </ul>

  <hr>

  <!-- Spiral Model -->
  <h3>5. Spiral Model</h3>
  <p>
    The <b>Spiral Model</b> combines the features of both <b>Iterative</b> and <b>Waterfall</b> models.  <br>  
    It focuses on <b>risk analysis</b> and is ideal for large, complex, and high-risk projects.
  </p>
  <p>
    Each spiral (loop) represents a phase that includes planning, risk analysis, development, and evaluation.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company is developing a <b>large banking software</b>.  
      - First spiral: Create a prototype of the account management module and identify risks. <br>
      - Second spiral: Develop the transaction module after addressing risks from the first spiral. <br>
      - Third spiral: Integrate reporting and security features, improving based on previous feedback.  
      Each spiral reduces risk and enhances the system gradually.
    </p>
  </div>

<h4>Spiral Model</h4>
<div class="model">
  <div class="loop">
    <div class="step">Requirement Identification</div>
    <div class="arrow">‚û°Ô∏è</div>
    <div class="step">Risk Analysis & Planning</div>
    <div class="arrow">‚û°Ô∏è</div>
    <div class="step">Design & Development</div>
    <div class="arrow">‚û°Ô∏è</div>
    <div class="step">Testing / Evaluation</div>
    <div class="arrow">‚û°Ô∏è</div>
    <div class="step">Customer Evaluation</div>
    <div class="arrow">‚û°Ô∏è</div>
    <div class="step">Next Spiral / Refinement</div>
  </div>
  <p> Repeated in multiple spirals, each refining the system and document risks.</p>
</div>

  <h4>Advantages:</h4>
  <ul>
    <li>Excellent for high-risk and complex projects.</li>
    <li>Risk is identified and minimized early.</li>
    <li>Flexible ‚Äî changes can be made in every cycle.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Can be expensive and time-consuming due to multiple iterations and risk analysis.</li>
    <li>Requires customer involvement at every spiral.</li>
  </ul>

  <hr>

  <!-- V-Model -->
  <h3>6. V-Model (Verification & Validation Model)</h3>
  <p>
    The <b>V-Model</b> is a <b>software process model</b> where <b>development and testing phases run in parallel</b>. 
    Each development phase has a corresponding testing phase, ensuring quality at every step.  
  </p>
  <p>
    Each development stage has a corresponding testing stage.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company is developing a <b>college management system</b>. <br>
      - Requirement Analysis ‚Üí Create requirement document.<br>
      - System Design ‚Üí Prepare system architecture.<br>
      - Module Design ‚Üí Design student registration module.<br>
      - Coding ‚Üí Implement the module.<br>
      - Unit Testing ‚Üí Test the registration module.<br>
      - Integration Testing ‚Üí Combine modules like registration + fee payment.<br>
      - System Testing ‚Üí Test the entire system.<br>
      - Acceptance Testing ‚Üí Client validates that the system meets requirements.
    </p>
  </div>

  <h4>V-Model (Verification & Validation)</h4>

  <div class="vmodel">
    <div class="v-left">
      <div class="step">Requirement Analysis</div>
      <div class="arrow">‚¨áÔ∏è</div>
      <div class="step">System Design</div>
      <div class="arrow">‚¨áÔ∏è</div>
      <div class="step">Architectural Design</div>
      <div class="arrow">‚¨áÔ∏è</div>
      <div class="step">Module Design</div>
    </div>

    <div class="v-middle">
      <div class="step">Coding</div>
    </div>

    <div class="v-right">
      <div class="step">Unit Testing</div>
      <div class="arrow">‚¨ÜÔ∏è</div>
      <div class="step">Integration Testing</div>
      <div class="arrow">‚¨ÜÔ∏è</div>
      <div class="step">System Testing</div>
      <div class="arrow">‚¨ÜÔ∏è</div>
      <div class="step">Acceptance Testing</div>
    </div>
  </div>

  <p style="text-align:center;"> Verification on the left side, validation on the right side. Each development step has a corresponding test step.</p>

  <h4>Advantages:</h4>
  <ul>
    <li>Structured and easy to understand.</li>
    <li>Each phase has a corresponding test, improving quality.</li>
    <li>Early detection of defects in design phases.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Not flexible for changing requirements.</li>
    <li>Better suited for small to medium projects.</li>
  </ul>
    
  <hr>

  <!-- Prototyping Model -->
  <h3>7. Prototyping Model</h3>
  <p>
    The <b>Prototype Model</b> is a <b>software process model</b> where a <b>quick working version</b> of the system is built first. <br> 
    The prototype is shown to the client for feedback, refined, and finally used to develop the complete system.
  </p>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company is developing a <b>library management system</b>. <br>
      - Build a prototype showing basic features: book catalog, search, and issue/return. <br>
      - Client reviews and requests changes like adding fine calculation. <br>
      - Prototype is refined based on feedback. <br>
      - Once approved, the final system is developed with all requested features.
    </p>
  </div>

  <h4>Prototyping Model</h4>
  <div class="model">
    <div class="row">
      <div class="step">Requirement</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Quick Design</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Build Prototype</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Client Evaluation / Feedback</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Refine & Improve Prototype</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Develop Final System</div>
    </div>
    <p>Repeat prototype refinement until the client is satisfied. Then finalize the system for deployment.</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Early client feedback ensures requirements are correct.</li>
    <li>Reduces misunderstanding and development risk.</li>
    <li>Reduces the risk of user dissatisfaction.</li>

  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Frequent changes can increase time and cost.</li>
    <li>May lead to confusion between prototype and final system.</li>
    <li>Not suitable for very large or complex projects.</li>
  </ul>

  <hr>

  <!-- RAD Model -->
  <h3>8. RAD (Rapid Application Development) Model</h3>
  <p>
    The <b>RAD Model</b> is a <b>software process model</b> focused on <b>fast development</b> using <b>reusable components</b> existing code, or purchased modules or prototypes. <br> 
    with constant user feedback. It emphasizes <b>speed over planning</b>, using reusable components and tools to build the software quickly. <br>
    It is suitable for small to medium projects where quick delivery is important.
  </p>

  <ul>
    <li>Build from existing code or modules if available.</li>
    <li>Buy from external vendors if it meets cost and time estimates.</li>
    <li>Otherwise, develop the required modules internally.</li>
  </ul>

  <div class="example">
    <h4>Example:</h4>
    <p>
      Developing a <b>small e-commerce website</b>:<br>
      - Business Model: Analyze what the client wants (catalog, payment, shipping).<br>
      - Data Model: Identify products, users, orders entities.<br>
      - Process Model: Assemble modules like shopping cart, payment gateway.<br>
      - Application & Development: Integrate and code any missing modules.<br>
      - Testing & Turnover: Test and deliver to client quickly.
    </p>
  </div>

  <h4>RAD Model (Rapid Application Development)</h4>

  <div class="model">
    <div class="loop">
      <div class="step">Business Modeling</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Data Modeling</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Process Modeling</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Application Generation</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Testing & Turnover</div>
    </div>
    <p>‚öôÔ∏è Each phase involves user feedback for faster delivery.</p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Faster development and delivery.</li>
    <li>Users are actively involved, improving satisfaction.</li>
    <li>Reusable components reduce coding effort.</li>
    <li>Flexibility to make changes during development.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires highly skilled developers.</li>
    <li>Not suitable for large, complex systems with strict requirements.</li>
    <li>Too much user involvement may lead to scope creep.</li>
  </ul>

  <hr>

  <h3>9. Win-Win Spiral Model</h3>
  <p>
    The <b>Win-Win Spiral Model</b> is an <b>improved version of the Spiral Model</b> developed by <b>Barry Boehm</b>.  
    It focuses on achieving a <b>‚Äúwin-win‚Äù situation</b> between all stakeholders ‚Äî developers, clients, and users.  
    The goal is to make sure that <b>everyone‚Äôs objectives are satisfied</b> before moving to the next phase.
  </p>

  <div class="model">
    <div class="loop">
      <div class="step">Identify Objectives</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Resolve Conflicts</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Develop & Validate</div>
      <div class="arrow">‚û°Ô∏è</div>
      <div class="step">Review & Agreement</div>
    </div>
    <p>üîÅ Each cycle ensures that all parties ‚Äúwin‚Äù by agreeing on goals, risks, and deliverables before proceeding.</p>
  </div>

  <h4>Phases:</h4>
  <ul>
    <li><b>1. Objective Identification:</b> Identify goals, constraints, and success criteria for all stakeholders.</li>
    <li><b>2. Conflict Resolution:</b> Resolve any disagreements to ensure mutual understanding.</li>
    <li><b>3. Development & Validation:</b> Build, test, and validate the product increment.</li>
    <li><b>4. Customer Review:</b> Review progress and gain approval before the next cycle.</li>
  </ul>

  <div class="example">
    <h4>Example:</h4>
    <p>
      A company developing a <b>custom ERP system</b> for a client.  
      - The client wants low cost and faster delivery.  
      - Developers want enough time for testing and design quality.  
      - Management wants risk-free implementation.  
      All parties discuss and agree on priorities (cost, quality, timeline) before development begins ‚Äî ensuring a ‚Äúwin-win‚Äù for everyone.
    </p>
  </div>

  <h4>Advantages:</h4>
  <ul>
    <li>Encourages collaboration and open communication.</li>
    <li>Minimizes risk through continuous client-developer agreement.</li>
    <li>Reduces rework and misunderstandings.</li>
  </ul>

  <h4>Disadvantages:</h4>
  <ul>
    <li>Requires active involvement of all stakeholders.</li>
    <li>Time-consuming due to frequent discussions and approvals.</li>
    <li>Not suitable for small or simple projects.</li>
  </ul>

  <h3>üîπ Comparison of Software Process Models</h3>

  <table cellspacing="0" cellpadding="8">
    <tr>
      <th>Model</th>
      <th>Approach</th>
      <th>Flexibility</th>
      <th>Client Involvement</th>
      <th>Risk Handling</th>
      <th>Cost</th>
      <th>Best Suited For</th>
    </tr>

    <tr>
      <td><b>Waterfall</b></td>
      <td>Linear sequential</td>
      <td>Very low</td>
      <td>Only at start & end</td>
      <td>Poor</td>
      <td>Low</td>
      <td>Small projects with fixed requirements</td>
    </tr>

    <tr>
      <td><b>Iterative</b></td>
      <td>Repeated improvement cycles</td>
      <td>High</td>
      <td>Moderate (after each iteration)</td>
      <td>Better than Waterfall</td>
      <td>Medium</td>
      <td>Projects needing gradual refinement</td>
    </tr>

    <tr>
      <td><b>Incremental</b></td>
      <td>Build module by module</td>
      <td>High</td>
      <td>After each increment</td>
      <td>Good</td>
      <td>Medium</td>
      <td>Large projects divided into modules</td>
    </tr>

    <tr>
      <td><b>Agile</b></td>
      <td>Iterative + Incremental (Sprints)</td>
      <td>Very High</td>
      <td>Continuous (each sprint)</td>
      <td>Excellent</td>
      <td>Medium to High</td>
      <td>Dynamic projects needing frequent updates</td>
    </tr>

    <tr>
      <td><b>Spiral</b></td>
      <td>Iterative with risk analysis</td>
      <td>High</td>
      <td>Regular feedback</td>
      <td>Very Strong</td>
      <td>High</td>
      <td>Large, high-risk projects</td>
    </tr>

    <tr>
      <td><b>V-Model</b></td>
      <td>Development & testing in parallel</td>
      <td>Low</td>
      <td>Only at milestones</td>
      <td>Moderate</td>
      <td>Medium</td>
      <td>Projects needing strict quality control</td>
    </tr>

    <tr>
      <td><b>Prototype</b></td>
      <td>Build quick mock-ups for feedback</td>
      <td>High</td>
      <td>Very High (continuous feedback)</td>
      <td>Good (early error detection)</td>
      <td>Medium</td>
      <td>Unclear or evolving requirements</td>
    </tr>

    <tr>
      <td><b>RAD</b></td>
      <td>Rapid module development using existing code</td>
      <td>High</td>
      <td>Frequent</td>
      <td>Good</td>
      <td>Low</td>
      <td>Small to medium projects needing fast delivery</td>
    </tr>

    <tr>
      <td><b>Win-Win Spiral</b></td>
      <td>Spiral + stakeholder negotiation</td>
      <td>High</td>
      <td>Very High (every phase)</td>
      <td>Excellent (mutual agreement)</td>
      <td>High</td>
      <td>Complex projects needing collaboration</td>
    </tr>
  </table>

  <p><b>Summary:</b> Waterfall is simple but rigid; Agile and Win-Win Spiral are flexible and client-centric.  
  Spiral-based models are best for high-risk projects, while RAD suits quick, low-cost development.</p>

</section>

<hr>

<h3>Software Requirements Specification (SRS)</h3>

<p>
  The <b>Software Requirements Specification (SRS)</b> is a document that describes the complete behavior, functionality, and constraints of a software system. 
  It defines <b>what the software is going to do</b> and acts as a <b>communication bridge</b> between the customer and the development team. 
  It also serves as a <b>contract</b> between both parties. Once the SRS is verified and approved by the customer, the actual development process begins.
</p>

<h4>Example ‚Äì Library Management System</h4>
<ul>
  <li><b>Functional Requirements (What the system should do):</b> Add new books, issue books to students, calculate fines.</li>
  <li><b>Non-Functional Requirements (How the system should perform):</b> System must respond within 2 seconds, support 100 concurrent users, ensure data security and quality performance.</li>
  <li><b>Constraints:</b> Must work on Windows 10 or above, and use MySQL as the database.</li>
</ul>

<h4>Purpose of SRS</h4>
<ul>
  <li>Establishes communication between the customer, analyst, system designer, developer, and maintainer.</li>
  <li>Acts as a contract between the customer and developer.</li>
  <li>Reduces developer effort by providing clarity of requirements.</li>
  <li>Helps in cost estimation and project planning.</li>
  <li>Provides a clear understanding of software development objectives.</li>
  <li>Assists in verification and validation of the system.</li>
</ul>

<h4>Components of SRS</h4>
<ol>
  <li><b>Introduction:</b> Overview, purpose, scope of the system, project information, references, and definitions.</li>
  <li><b>Overall Description:</b> System perspective, user characteristics, constraints, and assumptions.</li>
  <li><b>Specific Requirements:</b> Detailed functional and non-functional requirements, interface, and performance specifications.</li>
  <li><b>External Interface Requirements:</b> User interfaces, hardware interfaces, software interfaces, system interfaces, and communication interfaces.</li>
  <li><b>Other Non-Functional Requirements:</b> Performance, safety, security, reliability, maintainability, scalability, and compliance requirements.</li>
  <li><b>Other Requirements:</b> Terminology and definition list.</li>
  <li><b>Constraints:</b> Budget, deadlines, and rules to be followed.</li>
</ol>

<h4>Characteristics of a Good SRS</h4>
<p>
  A good SRS should be:
  <b>Correct</b>, <b>Consistent</b>, <b>Verifiable</b>, <b>Unambiguous</b>, <b>Traceable</b>, and <b>Ranked for importance</b>.
</p>

<h4>Advantages</h4>
<ul>
  <li>Provides a clear understanding of system requirements for both developers and clients.</li>
  <li>Reduces miscommunication and ambiguity.</li>
  <li>Serves as a reference for validation, verification, and future maintenance.</li>
</ul>

<h4>Disadvantages</h4>
<ul>
  <li>Creating a detailed SRS can be time-consuming.</li>
  <li>Frequent requirement changes can make the SRS outdated quickly.</li>
  <li>Too much detail may overwhelm developers or stakeholders.</li>
</ul>

<hr>

<h3>List of Documents Maintained in a Software Project</h3>
<div class="note">
  <p>The following documents are maintained during a software project to ensure clarity, tracking, and proper communication throughout the Software Development Life Cycle (SDLC).</p>

  <ol>
    <li>
      <b>Project Proposal / Feasibility Study</b><br>
      Defines the <b>scope, goal, and objectives</b> of the project. It also checks the <b>technical, operational, and economic feasibility</b> before development starts.
      <ul>
        <li><b>Technical Feasibility:</b> Can the project be built with current technology?</li>
        <li><b>Economic Feasibility:</b> Is it financially affordable?</li>
        <li><b>Operational Feasibility:</b> Will it solve the organization‚Äôs problems effectively?</li>
        <li><b>Legal Feasibility:</b> Are there any legal or regulatory issues?</li>
        <li><b>Schedule Feasibility:</b> Can it be completed on time?</li>
      </ul>
    </li>

    <li>
      <b>SRS (Software Requirement Specification)</b><br>
      Contains all <b>functional</b> and <b>non-functional requirements</b> of the software. It acts as an agreement between the <b>client and the developer</b>.
    </li>

    <li>
      <b>System Design Document (SDD)</b><br>
      Describes the <b>architecture, data flow, ER diagrams, components,</b> and <b>system structure</b>. It converts the requirements into a detailed design plan.
    </li>

    <li>
      <b>Project Plan / Schedule</b><br>
      Specifies the <b>timeline, milestones, resources, cost estimation,</b> and <b>team responsibilities</b> to manage and track project progress.
    </li>

    <li>
      <b>Test Case / Test Plan</b><br>
      Includes the <b>test inputs, expected outputs, and conditions</b> used to verify that the software meets the requirements and functions correctly.
    </li>

    <li>
      <b>Source Code Document</b><br>
      Contains the <b>actual program code, folder structure, naming conventions,</b> and <b>environment details</b> used for development.
    </li>

    <li>
      <b>User Manual / User Guide</b><br>
      Helps <b>end-users</b> understand how to <b>install, operate,</b> and <b>troubleshoot</b> the software effectively.
    </li>

    <li>
      <b>Maintenance Report / Log</b><br>
      Records all <b>post-deployment activities</b> such as <b>bug fixes, updates, performance improvements,</b> and version control.
    </li>
  </ol>
</div>

<hr>

<h3>List of Documents Maintained in a Project</h3>

<h4>1. Business Requirement Document (BRD)</h4>
<p>
  This document explains <b>why</b> the project is being built and outlines the <b>goals</b> of the project.
</p>
<p><b>Prepared by:</b> Business stakeholders, project sponsors</p>
<h5>Contents:</h5>
<ul>
  <li>Business goals and objectives</li>
  <li>Stakeholders involved</li>
  <li>High-level project scope and boundaries</li>
  <li>Expected deliverables (outputs or results to be completed)</li>
  <li>Timeline and constraints</li>
  <li>Business rules and regulations</li>
</ul>

<h4>2. Scope Document</h4>
<p>
  Defines the <b>scope</b> of the project ‚Äî what is included and what is excluded.
</p>
<p><b>Prepared by:</b> Project manager, development team</p>
<h5>Contents:</h5>
<ul>
  <li>Detailed list of features and functionalities to be delivered</li>
  <li>Definition of in-scope vs. out-of-scope items</li>
  <li>Assumptions, constraints, and dependencies</li>
</ul>

<h4>3. Software Requirement Specification (SRS)</h4>
<p>
  Describes the complete behavior, functionality, and constraints of a software system.
</p>
<p><b>Prepared by:</b> Developers, testers, technical team</p>
<h5>Contents:</h5>
<ul>
  <li>Functional requirements (what the system should do)</li>
  <li>Non-functional requirements (performance, security, scalability)</li>
  <li>User interface and system interfaces</li>
  <li>Constraints, assumptions, and dependencies</li>
</ul>

<h4>4. Document of Understanding (DOU)</h4>
<p>
  Sets out an agreement between the client and the team about project objectives, deliverables, and terms.
</p>
<p><b>Involved Parties:</b> Client, vendor, service provider, project manager</p>
<h5>Contents:</h5>
<ul>
  <li>Project objectives and deliverables</li>
  <li>Roles and responsibilities of each party</li>
  <li>Terms and conditions (service level agreements, timelines, costs)</li>
</ul>

<h4>5. Architecture Design Document (ADD)</h4>
<p>
  Describes the system architecture and design, showing how it will meet the requirements defined in the SRS.
</p>
<p><b>Prepared by:</b> Developers, architects, technical lead</p>
<h5>Contents:</h5>
<ul>
  <li>High-level architecture</li>
  <li>Detailed component designs (UI, backend, etc.)</li>
  <li>Design patterns and technologies used</li>
</ul>

<h4>6. Database Design Document (DBD)</h4>
<p>
  Defines the structure and design of the database, including how data will be stored and related.
</p>
<p><b>Prepared by:</b> Database administrator, developer</p>
<h5>Contents:</h5>
<ul>
  <li>Entity-relationship diagrams (ERD)</li>
  <li>Tables, fields, and relationships</li>
  <li>Indexing, normalization, and data integrity rules</li>
</ul>

<h4>7. Functional Specification Document (FSD)</h4>
<p>
  Describes the software‚Äôs features and functionality from a user‚Äôs perspective.
</p>
<p><b>Prepared by:</b> Developers, testers</p>
<h5>Contents:</h5>
<ul>
  <li>List of features</li>
  <li>UI/UX flow and design</li>
  <li>Input and output specifications</li>
  <li>Business rules and exceptions</li>
</ul>

<h4>8. Integration Document</h4>
<p>
  Describes how different systems, services, or components will interact and integrate with each other.
</p>
<p><b>Prepared by:</b> Developers, integration specialists, system architects</p>
<h5>Contents:</h5>

<ul>
  <li><b>API Specifications:</b>
    <ul>
      <li>Defines communication methods with external services via APIs.</li>
      <li>Example:<br>
      <code>GET /api/services?category=balance</code><br>
      Parameters: <code>category</code> (e.g., balance, withdraw)
      </li>
    </ul>
  </li>

  <li><b>Data Transfer Protocols (JSON, XML, PHP):</b>
    <ul>
      <li>Defines the format for data exchange between systems.</li>
      <li>Example: JSON for APIs, XML for legacy systems.</li>
    </ul>
  </li>

  <li><b>Integration Points and Flow:</b>
    <ul>
      <li>Describes how systems connect and interact.</li>
      <li>Example ‚Äì Payment Gateway Integration:
        <ol>
          <li>User initiates payment.</li>
          <li>Frontend sends request to backend.</li>
          <li>Backend calls external payment API (e.g., Stripe).</li>
          <li>API responds with success or failure.</li>
          <li>Backend updates user with payment status.</li>
        </ol>
      </li>
    </ul>
  </li>

  <li><b>Error Handling and Logging:</b>
    <ul>
      <li>Defines how integration errors are managed and logged.</li>
      <li>Example: <code>ERROR: Payment API request failed. Response Code: 500</code></li>
    </ul>
  </li>
</ul>

<h4>9. Schedule Document</h4>
<p>
  A plan outlining when each part of the project will be completed, including milestones and deadlines.
</p>
<p><b>Prepared by:</b> Project managers</p>
<h5>Contents:</h5>
<ul>
  <li>Detailed project schedule (start and end dates)</li>
  <li>Milestones and key deliverables</li>
  <li>Resource allocation and dependencies</li>
</ul>

<h4>10. Test Case Document</h4>
<p>
  Defines test cases and scenarios to ensure the system works as expected.
</p>
<p><b>Prepared by:</b> QA testers, developers</p>
<h5>Contents:</h5>
<ul>
  <li>Test case ID, description, and expected result</li>
  <li>Preconditions, test steps, and postconditions</li>
  <li>Expected outcomes (success/failure)</li>
</ul>

<h4>11. User Manual Document</h4>
<p>
  Provides instructions and guidance for end-users on how to use the software.
</p>
<p><b>Prepared for:</b> End users</p>
<h5>Contents:</h5>
<ul>
  <li>Step-by-step usage instructions</li>
  <li>Screenshots and UI walkthroughs</li>
  <li>Troubleshooting tips</li>
</ul>

<h4>12. Deployment Checklist Document</h4>
<p>
  A checklist ensuring the system is properly deployed and configured in production.
</p>
<p><b>Prepared by:</b> Developers, system administrators</p>
<h5>Contents:</h5>
<ul>
  <li>Pre-deployment checks (backups, configurations)</li>
  <li>Deployment steps (code migration, database updates)</li>
  <li>Post-deployment validation (system health checks)</li>
</ul>

<h4>13. Frontend and Admin Login Document</h4>
<p>
  Defines the login process, permissions, and access levels for users and administrators.
</p>
<p><b>Prepared by:</b> Developers, testers</p>
<h5>Contents:</h5>
<ul>
  <li>User authentication process</li>
  <li>Frontend and backend login flow</li>
  <li>Role-based access control (RBAC) details</li>
</ul>

<h4>14. Enhancement and Change Document</h4>
<p>
  Tracks system changes or enhancements after initial release.
</p>
<p><b>Prepared by:</b> Development team, project manager</p>
<h5>Contents:</h5>
<ul>
  <li>Details of requested changes/enhancements</li>
  <li>Justification for changes</li>
  <li>Impact on system functionality and performance</li>
</ul>

<h4>15. Support Tracker Document</h4>
<p>
  Records user issues and problems after software deployment.
</p>
<p><b>Maintained by:</b> Support team</p>
<h5>Contents:</h5>
<ul>
  <li>Issue ID, description, and priority</li>
  <li>Status (open, in progress, resolved)</li>
  <li>Resolution steps</li>
</ul>

<h4>16. Engineers and Client List Document</h4>
<p>
  Lists all people involved in the project, including team members and clients.
</p>
<p><b>Prepared by:</b> Project manager, team lead</p>
<h5>Contents:</h5>
<ul>
  <li>Names of engineers, developers, testers, and clients</li>
  <li>Contact details and responsibilities</li>
</ul>

<h4>17. Resource Tracker Document</h4>
<p>
  Tracks allocation and usage of project resources (team, tools, equipment).
</p>
<p><b>Prepared by:</b> Project manager, team lead</p>
<h5>Contents:</h5>
<ul>
  <li>Resource allocation (who is working on what)</li>
  <li>Resource utilization and availability</li>
  <li>Capacity planning</li>
</ul>

<h4>18. Release Note Document</h4>
<p>
  Summarizes new features, bug fixes, and changes for each software release.
</p>
<p><b>Prepared by:</b> Support team, testers</p>
<h5>Contents:</h5>
<ul>
  <li>Version number and release date</li>
  <li>New features, enhancements, and fixes</li>
  <li>Known issues and workarounds</li>
</ul>

<h4>19. Sign-Off Tracker Document</h4>
<p>
  Tracks approvals for different project stages such as design, development, and testing.
</p>
<p><b>Prepared by:</b> Project manager, client</p>
<h5>Contents:</h5>
<ul>
  <li>Stakeholder sign-offs with date and comments</li>
  <li>Approval conditions</li>
</ul>

<h4>20. Workflow (or) Network Document</h4>
<p>
  Describes the flow of tasks, processes, and responsibilities in the project.
</p>
<p><b>Prepared by:</b> Developers, team lead, project manager</p>
<h5>Contents:</h5>
<ul>
  <li>Process diagrams (flowcharts, swimlane diagrams)</li>
  <li>Task dependencies</li>
  <li>Roles and responsibilities</li>
</ul>

<h4>21. Training Document</h4>
<p>
  Provides training materials for users and administrators.
</p>
<p><b>Prepared by:</b> Support engineers</p>
<h5>Contents:</h5>
<ul>
  <li>User guides and documentation</li>
  <li>Training sessions and agendas</li>
  <li>FAQs and troubleshooting tips</li>
</ul>

<h4>22. Port Opening Document</h4>
<p>
  Specifies which network ports must be opened for communication between systems.
</p>
<p><b>Prepared by:</b> Network engineers, system administrators</p>
<h5>Contents:</h5>
<ul>
  <li>List of ports, protocols, and IP addresses</li>
  <li>Security considerations</li>
</ul>

<h4>23. Load Test Document</h4>
<p>
  Describes performance testing to ensure the system can handle heavy user traffic.
</p>
<p><b>Prepared by:</b> QA testers, performance engineers</p>
<h5>Contents:</h5>
<ul>
  <li>Test scenarios and load conditions (e.g., number of users, transaction types)</li>
  <li>Load testing tools and configurations</li>
  <li>Performance metrics and thresholds</li>
</ul>

<hr>
<h3>Project Management</h3>
<p>
  <b>Project Management</b> is the process that spans from the initial requirement gathering to deployment. <br>
  <b>Who all involved:</b> Project Manager, Team Lead
</p>

<h4>4 Factors of Project Management:</h4>
<ul>
  <li><b>People:</b> Who all work on the project.</li>
  <li><b>Project:</b> The task being executed for a client or organization.</li>
  <li><b>Product:</b> A project aligned with current company trends or market needs.</li>
  <li><b>Process:</b> The steps involved in creating and completing the project.</li>
</ul>

<h4>Software Team Types:</h4>
<ol>
  <li><b>Democratic Decentralized:</b> No team lead. The team members, with client collaboration, complete the project and modules collectively.</li>
  <li><b>Controlled Decentralized:</b> Multiple team leads. Each lead manages specific aspects of the project, with different teams working on various components.</li>
  <li><b>Controlled Centralized:</b> A single team lead oversees and allocates work to the team based on project needs.</li>
</ol>

<h4>Project Failure Reasons:</h4>
<ul>
  <li>Lack of time management</li>
  <li>Lack of resources</li>
  <li>Budget issues</li>
  <li>Not meeting client needs</li>
  <li>No proper documentation</li>
  <li>Poor team handling</li>
  <li>Technology changes</li>
  <li>Client drops the project</li>
  <li>Environmental problems</li>
  <li>Sponsorship losses</li>
  <li>Misunderstanding within the team</li>
</ul>

<h4>To Avoid Failure:</h4>
<ul>
  <li>Maintain regular interaction between the client and developer.</li>
  <li>Track the progress of the team consistently.</li>
  <li>Test the project thoroughly.</li>
  <li>Update the project status to the customer periodically.</li>
</ul>

<h3>Change Management</h3>
<div class="note">
  <p>
    Change Management is the process of handling <b>modifications in a software project</b>.  
    It is a systematic process for <b>planning, implementing, and monitoring</b> changes to software systems 
    to <b>minimize risks</b> and <b>maximize benefits</b>.
  </p>

  <h4>Steps in Change Management:</h4>
  <ol>
    <li><b>Request and Identification:</b> A change is requested due to <b>business needs, user feedback, or market shifts</b>.</li>
    <li><b>Analysis:</b> Evaluate the impact of the change on the system, users, project timeline, and budget.</li>
    <li><b>Approval / Rejection:</b> The <b>Change Control Board (CCB)</b> and stakeholders review and decide whether to approve or reject the change.</li>
    <li><b>Implementation:</b> If approved, developers make the necessary changes in code or design.</li>
    <li><b>Testing and Verification:</b> The new changes are tested to ensure they don't affect existing functionality.</li>
    <li><b>Deployment and Monitoring:</b> The updated feature is deployed and monitored to ensure it works as expected.</li>
    <li><b>Documentation and Review:</b> All relevant project documents are updated with the change details.</li>
  </ol>

  <h4>Example:</h4>
  <p>
    In a <b>mobile banking app</b>, users request to add a ‚ÄúDark Mode‚Äù feature.
  </p>
  <ol>
    <li>A change request is raised.</li>
    <li>Developers analyze its feasibility, check UI impact, required resources, and budget.</li>
    <li>The Project Manager approves the change.</li>
    <li>The feature is implemented, tested, deployed, and recorded in the change log.</li>
  </ol>
</div>

<h3>Risk Management</h3>
<p>
  <b>Risk Management</b> involves identifying, analyzing, and controlling potential risks to a project's success. <br>
  Risk involves uncertainty and potential losses. <br>
  Risk analysis and management help a software team understand and manage uncertainty during the development process.
</p>

<h4>Key Phases of Risk Management:</h4>
<ol>
  <li>Identify Risks</li>
  <li>Analyze and Prioritize Risks</li>
  <li>Plan and Schedule Risk Responses</li>
  <li>Track and Report Risk Status</li>
  <li>Control and Mitigate Risks</li>
  <li>Learn from Risks</li>
  <li>Document Lessons Learned</li>
</ol>

<h4>Steps:</h4>
<ul>
  <li><b>Risk Identification:</b> List all possible risks that could affect the project. 
      <br>Example: Schedule delay, budget overrun, technology failure.</li>
  <li><b>Analysis:</b> Estimate the probability of each risk and potential impact on the project.</li>
  <li><b>Risk Response Planning:</b> Develop strategies and plans to address the identified risks.</li>
  <li><b>Risk Monitoring and Control:</b> Track the status of risks and the effectiveness of plans throughout the project lifecycle.</li>
</ul>

<h4>Types of Risk:</h4>

<h5>1. Project Risk</h5>
<p>
  Project risks are factors that could cause the project to fail or adversely affect its objectives.
</p>
<h5>Key Project Risks:</h5>
<ul>
  <li><b>System/Technology Complexity:</b> Complex systems can fail or introduce unforeseen challenges.</li>
  <li><b>Client or Target Environment:</b> Changes or lack of understanding in the client environment can impact project success.</li>
  <li><b>Team Environment:</b> Lack of skill, motivation, or poor communication within the team.</li>
  <li><b>Business Risks:</b> Changes in business goals, strategies, or external factors like regulatory changes.</li>
</ul>

<h5>2. Technical Risk</h5>
<p>
  Technical risks refer to the possibility that technology, software, or systems could fail to meet requirements or cause issues during implementation.
</p>
<h5>Examples:</h5>
<ul>
  <li>Technology chosen for the project may not scale.</li>
  <li>Integration challenges with existing infrastructure.</li>
  <li>Unforeseen technical debt or legacy system issues.</li>
</ul>

<h5>3. Business Risk</h5>
<p>
  These risks affect the overall business, including revenue, budget, and strategic alignment.
</p>
<h5>Examples:</h5>
<ul>
  <li>Loss of revenue if the project does not meet business objectives.</li>
  <li>Budget overruns that impact business profitability.</li>
  <li>Failure to meet market expectations or deliverables.</li>
</ul>

<h4>Risk Identification:</h4>
<p>
  The process of determining risks that could potentially prevent the program, enterprise, or investment from achieving its objectives. <br>
  It includes documenting and communicating the concerns. <br>
  Risk identification involves recognizing risks that might affect the project and documenting their characteristics. <br>
  Risk management is an <b>iterative process</b>.
</p>

<h4>Diagram:</h4>
<p>
  <b>Identify Risks ‚û°Ô∏è Analyze Risks ‚û°Ô∏è Rank and Evaluate Risks ‚û°Ô∏è Treat the Risks ‚û°Ô∏è Monitor & Review Risks</b>
</p>

<hr>

<h3>PCI DSS (Payment Card Industry Data Security Standard)</h3>
<p>
  <b>PCI DSS</b> stands for <b>Payment Card Industry Data Security Standard</b>. <br>
  It is a set of rules and practices that businesses must follow to keep <b>credit card information safe</b>. <br>
  PCI DSS defines <b>security standards</b> to ensure that all companies that process, store, or transmit credit card information 
  maintain a <b>secure environment</b> to protect that data.
</p>

<h4>Key Principles of PCI DSS:</h4>
<p>The PCI DSS has <b>12 main requirements</b> grouped into six key principles:</p>

<ol>
  <li>
    <b>Build and Maintain a Secure Network and Systems (Secure Network)</b>
    <ul>
      <li><b>Requirement 1:</b> Install and maintain a firewall configuration to protect cardholder data. <i>(Firewall Setup)</i></li>
      <li><b>Requirement 2:</b> Do not use vendor-supplied defaults for system passwords and other security parameters. <i>(Change Default Passwords)</i></li>
    </ul>
  </li>

  <li>
    <b>Protect Cardholder Data (Protect Data)</b>
    <ul>
      <li><b>Requirement 3:</b> Protect stored cardholder data. <i>(Protect Stored Data)</i></li>
      <li><b>Requirement 4:</b> Encrypt transmission of cardholder data across open, public networks. <i>(Encrypt Data Transmission)</i></li>
    </ul>
  </li>

  <li>
    <b>Maintain a Vulnerability Management Program (Manage Vulnerabilities)</b>
    <ul>
      <li><b>Requirement 5:</b> Protect all systems against malware and regularly update anti-virus software or programs. <i>(Anti-Malware)</i></li>
      <li><b>Requirement 6:</b> Develop and maintain secure systems and applications. <i>(Apply Security Patches)</i></li>
    </ul>
  </li>

  <li>
    <b>Implement Strong Access Control Measures (Access Control)</b>
    <ul>
      <li><b>Requirement 7:</b> Restrict access to cardholder data by business need to know. <i>(Restrict Access)</i></li>
      <li><b>Requirement 8:</b> Identify and authenticate access to system components. <i>(Unique IDs)</i></li>
      <li><b>Requirement 9:</b> Restrict physical access to cardholder data. <i>(Physical Security)</i></li>
    </ul>
  </li>

  <li>
    <b>Regularly Monitor and Test Networks (Monitor & Test)</b>
    <ul>
      <li><b>Requirement 10:</b> Track and monitor all access to network resources and cardholder data. <i>(Logging & Tracking)</i></li>
      <li><b>Requirement 11:</b> Regularly test security systems and processes. <i>(Regular Testing)</i></li>
    </ul>
  </li>

  <li>
    <b>Maintain an Information Security Policy (Security Policy)</b>
    <ul>
      <li><b>Requirement 12:</b> Maintain a policy that addresses information security for all personnel. <i>(Maintain Security Policy)</i></li>
    </ul>
  </li>
</ol>


</body>
</html>
