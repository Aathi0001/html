<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>JavaNotes</title>
     <style>
          body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      line-height: 1.6;
      padding: 20px;
      color: #333;
    }

    h1, h2, h3 {
      margin-top: 30px;
      border-left: 5px solid #ff6347;
      padding-left: 12px;
      color: #333;
    }

    h1 {
      font-size: 32px;
      color: #e91e63;
    }

    h2 {
      font-size: 26px;
      color: #3f51b5;
    }

    h3 {
      font-size: 22px;
      color: #009688;
    }

    pre {
      background: #eee;
      padding: 10px 15px;
      border-left: 5px solid #607d8b;
      white-space: pre-wrap;
      font-family: 'Consolas', monospace;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin: 4px 0;
    }

    .section {
      margin-bottom: 40px;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 10px;
      border-left: 4px solid #ffc107;
    }
    code {
  background-color: #f0f0f0;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 0.95em;
  color: #c7254e;
}
a {
  color: #007acc;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
hr {
  border: none;
  border-top: 1px solid #ccc;
  margin: 40px 0;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

th, td {
  border: 1px solid #ccc;
  padding: 10px;
  text-align: left;
}

th {
  background-color: #f2f2f2;
}

.button {
  background-color: #4CAF50;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: inline-block;
}

.button:hover {
  background-color: #45a049;
}

     </style>
</head>
<body>
   <div class="section">
  <h1>What is Java?</h1>
  <p>
    Java is a <strong>high-level, class-based, object-oriented</strong> programming language designed to have as few implementation dependencies as possible.
    It was originally developed by <strong>James Gosling </strong>at <strong>Sun Microsystems</strong> and released in 1995.  
  </p>
  <p>
    Java is designed to let application developers write once, run anywhere (<em>WORA</em>), meaning that compiled Java code can run on all platforms that support Java without the need for recompilation.
  </p>

  <h2>Features of Java</h2>
  <ul>
    <li><strong>Simple:</strong> Easy to learn and understand.</li>
    <li><strong>Object-Oriented:</strong> Everything is treated as an object.</li>
    <li><strong>Platform Independent:</strong> Java code runs on any platform using the JVM.</li>
    <li><strong>Secure:</strong> Java provides a secure runtime environment.</li>
    <li><strong>Robust:</strong> Strong memory management and exception handling.</li>
    <li><strong>Multithreaded:</strong> Java supports multithreaded programming.</li>
    <li><strong>Architecture Neutral:</strong> Java programs are not tied to specific hardware.</li>
    <li><strong>Portable:</strong> Bytecode can be carried and executed anywhere.</li>
    <li><strong>High Performance:</strong> With Just-In-Time compilers, performance improves.</li>
    <li><strong>Distributed:</strong> Java has networking capabilities for distributed computing.</li>
    <li><strong>Dynamic:</strong> Java supports dynamic loading of classes at runtime.</li>
  </ul>

  <h2>JVM, JDK, and JRE</h2>
  <p>
    Java applications are compiled into <code>.class</code> files which contain bytecode. This bytecode is platform-independent and is interpreted/executed by the JVM.
  </p>

  <table>
    <thead>
      <tr>
        <th>Component</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>JVM</strong> (Java Virtual Machine)</td>
        <td>It is an engine that provides the runtime environment to execute Java bytecode. JVM makes Java platform-independent.</td>
      </tr>
      <tr>
        <td><strong>JRE</strong> (Java Runtime Environment)</td>
        <td>It includes the JVM and libraries required to run Java applications. It does not contain tools for Java development.</td>
      </tr>
      <tr>
        <td><strong>JDK</strong> (Java Development Kit)</td>
        <td>It includes JRE + development tools like compiler (<code>javac</code>), debugger, etc. Used to develop Java applications.</td>
      </tr>
    </tbody>
  </table>

  <div class="highlight">
     <strong>Summary:</strong>  
    <ul>
      <li>JVM runs Java bytecode</li>
      <li>JRE = JVM + libraries to run applications</li>
      <li>JDK = JRE + tools to develop applications</li>
    </ul>
  </div>
</div>
  
<hr>

<div class="section">
  <h1>Java Syntax and Data Types</h1>
  
  <h2>Basic Java Syntax</h2>
  <p>
    Java programs are made up of classes and methods. The <code>main()</code> method is the entry point of any Java program.
  </p>

  <pre>
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
  </pre>

  <ul>
    <li><code>public class Main</code> → defines a class named <code>Main</code></li>
    <li><code>public static void main(String[] args)</code> → main method where execution begins</li>
    <li><code>System.out.println</code> → used to print text to the console</li>
  </ul>

  <div class="highlight">
    🔹 Java is <strong>case-sensitive</strong>. For example, <code>main</code> is different from <code>Main</code>.
  </div>

<hr>

  <h2>Variables and Data Types</h2>
  <p>
    A <strong>variable</strong> is a container which holds the value while the Java program is executed.
    Each variable must be declared with a <strong>data type</strong>.
  </p>

  <h3>Primitive Data Types</h3>
  <ul>
    <li><code>byte</code> – 1 byte, range: -128 to 127</li>
    <li><code>short</code> – 2 bytes, range: -32,768 to 32,767</li>
    <li><code>int</code> – 4 bytes, commonly used for integers</li>
    <li><code>long</code> – 8 bytes, larger integer values</li>
    <li><code>float</code> – 4 bytes, single-precision decimal</li>
    <li><code>double</code> – 8 bytes, double-precision decimal</li>
    <li><code>char</code> – 2 bytes, stores a single character like 'A'</li>
    <li><code>boolean</code> – 1 bit, stores <code>true</code> or <code>false</code></li>
  </ul>

  <h3>Example: Declaring Variables</h3>
  <pre>
int age = 25;
float pi = 3.14f;
char grade = 'A';
boolean isJavaFun = true;
  </pre>

  <div class="highlight">
    🔹 <strong>Note:</strong> Use <code>f</code> or <code>F</code> at the end of float values.  
    🔹 Use <code>L</code> or <code>l</code> for long values (e.g., <code>long id = 1234567890L;</code>).
  </div>

  <h3>Reference Data Types</h3>
  <ul>
    <li><code>String</code> – represents a sequence of characters</li>
    <li>Arrays</li>
    <li>Classes</li>
    <li>Interfaces</li>
  </ul>

  <pre>
String name = "Aathi";
  </pre>

  <div class="highlight">
    ✅ All non-primitive types are reference types. They store the memory address (reference) of the object, not the actual value.
  </div>

</div>

<hr>

<div class="section">
  <h1>Operators in Java</h1>

  <p>
    An <strong>operator</strong> is a predefined symbol used to perform operations on operands.  
    Based on the number of operands they accept, Java operators are classified into:
  </p>
  
  <ul>
    <li><strong>Unary Operators</strong> – Operate on one operand</li>
    <li><strong>Binary Operators</strong> – Operate on two operands</li>
    <li><strong>Ternary Operator</strong> – Works on three operands</li>
  </ul>

  <h2>Arithmetic Operators</h2>
  <p>Used for basic mathematical calculations.</p>
  <ul>
    <li><code>+</code> : Addition</li>
    <li><code>-</code> : Subtraction</li>
    <li><code>*</code> : Multiplication</li>
    <li><code>/</code> : Division</li>
    <li><code>%</code> : Modulo (remainder)</li>
  </ul>

  <h2>Unary Operators</h2>
  <p>Operate on a single operand.</p>
  <ul>
    <li><code>+</code> : Unary plus</li>
    <li><code>-</code> : Unary minus</li>
    <li><code>++</code> : Increment (prefix/postfix)</li>
    <li><code>--</code> : Decrement (prefix/postfix)</li>
    <li><code>!</code> : Logical NOT (inverts boolean value)</li>
  </ul>

  <h2>Assignment Operators</h2>
  <p>Used to assign values to variables.</p>
  <ul>
    <li><code>=</code> : Simple assignment</li>
    <li><code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code> : Compound assignments</li>
  </ul>

  <h2>Relational (Comparison) Operators</h2>
  <p>Used to compare values and return a boolean.</p>
  <ul>
    <li><code>==</code> : Equal to</li>
    <li><code>!=</code> : Not equal to</li>
    <li><code>&gt;</code> : Greater than</li>
    <li><code>&lt;</code> : Less than</li>
    <li><code>&gt;=</code> : Greater than or equal to</li>
    <li><code>&lt;=</code> : Less than or equal to</li>
  </ul>

  <h2>Logical Operators</h2>
  <p>Used for boolean logic.</p>
  <ul>
    <li><code>&&</code> : Logical AND</li>
    <li><code>||</code> : Logical OR</li>
    <li><code>!</code> : Logical NOT</li>
  </ul>

  <h2>Bitwise Operators</h2>
  <p>Work at the bit level on integer data types.</p>
  <ul>
    <li><code>&</code> : Bitwise AND</li>
    <li><code>|</code> : Bitwise OR</li>
    <li><code>^</code> : Bitwise XOR</li>
    <li><code>~</code> : Bitwise Complement</li>
  </ul>

  <h2>Shift Operators</h2>
  <p>Used to shift bits left or right.</p>
  <ul>
    <li><code>&lt;&lt;</code> : Left shift</li>
    <li><code>&gt;&gt;</code> : Signed right shift</li>
    <li><code>&gt;&gt;&gt;</code> : Unsigned right shift</li>
  </ul>

  <h2>Ternary Operator</h2>
  <p>Shorthand for if-else.</p>
  <pre>
condition ? expression1 : expression2;
  </pre>
  <p>Example:</p>
  <pre>
int max = (a > b) ? a : b;
  </pre>

  <h2>instanceof Operator</h2>
  <p>
    Used to check if an object is an instance of a particular class or interface.
  </p>
  <pre>
if (obj instanceof String) {
    System.out.println("It's a String!");
}
  </pre>

<hr>

  <h1>Input / Output in Java</h1>

  <h2>Using <code>Scanner</code> Class</h2>
  <p>
    Java provides the <code>Scanner</code> class (in <code>java.util</code> package) for reading user input.
    Example:
  </p>
  <pre>
import java.util.Scanner;

Scanner sc = new Scanner(System.in);
int age = sc.nextInt();
String name = sc.next();
  </pre>

  <h3>Scanner Methods by Data Type</h3>

  <table>
    <thead>
      <tr>
        <th>Data Type</th>
        <th>Method</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>int</td><td><code>nextInt()</code></td></tr>
      <tr><td>long</td><td><code>nextLong()</code></td></tr>
      <tr><td>float</td><td><code>nextFloat()</code></td></tr>
      <tr><td>double</td><td><code>nextDouble()</code></td></tr>
      <tr><td>byte</td><td><code>nextByte()</code></td></tr>
      <tr><td>short</td><td><code>nextShort()</code></td></tr>
      <tr><td>boolean</td><td><code>nextBoolean()</code></td></tr>
      <tr><td>char</td><td><code>next().charAt(0)</code></td></tr>
      <tr><td>String (word)</td><td><code>next()</code></td></tr>
      <tr><td>String (line)</td><td><code>nextLine()</code></td></tr>
    </tbody>
  </table>

  <div class="highlight">
  🔹 <strong>Note:</strong><br>
   <strong>next()</strong> reads input only until the first space (single word).<br>
   <strong>nextLine()</strong> reads the entire line until the user hits Enter.<br>
  📌 Example:<br>
  <code>String name = sc.next();</code> → input: <code>Aathi</code><br>
  <code>String sentence = sc.nextLine();</code> → input: <code>My name is Aathi</code>
</div>
</div>

<hr>

<div class="section">
  <h1>Typecasting in Java</h1>

  <p>
    Typecasting is the process of converting one data type into another. It is broadly classified into:
  </p>

  <ul>
    <li><strong>Primitive Typecasting</strong></li>
    <li><strong>Non-Primitive (Reference) Typecasting</strong></li>
  </ul>

  <h2>Non-Primitive Typecasting</h2>
  <p>
    Converting one non-primitive data type (class) into another. It is only possible when:
    <ul>
      <li>There is an <strong>is-a relationship</strong> (inheritance), or</li>
      <li>There is a <strong>common child relationship</strong>.</li>
    </ul>
  </p>

  <h3>Upcasting</h3>
  <ul>
    <li>Converting a child object to a parent reference.</li>
    <li>Done <strong>implicitly</strong> (compiler allows it automatically).</li>
    <li><strong>Compile-time success.</strong></li>
  </ul>

  <pre>
// Example:
A <- B <- C <- D <- E

D ref1 = new E();   // E is a subclass of D
C ref3 = new D();   // D is a subclass of C
  </pre>

  <h3>Downcasting</h3>
  <ul>
    <li>Converting a parent reference to a child type.</li>
    <li>Done <strong>explicitly</strong> using casting syntax.</li>
    <li>We use it to access methods or members specific to the child class.</li>
  </ul>

  <pre>
// Example:
A <- B <- C <- D, E, F

C ref1 = new F();       // Upcasting
// ref1 can only access A, B, C

F ref2 = (F) ref1;      // Downcasting
// Now, we can access A, B, C, and F
  </pre>

  <div class="highlight">
    🔹 <strong>Use downcasting only when you are sure the object is of the correct subclass.</strong><br>
    🔸 Otherwise, it can throw <code>ClassCastException</code> at runtime.
  </div>

  <h2>Primitive Typecasting</h2>
  <p>
    Converting one primitive data type into another.
  </p>

  <h3>Widening (Implicit)</h3>
  <ul>
    <li>Lower range to higher range</li>
    <li>Automatically handled by compiler</li>
  </ul>
  <pre>
int a = 10;
long b = a;     // Widening
  </pre>

  <h3>Narrowing (Explicit)</h3>
  <ul>
    <li>Higher range to lower range</li>
    <li>Needs manual/explicit casting</li>
  </ul>
  <pre>
long a = 100L;
int b = (int) a;   // Narrowing
  </pre>

  <div class="highlight">
    🔹 Use narrowing carefully as it may lead to data loss.
  </div>

  <h2>instanceof Operator</h2>
  <p>
    The <code>instanceof</code> operator checks whether a given object is an instance of a particular class or interface.
  </p>

  <ul>
    <li>It is a <strong>binary operator</strong>.</li>
    <li>Return type is <code>boolean</code>.</li>
    <li>Useful before downcasting to avoid exceptions.</li>
  </ul>

  <pre>
// Syntax:
reference instanceof ClassName

// Example:
if (ref instanceof String) {
    System.out.println("It's a String!");
}
  </pre>

  <div class="highlight">
    ✅ Use <code>instanceof</code> before downcasting to ensure safe type conversion.
  </div>

  <hr>

  <div class="highlight">
    <h3>🔍 Did You Know?</h3>
    <ul>
      <li><strong>ClassCastException:</strong> A runtime exception thrown during invalid downcasting. (already hinted ✅)</li>
      <li><strong>Precedence:</strong> <code>instanceof</code> has lower precedence than most arithmetic/logical operators.</li>
      <li><strong>Common Pitfall:</strong> Using <code>nextLine()</code> after numeric input may need an extra <code>sc.nextLine();</code> to consume newline.</li>
    </ul>
  </div>
</div>

<hr>

<div class="section">
  <h1>Control Flow</h1>

  <h2>Loops</h2>
  <div class="highlight">
    A loop runs the same block of code multiple times until a condition becomes false.
  </div>

  <h3>for loop</h3>
  <ul>
    <li>Used when you know how many times to run the loop.</li>
  </ul>
  <pre>
for(initialization; condition; update){
    // code to repeat
}</pre>

  <h3>while loop</h3>
  <ul>
    <li>Used when you don't know how many times, but want to repeat as long as the condition is true.</li>
  </ul>
  <pre>
while(condition){
    // code to repeat
}</pre>

  <h3>do-while loop</h3>
  <ul>
    <li>Used when you want to run the loop at least once, even if the condition is false.</li>
  </ul>
  <pre>
do{
    // code to repeat
} while(condition);</pre>

  <h2>if, else if, else</h2>
  <div class="highlight">
    This statement helps you make decisions in your program.
  </div>
  <pre>
if(condition1){
    // run if condition1 is true
}
else if(condition2){
    // run if condition1 is false and condition2 is true
}
...
else{
    // run if none of the above are true
}</pre>

  <h2>switch statement</h2>
  <ul>
    <li>Used when you want to compare one variable against multiple values.</li>
  </ul>
  <pre>
switch(variable){
    case value1: {
        // code;
        break;
    }
    case value2: {
        // code;
        break;
    }
    ...
    default:
        // code if no case matches
}</pre>

  <h2>Break Statement</h2>
  <ul>
    <li>It is used to immediately exit a loop or switch.</li>
  </ul>
  <pre>
for(int i = 0; i < 5; i++){
    if(i == 3){
        break;
    }
    System.out.println(i);
}</pre>
  <div class="highlight">
    Output:
    <pre>0
1
2</pre>
  </div>

  <h2>Continue Statement</h2>
  <ul>
    <li>Used to skip the current iteration and move to the next one.</li>
  </ul>
  <pre>
for(int i = 0; i < 5; i++){
    if(i == 3){
        continue;
    }
    System.out.println(i);
}</pre>
  <div class="highlight">
    Output:
    <pre>0
1
2
4</pre>
  </div>

<!-- ✅ Loop Differences Table -->
<h2> Loop Differences (for, while, do-while)</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th><code>for</code> Loop</th>
      <th><code>while</code> Loop</th>
      <th><code>do-while</code> Loop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Usage</strong></td>
      <td>When number of iterations is known</td>
      <td>When iterations depend on condition</td>
      <td>When code must run at least once</td>
    </tr>
    <tr>
      <td><strong>Condition Check</strong></td>
      <td>Before entering loop (entry-controlled)</td>
      <td>Before entering loop (entry-controlled)</td>
      <td>After one execution (exit-controlled)</td>
    </tr>
    <tr>
      <td><strong>Syntax</strong></td>
      <td>Compact, all in one line</td>
      <td>Separate initialization and update</td>
      <td>Condition checked after body runs</td>
    </tr>
    <tr>
      <td><strong>Runs At Least Once?</strong></td>
      <td>❌ No</td>
      <td>❌ No</td>
      <td>✅ Yes</td>
    </tr>
  </tbody>
</table>

<p><strong> Tip:</strong> Prefer <code>for</code> loop for fixed iteration, <code>while</code> when condition-based, <code>do-while</code> if it must run at least once.</p>

<hr>

<!-- ✅ if-else vs switch Table -->
<h2> if-else vs switch</h2>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th><code>if-else</code> Statement</th>
      <th><code>switch</code> Statement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Use Case</strong></td>
      <td>For complex, multiple condition checks</td>
      <td>For checking one variable against multiple constant values</td>
    </tr>
    <tr>
      <td><strong>Supports Ranges?</strong></td>
      <td>✅ Yes (<code>x &gt; 5 &amp;&amp; x &lt; 10</code>)</td>
      <td>❌ No (only exact match)</td>
    </tr>
    <tr>
      <td><strong>Type Support</strong></td>
      <td>boolean, int, char, String, etc.</td>
      <td>Only <code>int</code>, <code>char</code>, <code>String</code>, <code>enum</code></td>
    </tr>
    <tr>
      <td><strong>Syntax Length</strong></td>
      <td>Longer with many conditions</td>
      <td>Shorter and cleaner with many cases</td>
    </tr>
  </tbody>
</table>

<p><strong> Tip:</strong> Use <code>if-else</code> for condition <em>ranges</em> or complex logic. Use <code>switch</code> for <em>specific values</em>.</p>

<hr>

<!-- ✅ break vs continue Table -->
<h2> break vs continue</h2>

<table>
  <thead>
    <tr>
      <th>Keyword</th>
      <th><code>break</code></th>
      <th><code>continue</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Use Case</strong></td>
      <td>To exit the loop/switch immediately</td>
      <td>Skip the current iteration and continue the loop</td>
    </tr>
    <tr>
      <td><strong>Effect</strong></td>
      <td>Stops execution of the entire loop/block</td>
      <td>Skips rest of current loop body, jumps to next</td>
    </tr>
    <tr>
      <td><strong>Applies To</strong></td>
      <td>loops and switch</td>
      <td>loops only</td>
    </tr>
  </tbody>
</table>

</div>

<hr>

<h1>Java Methods</h1>

  <div class="section">
    <h2>What is a Method?</h2>
    <p>A <strong>method</strong> in Java is a block of code used to perform a specific task. Every method has its own name and specific task to perform.</p>
  </div>

  <div class="section">
    <h2>Syntax of a Method</h2>
    <pre>[Access Modifier] [Modifier] returnType MethodName([formalArguments]) {
    // task
}</pre>
    <ul>
      <li><strong>Access Modifier, Modifier</strong>, and <strong>formal arguments</strong> are optional.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Important Concepts</h2>
    <ul>
      <li><strong>Method Signature:</strong> Combination of method name with formal arguments.</li>
      <li><strong>Access Modifier:</strong> Controls visibility. (e.g., <code>public</code>, <code>protected</code>, <code>private</code>, <code>default</code>)</li>
      <li><strong>Modifier:</strong> Controls characteristics. (e.g., <code>static</code>, <code>final</code>, <code>abstract</code>, <code>transient</code>, <code>native</code>, <code>synchronized</code>)</li>
      <li><strong>Return Type:</strong> Specifies the data returned after method execution. (e.g., <code>void</code>, primitive or non-primitive)</li>
      <li><strong>Return Keyword:</strong> Used to terminate method execution and return a value.</li>
    </ul>
  </div>

  <div class="section">
    
    
    <div class="highlight">
      <strong>Note:</strong> <br> You cannot create a method inside another method.<br>
      Static methods can be called without creating an object.<br>
      Non-static methods require an object to call.
    </div>
    <div class="section">
  <h2>Types of Methods in Java</h2>

  <h3>1. Based on Definition</h3>
  <ul>
    <li><strong>Predefined Method</strong> – Already available in Java libraries. Example: <code>System.out.println()</code></li>
    <li><strong>User-defined Method</strong> – Created by the programmer with custom logic.</li>
  </ul>

  <h3>2. Based on Parameters and Return Type</h3>
  <table>
    <tr>
      <th>Type</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>No Parameter, No Return</td>
      <td>Method performs a task but returns nothing</td>
      <td><code>void greet()</code></td>
    </tr>
    <tr>
      <td>With Parameters, No Return</td>
      <td>Takes inputs but doesn’t return a value</td>
      <td><code>void add(int a, int b)</code></td>
    </tr>
    <tr>
      <td>No Parameters, With Return</td>
      <td>Returns a value but takes no input</td>
      <td><code>int getNumber()</code></td>
    </tr>
    <tr>
      <td>With Parameters, With Return</td>
      <td>Takes input and returns a result</td>
      <td><code>int multiply(int a, int b)</code></td>
    </tr>
  </table>

  <h3>3. Based on Parameters</h3>
  <ul>
    <li><strong>Parameterized Method</strong> – Accepts one or more parameters.</li>
    <li><strong>Non-Parameterized Method</strong> – Takes no arguments (also called No-argument Method).</li>
  </ul>

  <div class="highlight">
    <strong>Note:</strong> Method Signature = Method Name + Parameter List (does not include return type).
  </div>
</div>

  </div>

  <div class="section">
    <h2>Examples of Method Types Based on Parameters and Return Type</h2>
    <h3>1. Void Method Without Parameters</h3>
    <pre>public static void greet() {
    System.out.println("Welcome");
}</pre>

    <h3>2. Void Method With Parameters</h3>
    <pre>public static void sum(int a, int b) {
    System.out.println(a + b);
}</pre>

    <h3>3. Return Method Without Parameters</h3>
    <pre>public static int fixedNumber() {
    return 100;
}</pre>

    <h3>4. Return Method With Parameters</h3>
    <pre>public static int multiply(int a, int b) {
    return a * b;
}</pre>
  </div>

  <div class="section">
    <h2>Extra Tip</h2>
    <ul>
      <li>Methods improve code reusability and modularity.</li>
      <li>It helps avoid code repetition and enhances maintainability.</li>
    </ul>
  </div>
<div class="section">
  <h2>Method Calling in Java</h2>

  <h3>1. Calling a Static Method</h3>
  <p>Static methods belong to the class and can be called without creating an object.</p>
  <pre><code>
class Demo {
    static void greet() {
        System.out.println("Hello from static method");
    }

    public static void main(String[] args) {
        greet();         // Direct call
        Demo.greet();    // Or using class name
    }
}
  </code></pre>

  <h3>2. Calling a Non-Static Method</h3>
  <p>Non-static methods require an object to call them.</p>
  <pre><code>
class Demo {
    void show() {
        System.out.println("Hello from non-static method");
    }

    public static void main(String[] args) {
        Demo d = new Demo(); // Object creation
        d.show();            // Call using object
    }
}
  </code></pre>
</div>

<div class="section">
  <h2>What is Method Signature?</h2>
  <p>A <strong>method signature</strong> is the unique identity of a method, used by Java to distinguish overloaded methods.</p>

  <h3>✅ Method Signature Includes:</h3>
  <ul>
    <li>Method Name</li>
    <li>Parameter types and their order</li>
  </ul>

  <h3>❌ Method Signature Does NOT Include:</h3>
  <ul>
    <li>Return type</li>
    <li>Access modifiers (e.g., public, private)</li>
    <li>static keyword</li>
  </ul>

  <h3>Example:</h3>
  <pre><code>
void greet(String name)   // Signature: greet(String)
void greet(int times)     // Signature: greet(int)
int greet(String name)    // ❌ Error: Same signature as greet(String)
  </code></pre>

  <div class="highlight">
    <strong>Note:</strong> Java matches method calls using the method signature.
  </div>
</div>

<hr>

<div class="section">
  <h2>Recursion in Java</h2>
  <p>Recursion is a technique where a method calls itself to solve a problem. It's commonly used for problems that can be broken into smaller subproblems of the same type.</p>

  <div class="highlight">
    <strong>Definition:</strong> A method that calls itself is called a <strong>recursive method</strong>.
  </div>

  <h3>🔁 Why use Recursion?</h3>
  <ul>
    <li>To solve complex problems by breaking them into smaller, manageable problems.</li>
    <li>Used in problems like factorial, Fibonacci series, tree traversal, etc.</li>
  </ul>

  <h3>⚠️ Stack Overflow Error</h3>
  <p>If a recursive method does not have a proper stopping condition, it will keep calling itself infinitely, causing a <code>StackOverflowError</code> at runtime.</p>

  <pre>
Example: Infinite Recursion (Leads to Stack Overflow)
-------------------------------------
void sayHello() {
    System.out.println("Hello");
    sayHello(); // No stop condition
}
  </pre>

  <h3>✅ Example: Factorial Using Recursion</h3>
  <pre>
class RecursionExample {
    int factorial(int n) {
        if (n == 0) {
            return 1; // base case
        } else {
            return n * factorial(n - 1); // recursive call
        }
    }

    public static void main(String[] args) {
        RecursionExample obj = new RecursionExample();
        int result = obj.factorial(5);
        System.out.println("Factorial of 5 is: " + result);
    }
}
  </pre>

  <h3>🧠 Key Points</h3>
  <ul>
    <li>Every recursion must have a <strong>base case</strong> (exit condition) to stop calling itself.</li>
    <li>Recursive calls are stored in <code>stack memory</code>. If too many calls are made without returning, it overflows the stack.</li>
    <li>Recursion can often be replaced with loops (iteration), but recursion gives cleaner solutions in some cases.</li>
  </ul>

  <h3>📌 Difference Between Iteration and Recursion</h3>
  <table>
    <thead>
      <tr>
        <th>Iteration</th>
        <th>Recursion</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Uses loops like <code>for</code>, <code>while</code></td>
        <td>Method calls itself repeatedly</td>
      </tr>
      <tr>
        <td>Faster and memory efficient</td>
        <td>Can consume more memory (stack calls)</td>
      </tr>
      <tr>
        <td>Needs loop variables</td>
        <td>Needs base case to stop</td>
      </tr>
      <tr>
        <td>Harder to write for some problems</td>
        <td>Cleaner and simpler in problems like trees, factorials</td>
      </tr>
    </tbody>
  </table>
</div>

<hr>

<div class="section">
  <h2>Creating Classes and Objects</h2>

  <h3>📌 Class and Object</h3>
  <ul>
    <li><strong>Class:</strong> A blueprint or template to create objects. It defines properties (variables) and behaviors (methods).</li>
    <li><strong>Object:</strong> A real-world instance of a class that holds actual values and can call methods.</li>
  </ul>

  <pre>
Example:
-------
class Car {
    String brand;
    int speed;

    void drive() {
        System.out.println(brand + " is driving at " + speed + " km/h");
    }
}

public class Main {
    public static void main(String[] args) {
        Car c1 = new Car();     // Object creation
        c1.brand = "BMW";
        c1.speed = 100;
        c1.drive();
    }
}
  </pre>

  <hr>

  <h2>🚀 Constructors in Java</h2>
  <p>A <strong>constructor</strong> is a special block that is used to initialize objects when they are created.</p>

  <ul>
    <li>Constructor name = Class name</li>
    <li>No return type (not even <code>void</code>)</li>
    <li>Used to load non-static members into memory</li>
    <li>Helps initialize object state (assign values to variables)</li>
  </ul>

  <div class="highlight">
    🔸 If no constructor is defined, the compiler adds a default no-argument constructor at compile-time.
  </div>

  <h3>Constructor Syntax</h3>
  <pre>
class Car {
    String color;

    // Constructor
    Car() {
        color = "Red"; // load non-static member
        System.out.println("Constructor called!");
    }
}
  </pre>

  <h3>🔧 Types of Constructors</h3>
  <ul>
    <li><strong>Default Constructor</strong> - No parameters</li>
    <li><strong>Parameterized Constructor</strong> - Accepts arguments to initialize the object</li>
    <li><strong>Constructor Overloading</strong> - Multiple constructors with different parameter types or counts</li>
  </ul>

  <h3>Example</h3>
  <pre>
class Student {
    String name;
    int age;

    // Default Constructor
    Student() {
        name = "Aathi";
        age = 21;
    }

    // Parameterized Constructor
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void display() {
        System.out.println(name + " - " + age);
    }
}

public class ConstructorDemo {
    public static void main(String[] args) {
        Student s1 = new Student();                         // calls default constructor
        s1.display();

        Student s2 = new Student("Ganesh", 22);             // calls parameterized constructor
        s2.display();
    }
}
  </pre>

  <hr>

  <h2><code>this</code> Keyword</h2>
  <p>The <code>this</code> keyword is used to refer to the current object of the class.</p>

  <h3>Use Cases:</h3>
  <ul>
    <li>Differentiate between local variable and instance variable when they have the same name.</li>
    <li>Call another constructor within the same class using <code>this()</code>.</li>
    <li>Pass current object as an argument to methods or constructors.</li>
    <li>Return current object from a method.</li>
  </ul>

  <div class="highlight">
    🔸 <code>this</code> can only be used inside non-static blocks (not allowed in static blocks or static methods).
  </div>

  <h3>Example 1: Using <code>this</code> to Resolve Naming Conflict</h3>
  <pre>
class Example {
    int x;

    Example(int x) {
        this.x = x; // this.x refers to instance variable, x is local parameter
    }

    void show() {
        System.out.println("x = " + x);
    }
}
  </pre>

  <h3>Example 2: Using <code>this()</code> to Call Another Constructor</h3>
  <pre>
class Demo {
    int a, b;

    Demo() {
        this(10, 20); // calling parameterized constructor
    }

    Demo(int a, int b) {
        this.a = a;
        this.b = b;
    }

    void print() {
        System.out.println("a = " + a + ", b = " + b);
    }
}
  </pre>
</div>

<hr>

<section class="section">
  <h2><code>super</code> Keyword in Java</h2>
  <p><strong>super</strong> is a keyword in Java used to refer to the immediate parent class of a subclass. It is commonly used in three situations:</p>

  <ul>
    <li>To call the parent class constructor</li>
    <li>To access parent class methods</li>
    <li>To access parent class variables</li>
  </ul>

  <h3>1. Calling Parent Constructor using <code>super()</code></h3>
  <p>When a subclass constructor is called, it automatically calls the parent constructor using <code>super()</code> (even if not written explicitly). If not called explicitly, Java inserts it implicitly.</p>

  <pre><code>class A {
    A() {
        System.out.println("Parent Constructor Called");
    }
}

class B extends A {
    B() {
        super(); // Calls constructor of class A
        System.out.println("Child Constructor Called");
    }
}

public class Main {
    public static void main(String[] args) {
        B obj = new B();
    }
}</code></pre>

  <h3>2. Accessing Parent Method using <code>super</code></h3>
  <pre><code>class A {
    void show() {
        System.out.println("Parent Method");
    }
}

class B extends A {
    void show() {
        super.show(); // Calls show() from A
        System.out.println("Child Method");
    }
}</code></pre>

  <h3>3. Accessing Parent Variable using <code>super</code></h3>
  <pre><code>class A {
    int x = 10;
}

class B extends A {
    int x = 20;

    void display() {
        System.out.println(super.x); // prints 10 (from A)
        System.out.println(x);       // prints 20 (from B)
    }
}</code></pre>
</section>

<section class="section">
  <h2>extends vs implements</h2>

  <h3>extends</h3>
  <ul>
    <li>Used when one class inherits another class.</li>
    <li>Can be used when both parent and child are <strong>classes</strong>.</li>
    <li>Also used when one <strong>interface extends another interface</strong>.</li>
  </ul>

  <pre><code>class A {
    void greet() {
        System.out.println("Hello from A");
    }
}

class B extends A {
    void greet2() {
        System.out.println("Hello from B");
    }
}</code></pre>

  <h3>implements</h3>
  <ul>
    <li>Used when a class wants to implement an interface.</li>
    <li>Can only be used when the parent is an <strong>interface</strong> and the child is a <strong>class</strong>.</li>
    <li><strong>Cannot</strong> be used to make an interface inherit a class.</li>
  </ul>

  <pre><code>interface A {
    void greet();
}

class B implements A {
    public void greet() {
        System.out.println("Hello from implemented method");
    }
}</code></pre>

  <h3>Invalid Example</h3>
  <pre><code>// This is invalid and will throw an error
class A{
}
interface B implements A {  // ❌ Wrong - interfaces cannot implement classes
}</code></pre>
</section>

<hr>

<h2>✅ Singleton Pattern in Java</h2>
<p>Ensures only one object is created for the class. Used in logging, config managers, database connections, etc.</p>

<h4>🔸 Rules:</h4>
<ul>
  <li>Private static instance of the class</li>
  <li>Private constructor</li>
  <li>Public static method to return the instance</li>
</ul>

<pre><code>public class Singleton {
    private static Singleton instance;

    private Singleton() {
        System.out.println("Singleton instance created");
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

class Main {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();
        System.out.println(s1 == s2); // true
    }
}
</code></pre>

<h2>✅ Java Bean Class (or) POJO Class</h2>
<p>A JavaBean is a simple Java class used for encapsulation, data transfer, and framework compatibility.</p>

<h4>🔸 Rules:</h4>
<ul>
  <li>Public class</li>
  <li>Private variables</li>
  <li>No-argument constructor</li>
  <li>Public getters and setters</li>
  <li>Should be serializable (optional)</li>
</ul>

<pre><code>public class Student {
    private String name;
    private int age;

    public Student() {}

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
}

class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("Aathi");
        s.setAge(21);
        System.out.println(s.getName() + " - " + s.getAge());
    }
}
</code></pre>

<h2>✅ Serialization and Deserialization</h2>
<p><strong>Serialization:</strong> Converting object into byte stream to store in file, DB, or send over network.<br>
<strong>Deserialization:</strong> Reconstructing object from byte stream.</p>

<pre><code>import java.io.*;

class Student implements Serializable {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String toString() {
        return name + " - " + age;
    }
}

class Main {
    public static void main(String[] args) throws Exception {
        Student s1 = new Student("Aathi", 21);

        // Serialization
        FileOutputStream fos = new FileOutputStream("student.txt");
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);
        oos.close();

        // Deserialization
        FileInputStream fis = new FileInputStream("student.txt");
        ObjectInputStream ois = new ObjectInputStream(fis);
        Student s2 = (Student) ois.readObject();
        ois.close();

        System.out.println("Deserialized: " + s2);
    }
}
</code></pre>

<hr>

<h2>✅ Relationship in Java</h2>
<p>The connection between objects is called a <strong>relationship</strong>.</p>

<h4>🔸 Types of Relationship</h4>
<ul>
  <li>Has-A Relationship</li>
  <li>Is-A Relationship (Inheritance)</li>
</ul>

<h2>✅ Has-A Relationship</h2>
<p>Has-A Relationship represents <strong>dependency</strong> between objects, where one class contains a reference to another class.</p>

<h4>🔸 Types:</h4>
<ul>
  <li><strong>Composition</strong> (Strong Has-A)</li>
  <li><strong>Aggregation</strong> (Weak Has-A)</li>
</ul>

<h3>🔸 Composition (Strong Has-A)</h3>
<p>
The dependency between objects is such that one object <strong>cannot exist without</strong> the other.<br>
It uses <strong>early instantiation</strong> – the dependent object is created at the same time.
</p>

<pre><code>class Heart {
    void pump() {
        System.out.println("Pumping blood");
    }
}

class Human {
    private Heart heart = new Heart();  // Composition – Human has-a Heart

    void live() {
        heart.pump();
        System.out.println("Human is alive");
    }
}

class Main {
    public static void main(String[] args) {
        Human h = new Human();
        h.live();
    }
}
</code></pre>

<h3>🔸 Aggregation (Weak Has-A)</h3>
<p>
The dependency is such that one object <strong>can exist without</strong> the other.<br>
It uses <strong>lazy instantiation</strong> – the dependent object is passed later or set through methods.
</p>

<pre><code>class Book {
    String title;
    Book(String title) {
        this.title = title;
    }
}

class Library {
    Book book;  // Library has-a Book

    Library(Book book) {
        this.book = book;
    }

    void showBook() {
        System.out.println("Library has: " + book.title);
    }
}

class Main {
    public static void main(String[] args) {
        Book b = new Book("Java Mastery");
        Library lib = new Library(b);
        lib.showBook();
    }
}
</code></pre>

<hr>

<!-- IS-A Relationship and Inheritance Notes -->

<div class="section">
    <h2>IS-A Relationship</h2>
    <p>It represents a relationship between a parent and child class. It means one class is a type of another class. This is achieved using <b>Inheritance</b>.</p>
    <p><b>Example:</b> A Student IS-A Person. A Dog IS-A Animal.</p>
</div>

<div class="section">
    <h2>What is Inheritance?</h2>
    <p>Inheritance is the process of acquiring the properties (fields) and behaviors (methods) of one class into another.</p>
    <p>In Java, inheritance is achieved using the keywords <code>extends</code> (for classes) and <code>implements</code> (for interfaces).</p>
    <p>The class which inherits is called <b>Child class / Subclass</b>. The class being inherited from is called <b>Parent class / Superclass</b>.</p>
</div>

<div class="section">
    <h2>Why Use Inheritance?</h2>
    <ul>
        <li>Code Reusability</li>
        <li>Improves readability and maintainability</li>
        <li>Helps achieve polymorphism</li>
    </ul>
</div>

<div class="section">
    <h2>Types of Inheritance in Java</h2>
    <ul>
        <li><b>Single Inheritance</b> – One class inherits another class.</li>
        <li><b>Multilevel Inheritance</b> – One class inherits another class, which inherits another class.</li>
        <li><b>Hierarchical Inheritance</b> – Multiple classes inherit the same parent class.</li>
        <li><b>Multiple Inheritance</b> – One class inherits multiple classes (Not supported using classes directly, but supported via interfaces).</li>
        <li><b>Hybrid Inheritance</b> – Combination of more than one type of inheritance (only possible with interfaces in Java).</li>
    </ul>
    <p><b>Note:</b> Java does not support multiple inheritance with classes to avoid the <b>diamond problem</b>.</p>
</div>

<div class="section">
    <h3>1. Single Inheritance</h3>
    <pre><code>
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
        d.bark();
    }
}
    </code></pre>
</div>

<div class="section">
    <h3>2. Multilevel Inheritance</h3>
    <pre><code>
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

class Puppy extends Dog {
    void weep() {
        System.out.println("Puppy weeps");
    }
}

class Main {
    public static void main(String[] args) {
        Puppy p = new Puppy();
        p.sound();
        p.bark();
        p.weep();
    }
}
    </code></pre>
</div>

<div class="section">
    <h3>3. Hierarchical Inheritance</h3>
    <pre><code>
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    void meow() {
        System.out.println("Cat meows");
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();
        d.bark();

        Cat c = new Cat();
        c.eat();
        c.meow();
    }
}
    </code></pre>
</div>

<div class="section">
    <h3>4. Multiple Inheritance (via Interfaces)</h3>
    <pre><code>
interface A {
    void methodA();
}

interface B {
    void methodB();
}

class C implements A, B {
    public void methodA() {
        System.out.println("methodA from A");
    }

    public void methodB() {
        System.out.println("methodB from B");
    }
}

class Main {
    public static void main(String[] args) {
        C obj = new C();
        obj.methodA();
        obj.methodB();
    }
}
    </code></pre>
</div>

<div class="section">
    <h3>5. Hybrid Inheritance (via Interfaces)</h3>
    <pre><code>
interface A {
    void methodA();
}

interface B extends A {
    void methodB();
}

interface C {
    void methodC();
}

class D implements B, C {
    public void methodA() {
        System.out.println("A's method");
    }

    public void methodB() {
        System.out.println("B's method");
    }

    public void methodC() {
        System.out.println("C's method");
    }
}

class Main {
    public static void main(String[] args) {
        D obj = new D();
        obj.methodA();
        obj.methodB();
        obj.methodC();
    }
}
    </code></pre>
</div>

<div class="section">
    <h2>Inheritance with Constructors (super keyword)</h2>
    <p>We use <code>super()</code> in the child class constructor to call the parent class constructor.</p>

    <pre><code>
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void displayPersonInfo() {
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
    }
}

class Student extends Person {
    int rollNo;

    Student(String name, int age, int rollNo) {
        super(name, age); // Call to parent constructor
        this.rollNo = rollNo;
    }

    void displayStudentInfo() {
        System.out.println("RollNo: " + rollNo);
    }
}

class Main {
    public static void main(String[] args) {
        Student s = new Student("Aathi", 21, 1101);
        s.displayPersonInfo();
        s.displayStudentInfo();
    }
}
    </code></pre>
</div>

<div class="section">
    <h2>super keyword</h2>
    <ul>
        <li><code>super()</code> – calls the parent class constructor</li>
        <li><code>super.variable</code> – accesses the parent class variable</li>
        <li><code>super.method()</code> – calls the parent class method</li>
    </ul>

    <h4>super example:</h4>
    <pre><code>
class Animal {
    String type = "Animal";

    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    String type = "Dog";

    void showType() {
        System.out.println("Child type: " + type);
        System.out.println("Parent type: " + super.type);
        super.sound(); // call parent method
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.showType();
    }
}
    </code></pre>
</div>

<div class="section">
    <h2>Important Notes</h2>
    <ul>
        <li>A subclass cannot access private members of the superclass.</li>
        <li>Java does not support multiple inheritance using classes.</li>
        <li>All classes in Java implicitly extend <code>Object</code> class.</li>
        <li>Constructors are not inherited but can be called using <code>super()</code>.</li>
        <li><code>final</code> class cannot be inherited.</li>
        <li><code>final</code> method cannot be overridden.</li>
    </ul>
</div>

<hr>

<div class="section">
    <h2>Polymorphism</h2>
    <p><b>Definition:</b> Polymorphism means "many forms". It allows one entity (method or object) to behave differently based on the context.</p>

    <h3>Types of Polymorphism</h3>
    <ul>
        <li><b>Compile-time Polymorphism (Static Binding):</b> Achieved through method overloading, constructor overloading, variable shadowing, and method shadowing.</li>
        <li><b>Runtime Polymorphism (Dynamic Binding):</b> Achieved through method overriding.</li>
    </ul>

    <h3>1. Compile-Time Polymorphism</h3>

    <h4>Method Overloading</h4>
    <p><b>Definition:</b> Having multiple methods in the same class with the same name but different parameters (type, number, or order).</p>
    <p><b>Rules:</b></p>
    <ul>
        <li>Scope: Same class</li>
        <li>Method Name: Same</li>
        <li>Parameters: Different (by type or count or order)</li>
        <li>Return Type: Can be same or different</li>
    </ul>

<pre><code>class Calc {
    void add(int a, int b){
        System.out.println("Sum(int):" + (a+b));
    }
    void add(double a, double b){
        System.out.println("Sum(double):" + (a+b));
    }
    void add(int a, int b, int c){
        System.out.println("Sum(3int):" + (a+b+c));
    }
}

class PolymorphismMethodOverloading {
    public static void main(String[] args){
        Calc c = new Calc();
        c.add(10, 20);
        c.add(20.3, 2.3);
        c.add(10, 20, 30);
    }
}</code></pre>

    <h4>Constructor Overloading</h4>
    <p>Same constructor name (class name) but with different parameter lists.</p>

<pre><code>class Person {
    String name;
    int age;

    Person(String name) {
        this.name = name;
    }

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}</code></pre>

    <h4>Variable Shadowing</h4>
    <p>Subclass has a variable with the same name as superclass. Use <code>super.variable</code> to access parent variable.</p>

<pre><code>class A {
    int x = 10;
}

class B extends A {
    int x = 20;

    void display() {
        System.out.println("Child x: " + x);
        System.out.println("Parent x: " + super.x);
    }
}</code></pre>

    <h4>Method Shadowing / Hiding</h4>
    <p>Both parent and child class have static method with same name and signature. This is not overriding.</p>

<pre><code>class A {
    static void show() {
        System.out.println("Parent static method");
    }
}

class B extends A {
    static void show() {
        System.out.println("Child static method");
    }
}</code></pre>

    <h3>2. Runtime Polymorphism</h3>

    <h4>Method Overriding</h4>
    <p><b>Definition:</b> Occurs when a subclass provides a specific implementation of a method that is already defined in its superclass.</p>
    <p><b>Rules:</b></p>
    <ul>
        <li>IS-A relationship required (inheritance)</li>
        <li>Method name, parameters, and return type should be same (or covariant return type)</li>
        <li>Only applicable to non-static methods</li>
        <li>Access modifier in child method should be same or more visible</li>
        <li><code>@Override</code> annotation is recommended</li>
    </ul>

<pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal Sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog Barks");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Cat Meows");
    }
}

class PolymorphismMethodOverriding {
    public static void main(String[] args) {
        Animal a;
        a = new Dog();
        a.makeSound();  // Dog Barks
        a = new Cat();
        a.makeSound();  // Cat Meows
    }
}</code></pre>

    <h4>Using <code>super</code> in Overriding</h4>
    <p>Use <code>super.methodName()</code> to call the parent class method inside the overridden method.</p>

<pre><code>class Animal {
    void makeSound() {
        System.out.println("Animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        super.makeSound();
        System.out.println("Dog Barks");
    }
}

class OverridingSuper {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.makeSound();
    }
}

// Output:
// Animal sound
// Dog Barks</code></pre>

</div>

<hr>

 <h1>Interface in Java</h1>
  <div class="section">
    <p><strong>Definition:</strong> An <code>interface</code> in Java is a completely abstract class that defines a set of method signatures without implementations.</p>
    <ul>
      <li>It defines <em>what</em> a class must do, but not <em>how</em> it does it.</li>
      <li>Supports <strong>full abstraction</strong>.</li>
      <li>Java allows a class to <strong>implement multiple interfaces</strong>, thus supporting multiple inheritance.</li>
    </ul>

    <h2>Types of Interfaces</h2>
    <ul>
      <li><strong>Regular Interface:</strong> Any interface with one or more abstract methods.</li>
      <li><strong>Functional Interface:</strong> An interface with exactly one abstract method. Used with <code>lambda expressions</code>.</li>
      <li><strong>Marker Interface:</strong> An interface with no methods, used to mark or tag a class (e.g., <code>Serializable</code>, <code>Cloneable</code>).</li>
    </ul>

    <h2>Syntax Example</h2>
    <pre><code>interface Animal {
    void makeSound(); // abstract method
}

class Dog implements Animal {
    public void makeSound() {
        System.out.println("Dog Barks");
    }
}

public class InterfaceExample {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.makeSound();
    }
}
// Output: Dog Barks</code></pre>

    <h2>Lambda Expression</h2>
    <p>A lambda expression is an anonymous method (no name), used mainly to implement a method of a <strong>functional interface</strong>.</p>
    <pre><code>(int a, String b) -> {
    System.out.println("Two arguments: " + a + " and " + b);
}</code></pre>

    <h2>Method Reference</h2>
    <p>Introduced in Java 8, method references let you refer to methods without calling them.</p>
    <p>Can be used only with <strong>functional interfaces</strong>.</p>

    <h3>Types of Method References</h3>
    <ul>
      <li>Reference to a<strong>Static method:</strong> <code>ClassName::staticMethod</code></li>
      <li>Reference to a<strong>Instance method (object):</strong> <code>object::instanceMethod</code></li>
      <li>Reference to a<strong>Instance method (class):</strong> <code>ClassName::instanceMethod</code></li>
      <li>Reference to a<strong>Constructor:</strong> <code>ClassName::new</code></li>
      <li>Reference to a<strong>Non-static method:</strong> <code>ref::nonStaticMethod</code></li>
    </ul>

    <h3>Functional Interface Example with Lambda</h3>
    <pre><code>@FunctionalInterface
interface Greet {
    void sayHello(String name);
}

public class LambdaDemo {
    public static void main(String[] args) {
        Greet g = (name) -> System.out.println("Hello " + name);
        g.sayHello("Aathi");
    }
}
// Output: Hello Aathi</code></pre>

    <h3>Method Reference Example</h3>
    <pre><code>interface Printable {
    void print();
}

class Printer {
    public void display() {
        System.out.println("Printed using method reference!");
    }
}

public class MethodRefDemo {
    public static void main(String[] args) {
        Printer p = new Printer();
        Printable pr = p::display; // method reference
        pr.print();
    }
}
// Output: Printed using method reference!</code></pre>

  </div>

<hr>

<div class="topic">
  <h2>Access Modifiers in Java</h2>
  <p>Access Modifiers control the visibility or accessibility of classes, variables, methods, and constructors.</p>

  <h3>Types of Access Modifiers:</h3>
  <ul>
    <li><strong>public</strong>: Accessible from anywhere (any class, any package).</li>
    <li><strong>protected</strong>: Accessible within the same package or subclass in other packages.</li>
    <li><strong>default</strong>: (no modifier) Accessible only within the same package.</li>
    <li><strong>private</strong>: Accessible only within the same class.</li>
  </ul>

  <h3>Modifier Table:</h3>
  <table border="1" cellpadding="5">
    <tr>
      <th>Modifier</th>
      <th>Same Class</th>
      <th>Same Package</th>
      <th>Subclass</th>
      <th>Other Class</th>
    </tr>
    <tr>
      <td>public</td>
      <td>✔</td>
      <td>✔</td>
      <td>✔</td>
      <td>✔</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>✔</td>
      <td>✔</td>
      <td>✔</td>
      <td>✖</td>
    </tr>
    <tr>
      <td>default</td>
      <td>✔</td>
      <td>✔</td>
      <td>✖</td>
      <td>✖</td>
    </tr>
    <tr>
      <td>private</td>
      <td>✔</td>
      <td>✖</td>
      <td>✖</td>
      <td>✖</td>
    </tr>
  </table>

  <h3>Example:</h3>
  <pre><code class="language-java">
public class Example {
    public int a = 1;       // visible everywhere
    protected int b = 2;    // visible in same package + subclass
    int c = 3;              // default - visible only in same package
    private int d = 4;      // visible only in the same class

    public static void main(String[] args) {
        Example obj = new Example();
        System.out.println(obj.a); // 1
        System.out.println(obj.b); // 2
        System.out.println(obj.c); // 3
        System.out.println(obj.d); // 4
    }
}
  </code></pre>

  <h4>Output:</h4>
  <pre>1
2
3
4</pre>
</div>

<div class="topic">
  <h2>Packages in Java</h2>
  <p>A <strong>package</strong> is a namespace that organizes a set of related classes and interfaces. It helps avoid name conflicts and makes files easier to locate.</p>

  <h3>Types of Packages:</h3>
  <ul>
    <li><strong>Built-in packages</strong> - provided by Java (e.g., java.util, java.io, java.lang)</li>
    <li><strong>User-defined packages</strong> - created by the user (e.g., <code>package mypackage;</code>)</li>
  </ul>

  <h3>Syntax to Create Package:</h3>
  <pre><code class="language-java">
// File: MyClass.java
package mypackage;

public class MyClass {
    public void display() {
        System.out.println("Inside MyClass in mypackage");
    }
}
  </code></pre>

  <h3>Import & Use:</h3>
  <pre><code class="language-java">
// File: Main.java
import mypackage.MyClass;

class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.display();
    }
}
  </code></pre>
</div>

<div class="topic">
  <h2>Static Keyword in Java</h2>
  <p>The <code>static</code> keyword is used to define methods or variables that belong to the class rather than any instance.</p>

  <ul>
    <li><strong>Static variable</strong>: Shared among all instances.</li>
    <li><strong>Static method</strong>: Can be called without creating an object.</li>
    <li><strong>Static block</strong>: Runs once when the class is loaded.</li>
  </ul>

  <h3>Static Variable Example:</h3>
  <pre><code class="language-java">
class Student {
    int id;
    String name;
    static String college = "AMS";

    Student(int i, String n) {
        id = i;
        name = n;
    }

    void display() {
        System.out.println(id + " " + name + " " + college);
    }
}

class Main {
    public static void main(String[] args) {
        Student s1 = new Student(1, "Aathi");
        Student s2 = new Student(2, "Rakshan");
        s1.display();
        s2.display();
    }
}
  </code></pre>

  <h4>Output:</h4>
  <pre>1 Aathi AMS
2 Rakshan AMS</pre>

  <h3>Static Method Example:</h3>
  <pre><code class="language-java">
class Demo {
    static void greet() {
        System.out.println("Hello from static method");
    }
}

class Main {
    public static void main(String[] args) {
        Demo.greet(); // Called without object creation
    }
}
  </code></pre>

  <h4>Output:</h4>
  <pre>Hello from static method</pre>
</div>

<div class="topic">
  <h2>Final Keyword in Java</h2>
  <p>The <code>final</code> keyword is used to define constants, prevent method overriding, and stop inheritance.</p>

  <h3>Uses of final:</h3>
  <ul>
    <li><strong>final variable</strong>: Value cannot be changed once assigned.</li>
    <li><strong>final method</strong>: Cannot be overridden in a subclass.</li>
    <li><strong>final class</strong>: Cannot be inherited or extended.</li>
  </ul>

  <h3>Examples:</h3>

  <h4>Final Variable:</h4>
  <pre><code class="language-java">
class Test {
    final int value = 10;

    void show() {
        // value = 20; // ❌ Error: cannot assign a value to final variable
        System.out.println(value);
    }
}
  </code></pre>

  <h4>Final Method:</h4>
  <pre><code class="language-java">
class Parent {
    final void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    // void display() {} // ❌ Error: Cannot override final method
}
  </code></pre>

  <h4>Final Class:</h4>
  <pre><code class="language-java">
final class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

// class Dog extends Animal {} // ❌ Error: Cannot inherit from final class
  </code></pre>
</div>

<hr>

<h2>JAVA MEMBERS REFERENCE – VARIABLES, METHODS, BLOCKS</h2>
<ul>
<li><strong>VARIABLES:</strong>
    <ul>
        <li>Instance Variable → Belongs to object (non-static)</li>
        <li>Static Variable → Belongs to class (shared)</li>
        <li>Local Variable → Declared in methods/blocks</li>
        <li>Final Variable → Cannot be reassigned after set</li>
    </ul>
</li>
<li><strong>METHODS:</strong>
    <ul>
        <li>Instance Method → Needs object to call</li>
        <li>Static Method → Call using class name</li>
        <li>Constructor → Same name as class, runs on object creation</li>
        <li>Main Method → Entry point: <code>public static void main(String[] args)</code></li>
    </ul>
</li>
<li><strong>INITIALIZERS:</strong>
    <ul>
        <li>Static Block → Runs once when class loads</li>
        <li>Instance Block → Runs before constructor, every object creation</li>
    </ul>
</li>
</ul>

<p><strong>ORDER OF EXECUTION:</strong><br>
→ Static Block → Instance Block → Constructor → Methods</p>

<p><strong>Example Use:</strong><br>
Static block: DB connection, constants<br>
Instance block: Common logic for all constructors<br>
Final variable: PI = 3.14</p>

<h2>STATIC vs NON-STATIC in Java</h2>
<ul>
<li><strong>STATIC:</strong>
    <ul>
        <li>Belongs to the class (not to object)</li>
        <li>Shared by all objects</li>
        <li>Can be accessed using class name</li>
        <li>Example: <code>static int count;</code> <code>static void show();</code></li>
    </ul>
</li>
<li><strong>NON-STATIC (Instance Members):</strong>
    <ul>
        <li>Belongs to individual object</li>
        <li>Unique for each object</li>
        <li>Requires object to access</li>
        <li>Example: <code>String name;</code> <code>int age;</code> <code>void print();</code></li>
    </ul>
</li>
</ul>

<p><strong>Rules:</strong><br>
Static methods can access only static members directly<br>
Non-static methods can access both static and non-static members</p>

<p><strong>Use Cases:</strong><br>
Static: Constants, counters, utility methods<br>
Non-static: Personal data, behavior per object</p>

<h2>CLASS LOADING & INITIALIZATION FLOW</h2>
<ol>
<li>Class is loaded by ClassLoader (JVM)</li>
<li>Static variables & static blocks are initialized (top to bottom)</li>
<li>Main method is called (entry point)</li>
<li>When object is created:
    <ul>
        <li>Instance variables are initialized</li>
        <li>Instance initializer block runs</li>
        <li>Constructor runs</li>
    </ul>
</li>
</ol>

<h2>CLASS LOADING & OBJECT CREATION FLOW</h2>
<ol>
<li>Class loads → Static block runs once</li>
<li>Object created → Instance block → Constructor</li>
<li>Instance methods/fields work on objects</li>
<li>Static methods/fields belong to class</li>
</ol>

<p><strong>Static members:</strong> shared across all objects<br>
<strong>Instance members:</strong> separate for each object</p>

<h2>Object</h2>
<p>Every object will be having two properties that is:<br>
State/Attributes/DataMember - Should be represented by non-static variable.<br>
Behaviours/Function/Features - Should be represented by non-static methods.</p>

<pre>
class Book {
    int id;
    String author;
    String title;
    double price;
    void read() {}
    void write() {}
}
</pre>

<h2>java.lang.Object</h2>
<ul>
<li>Superclass of all Java classes</li>
<li>Common methods: toString(), equals(), hashCode(), getClass(), finalize()</li>
<li>All custom classes inherit Object by default</li>
</ul>

<h2>java.lang.Object – Superclass</h2>
<ul>
<li>All classes in Java implicitly extend Object.</li>
<li>Common methods inherited:
    <ul>
        <li>toString() → String representation</li>
        <li>equals(Object) → Compares content</li>
        <li>hashCode() → Used in collections</li>
        <li>getClass() → Returns runtime class</li>
        <li>finalize() → Called before garbage collection (deprecated)</li>
    </ul>
</li>
</ul>

<h2>final</h2>
<ul>
<li>It is a keyword as well as modifier.</li>
<li>Represents a constant (cannot be changed after assignment).</li>
<li>Used for class, variable, and methods.</li>
</ul>

<h3>final method</h3>
<p>Cannot be overridden but can be inherited and used.</p>

<h3>final global variable</h3>
<p>Declared at class level and should be in uppercase.</p>

<h3>final local variable</h3>
<p>Declared inside method. Once assigned, cannot be changed.</p>

<h3>final class</h3>
<p>Cannot be inherited. Example: <code>public final class MyClass { }</code></p>

<h2>Varargs</h2>
<ul>
<li>Only one varargs parameter is allowed in a method.</li>
<li>Must be the last parameter in the method signature.</li>
</ul>

<pre><code>returnType methodName(type... varName) { }</code></pre>

<p>The ... (three dots) tells Java that the method accepts 0 or more arguments of that type.</p>

<h2>Anonymous Class</h2>
<ul>
<li>A class without a name, declared and instantiated in a single statement.</li>
<li>Used to override methods from abstract class or interface.</li>
</ul>

<table border="1" cellpadding="5">
<tr><th>Name</th><th>Type</th><th>Purpose</th><th>Anonymous Class Usage?</th></tr>
<tr><td>Runnable</td><td>Interface</td><td>Run code in a thread</td><td>✅ Yes</td></tr>
<tr><td>Callable</td><td>Interface</td><td>Like Runnable but returns result</td><td>✅ Yes</td></tr>
<tr><td>Comparator</td><td>Interface</td><td>Used to sort objects</td><td>✅ Yes</td></tr>
<tr><td>ActionListener</td><td>Interface</td><td>Used in GUI for button clicks etc.</td><td>✅ Yes</td></tr>
<tr><td>Thread</td><td>Class</td><td>Controls and starts threads</td><td>✅ Yes (can be extended)</td></tr>
</table>

<pre><code>InterfaceOrClass obj = new InterfaceOrClass() {
    // Override methods here
};</code></pre>

<h2>object class</h2>
<ul>
<li>Root class of all Java classes</li>
<li>Implicitly extended if no superclass is specified</li>
<li>Contains 11 non-static methods</li>
<li>Compiler adds "extends Object" by default</li>
</ul>

<pre><code>Object ref = new ClassName();</code></pre>

<h3>Common Methods:</h3>
<ul>
<li><strong>toString()</strong>: Returns string representation of object</li>
<li><strong>equals(Object o)</strong>: Compares if two objects are equal (default: memory address)</li>
<li><strong>hashCode()</strong>: Returns hash code (used in collections)</li>
<li><strong>getClass()</strong>: Returns runtime class info</li>
<li><strong>clone()</strong>: Creates object copy (requires Cloneable)</li>
<li><strong>finalize()</strong>: Used for cleanup before GC (deprecated)</li>
<li><strong>wait(), notify(), notifyAll()</strong>: For multithreading synchronization</li>
</ul>

<p><strong>Garbage Collection:</strong><br>
<code>System.gc()</code> calls <code>finalize()</code> before collecting objects created with <code>new</code> keyword.</p>

<h1>Object Class Methods</h1>

  <section>
    <h2>1. toString()</h2>
    <p>Returns a string representation of the object. Default: <code>ClassName@HexHashCode</code></p>
    <pre><code>public String toString()</code></pre>
    <p><strong>Example:</strong></p>
    <pre><code>class Demo {
    int a = 10;
    public String toString() {
        return "Value of a: " + a;
    }
    public static void main(String[] args) {
        Demo d = new Demo();
        System.out.println(d); // calls toString()
    }
}</code></pre>
  </section>

  <section>
    <h2>2. equals(Object obj)</h2>
    <p>Checks whether two objects are logically equal.</p>
    <pre><code>public boolean equals(Object obj)</code></pre>
    <pre><code>String s1 = new String("Hello");
String s2 = new String("Hello");
System.out.println(s1.equals(s2)); // true</code></pre>
  </section>

  <section>
    <h2>3. hashCode()</h2>
    <p>Returns hash code used in hashing-based collections like HashMap, HashSet.</p>
    <pre><code>public int hashCode()</code></pre>
    <pre><code>String s = "Hello";
System.out.println(s.hashCode());</code></pre>
  </section>

  <section>
    <h2>4. getClass()</h2>
    <p>Returns runtime class information of the object.</p>
    <pre><code>public final Class&lt;?&gt; getClass()</code></pre>
    <pre><code>Demo d = new Demo();
System.out.println(d.getClass());</code></pre>
  </section>

  <section>
    <h2>5. clone()</h2>
    <p>Creates a copy of the object. Class must implement <code>Cloneable</code>.</p>
    <pre><code>protected Object clone() throws CloneNotSupportedException</code></pre>
    <pre><code>class Demo implements Cloneable {
    int x = 10;
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    public static void main(String[] args) throws CloneNotSupportedException {
        Demo d1 = new Demo();
        Demo d2 = (Demo)d1.clone();
        System.out.println(d2.x);
    }
}</code></pre>
  </section>

  <section>
    <h2>6. wait(), notify(), notifyAll()</h2>
    <p>Used in multithreading for synchronization.</p>
    <pre><code>public final void wait()
public final void wait(long timeout)
public final void wait(long timeout, int nanos)
public final void notify()
public final void notifyAll()</code></pre>
    <p>These methods are used inside synchronized blocks to manage thread communication.</p>
  </section>

  <section>
    <h2>7. finalize()</h2>
    <p>Used to perform cleanup before the object is garbage collected.</p>
    <pre><code>protected void finalize() throws Throwable</code></pre>
    <p><strong>Notes:</strong></p>
    <ul>
      <li>Called by <code>System.gc()</code> before destroying object</li>
      <li>Only works for objects created using <code>new</code></li>
    </ul>
    <pre><code>class Test {
    protected void finalize() {
        System.out.println("Object is being garbage collected");
    }

    public static void main(String[] args) {
        Test t1 = new Test();
        t1 = null;
        System.gc();
    }
}</code></pre>
  </section>

<hr>

<div class="section">
  <h1>Abstraction</h1>
  <p>Abstraction means <strong>hiding internal implementation</strong> and showing only the <strong>essential features</strong> to the user.</p>

  <h2>Types of Abstraction in Java</h2>
  <ul>
    <li><strong>Abstract Class</strong> – Partially abstract. Can have both abstract and concrete methods.</li>
    <li><strong>Interface</strong> – Fully abstract (before Java 8). Used to define a contract that a class must follow.</li>
  </ul>

  <h3>Abstract Class</h3>
  <ul>
    <li>Declared with the <code>abstract</code> keyword.</li>
    <li>Cannot be instantiated (no object can be created).</li>
    <li>Can have both <code>abstract</code> methods and normal methods.</li>
    <li><code>abstract</code> and <code>static</code> cannot be used together (static methods cannot be overridden).</li>
    <li><code>abstract</code> and <code>final</code> cannot be used together.</li>
    <li><code>abstract</code> and <code>private</code> cannot be used together (private methods cannot be overridden).</li>
  </ul>

  <h3>Interface</h3>
  <ul>
    <li>Defines a pure abstraction.</li>
    <li>All methods are implicitly <code>public abstract</code> (till Java 7).</li>
    <li>Cannot have static methods inherited.</li>
    <li>Can support <code>default</code> and <code>static</code> methods from Java 8 onward.</li>
    <li>Supports multiple inheritance.</li>
  </ul>

  <h3>Terms</h3>
  <ul>
    <li><strong>Service Specifier</strong>: Specifies what features are needed for the end user.</li>
    <li><strong>Service Provider</strong>: Implements the specifications (functions) made by the specifier.</li>
    <li><strong>End User</strong>: Uses the final functionalities.</li>
  </ul>

  <h2>Abstract Class vs Interface</h2>
  <table>
    <tr>
      <th>Feature</th>
      <th>Abstract Class</th>
      <th>Interface</th>
    </tr>
    <tr>
      <td>Keyword</td>
      <td><code>abstract class</code></td>
      <td><code>interface</code></td>
    </tr>
    <tr>
      <td>Method Types</td>
      <td>Abstract + Concrete</td>
      <td>Only Abstract (until Java 8)</td>
    </tr>
    <tr>
      <td>Constructors</td>
      <td>✔️ Can have constructors</td>
      <td>❌ Not allowed</td>
    </tr>
    <tr>
      <td>Variables</td>
      <td>Can have any type</td>
      <td>Only <code>public static final</code></td>
    </tr>
    <tr>
      <td>Access Modifiers</td>
      <td>private, protected, public, etc.</td>
      <td>Only public</td>
    </tr>
    <tr>
      <td>Multiple Inheritance</td>
      <td>❌ Not supported</td>
      <td>✅ Supported</td>
    </tr>
    <tr>
      <td>When to Use</td>
      <td>When classes are related by IS-A</td>
      <td>When unrelated classes need common behavior</td>
    </tr>
    <tr>
      <td>Fields</td>
      <td>Can have instance variables</td>
      <td>Only constants</td>
    </tr>
  </table>

  <div class="highlight">
    <p><strong>Example:</strong></p>
    <ul>
      <li>Use <strong>Abstract Class</strong> when <code>Car</code> and <code>Truck</code> share common behavior like <code>startEngine()</code>.</li>
      <li>Use <strong>Interface</strong> when <code>Bird</code>, <code>Airplane</code>, and <code>Drone</code> all share <code>fly()</code> but are unrelated.</li>
    </ul>
  </div>

  <h2>Example Code</h2>
  <pre>
abstract class Animal {
    abstract void makeSound();

    void sleep() {
        System.out.println("Sleeping");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog Barks");
    }
}

class AbstractTest {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.makeSound();
        d.sleep();
    }
}
  </pre>

  <h3>Output:</h3>
  <pre>
Dog Barks
Sleeping
  </pre>
</div>

<hr>

<div class="section">
  <h2>Encapsulation</h2>

  <div class="section">
    <h3>Definition</h3>
    <p>
      Encapsulation is the process of wrapping data (variables) and code (methods) together into a single unit typically a class and restricting direct access to some of the object's components.
    </p>
    <ul>
      <li>To protect data from unauthorized access</li>
      <li>Data hiding - internal details are hidden from outside</li>
      <li>Controlled Access - decide who can read/write</li>
    </ul>
  </div>

  <div class="section">
    <h3>Encapsulation Rules</h3>
    <ul>
      <li>Declare variables as <code>private</code></li>
      <li>Provide public <code>get</code> and <code>set</code> methods to access/update them</li>
      <li>Wrap everything inside a <code>class</code></li>
    </ul>
  </div>

  <div class="section">
    <h3>Java Example</h3>
    <pre><code>class Student {
    private String name;
    private int age;

    // Getter
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Setter
    public void setName(String newName) {
        name = newName;
    }

    public void setAge(int newAge) {
        if(newAge > 0) {
            age = newAge;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("Aathi");
        s.setAge(21);

        System.out.println(s.getName());
        System.out.println(s.getAge());
    }
}</code></pre>
  </div>

  <div class="section">
    <h3>Output</h3>
    <pre><code>Aathi
21</code></pre>
  </div>

  <div class="section">
    <h3>Why Use Encapsulation?</h3>
    <ul>
      <li>Protect variables by making them <code>private</code></li>
      <li>Control how values are read or written</li>
      <li>Validate input before updating fields</li>
    </ul>
  </div>

  <div class="section">
    <h3>Syntax</h3>
    <pre><code>class Student {
    private String name;     // private = cannot access directly
    private int age;

    // ✅ GETTER → to read value
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // ✅ SETTER → to update value
    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        // Optional: Validation
        if(age > 0)
            this.age = age;
    }
}</code></pre>
  </div>

  <div class="section">
    <h3>Usage</h3>
    <pre><code>Student s = new Student();

s.setName("Aathi");
s.setAge(20);

System.out.println(s.getName());  // ➝ Aathi
System.out.println(s.getAge());   // ➝ 20</code></pre>
  </div>

  <div class="section">
    <h3>Advantages of Encapsulation</h3>
    <ul>
      <li>✔ Data hiding: Protect internal data</li>
      <li>✔ Add validation logic in setters</li>
      <li>✔ Maintain clean API even if internal implementation changes</li>
      <li>✔ Easier to maintain, safer for future updates</li>
    </ul>
  </div>

  <div class="section">
    <h3>Characteristics of Getters and Setters</h3>
    <h4>🔹 Getter Method:</h4>
    <ul>
      <li>Used to "get" or read the value of a private field</li>
      <li>Public in access</li>
      <li>Has no parameters</li>
      <li>Returns the data type of the field</li>
      <li>Follows naming: <code>getFieldName()</code></li>
    </ul>
    <pre><code>public String getName() {
    return name;
}</code></pre>

    <h4>🔸 Setter Method:</h4>
    <ul>
      <li>Used to "set" or update the value of a private field</li>
      <li>Public in access</li>
      <li>Has one parameter (same type as the field)</li>
      <li>Return type is <code>void</code></li>
      <li>Follows naming: <code>setFieldName()</code></li>
    </ul>
    <pre><code>public void setName(String name) {
    this.name = name;
}</code></pre>

    <h4>🔹 Encapsulation with Validation:</h4>
    <pre><code>public void setAge(int age) {
    if(age > 0)
        this.age = age;
    else
        System.out.println("Invalid age!");
}</code></pre>
  </div>

  <div class="section">
    <h3>☑️ Setter and Getter for Boolean Variables</h3>
    <ul>
      <li>For boolean fields, getter uses <code>is</code> instead of <code>get</code></li>
      <li>Follows naming: <code>isFieldName()</code></li>
    </ul>
    <pre><code>// Field:
private boolean active;

// Getter:
public boolean isActive() {
    return active;
}

// Setter:
public void setActive(boolean active) {
    this.active = active;
}</code></pre>
  </div>
</div>


<hr>

<div class="section">
  <h2>Array</h2>
  <p>It is the collection of elements of the same type stored in a fixed size container.</p>
  <p>Array is a continuous memory location which is logically divided into multiple parts to store multiple data.</p>
  <p>Size of the array will be fixed and we cannot modify the size during the execution of the program.</p>
  <p>We can declare the size of an array during the declaration of an array.</p>

  <h3>Syntax</h3>
  <pre>datatype[] variable_name = new datatype[size];</pre>

  <h3>Initialization</h3>
  <pre>array_reference[index] = value;</pre>

  <h3>Example</h3>
  <pre>int[] arr = new int[5];
arr[3] = 8;
System.out.println(arr[3]);  // Output: 8</pre>

  <h3>Index</h3>
  <p>Index is an integer value which starts from <b>0</b> and goes till <b>(size - 1)</b>.</p>

  <h3>Declaration and Initialization in One Line</h3>
  <pre>datatype[] variable_name = {value1, value2, value3, ...};</pre>

  <h3>Examples</h3>
  <pre>int[] numbers = new int[5];              // Declaration with size
int[] marks = {90, 80, 85, 70, 95};      // Declaration with values</pre>

  <h3>Traversing 1D Array</h3>
  <pre>for(int i = 0; i &lt; marks.length; i++) {
    System.out.println(marks[i]);
}</pre>

  <h3>Useful Methods</h3>
  <pre>import java.util.Arrays;

int[] arr = {4, 1, 3, 5, 2};

Arrays.sort(arr);                        // Sort the array
System.out.println(Arrays.toString(arr)); // Print array elements

int index = Arrays.binarySearch(arr, 3); // Binary search (sorted only)
System.out.println("Index: " + index);</pre>

  <hr>

  <h2>2D Array</h2>
  <p>A 2D array is an array of arrays (matrix format).</p>

  <h3>Syntax</h3>
  <pre>int[][] num = new int[2][3];</pre>

  <p>2 → rows<br>3 → columns</p>

  <h3>Assigning Values</h3>
  <pre>num[0][0] = 1;
num[0][1] = 2;
num[0][2] = 3;
num[1][0] = 4;
num[1][1] = 5;
num[1][2] = 6;</pre>

  <h3>Traversal</h3>
  <pre>for(int i = 0; i &lt; num.length; i++) {
    for(int j = 0; j &lt; num[i].length; j++) {
        System.out.print(num[i][j] + " ");
    }
    System.out.println();
}</pre>

  <h3>Declaration with Initialization</h3>
  <pre>int[][] mat = {
    {1, 2, 3},
    {4, 5, 6}
};</pre>

  <h3>Print 2D Array</h3>
  <pre>for (int[] row : mat) {
    for (int val : row) {
        System.out.print(val + " ");
    }
    System.out.println();
}</pre>

  <hr>

  <h2>Multi-Dimensional Array</h2>
  <p>One array inside another array (more than 2 dimensions).</p>

  <h3>Declaration</h3>
  <pre>datatype[][][] variable;</pre>

  <h3>Declaration + Initialization</h3>
  <pre>int[][][] cube = new int[2][2][2];</pre>

  <h3>Initialization Later</h3>
  <pre>cube[0][0][0] = 1;
cube[0][0][1] = 2;
cube[1][1][1] = 8;</pre>

  <h3>Traversal</h3>
  <pre>for(int i=0; i&lt;cube.length; i++) {
    for(int j=0; j&lt;cube[i].length; j++) {
        for(int k=0; k&lt;cube[i][j].length; k++) {
            System.out.print(cube[i][j][k] + " ");
        }
        System.out.println();
    }
    System.out.println("---");
}</pre>

  <hr>

  <h2>Jagged Array</h2>
  <p>A jagged array is a multi-dimensional array with unequal row sizes.</p>

  <h3>Syntax</h3>
  <pre>int[][] jagged = new int[3][];     // 3 rows, no columns yet

jagged[0] = new int[2];            // 2 columns
jagged[1] = new int[4];            // 4 columns
jagged[2] = new int[3];            // 3 columns</pre>

  <h3>Assigning Values</h3>
  <pre>jagged[0][0] = 1;
jagged[0][1] = 2;
jagged[1][0] = 3;
// ... and so on</pre>

  <h3>Traversing Jagged Array</h3>
  <pre>for(int i = 0; i &lt; jagged.length; i++) {
    for(int j = 0; j &lt; jagged[i].length; j++) {
        System.out.print(jagged[i][j] + " ");
    }
    System.out.println();
}</pre>

  <hr>

  <h2>Array Utility Methods (from Arrays class)</h2>
  <pre>import java.util.Arrays;

int[] data = {5, 2, 8, 3, 1};

// Sort
Arrays.sort(data);

// Convert to string
System.out.println(Arrays.toString(data)); // [1, 2, 3, 5, 8]

// Binary Search
int pos = Arrays.binarySearch(data, 3);

// Fill array
int[] filled = new int[5];
Arrays.fill(filled, 10); // [10, 10, 10, 10, 10]

// Copy array
int[] copy = Arrays.copyOf(data, data.length);

// Compare arrays
boolean same = Arrays.equals(data, copy);</pre>
</div>
 <div class="section">
    <h2>Common Array Methods</h2>
    <ul>
      <li><code>Arrays.toString(array)</code> – Returns string representation of 1D array</li>
      <li><code>Arrays.deepToString(array)</code> – For multidimensional arrays</li>
      <li><code>Arrays.sort(array)</code> – Sorts the array in ascending order</li>
      <li><code>Arrays.copyOf(array, length)</code> – Returns a copy with new length</li>
      <li><code>Arrays.equals(arr1, arr2)</code> – Checks if arrays are equal</li>
      <li><code>Arrays.binarySearch(array, key)</code> – Returns index of key (sorted array only)</li>
      <li><code>array.length</code> – Returns size of array (not a method, it's a field)</li>
    </ul>
  </div>

<hr>

<div class="section">
  <h2>String</h2>
  <p>String is a non-primitive datatype.</p>
  <p>Anything present inside double quotes <code>" "</code> is considered a String.</p>
  <p>The String class contains many methods to perform operations on strings.</p>

  <h3>String Comparison (Literal vs New)</h3>
  <pre>
String s1 = "AATHI";
String s2 = "AATHI";
String s3 = new String("AATHI");
String s4 = new String("AATHI");

System.out.println(s1 == s2);     // true (same literal in String Pool)
System.out.println(s1 == s3);     // false (new object in heap)
System.out.println(s1.equals(s3)); // true (same content)
System.out.println(s3 == s4);     // false (different memory)
System.out.println(s3.equals(s4)); // true (same content)
  </pre>

  <h3>StringBuilder Comparison</h3>
  <pre>
StringBuilder sb1 = new StringBuilder("AATHI");
StringBuilder sb2 = new StringBuilder("AATHI");

System.out.println(sb1 == sb2);       // false (different objects)
System.out.println(sb1.equals(sb2));  // false (equals not overridden)
  </pre>

  <h3>StringBuffer Comparison</h3>
  <pre>
StringBuffer sbf1 = new StringBuffer("AATHI");
StringBuffer sbf2 = new StringBuffer("AATHI");

System.out.println(sbf1 == sbf2);       // false
System.out.println(sbf1.equals(sbf2));  // false
  </pre>

  <hr>
  <h2>String vs StringBuilder vs StringBuffer</h2>

  <table border="1" cellpadding="8">
    <thead>
      <tr>
        <th>Feature</th>
        <th>String</th>
        <th>StringBuilder</th>
        <th>StringBuffer</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>Mutability</td><td>No</td><td>Yes</td><td>Yes</td></tr>
      <tr><td>Thread-safe</td><td>No</td><td>No</td><td>Yes</td></tr>
      <tr><td>Performance</td><td>Slow</td><td>Fast</td><td>Slower</td></tr>
      <tr><td>Use-case</td><td>Fixed text</td><td>Single-thread</td><td>Multi-thread</td></tr>
    </tbody>
  </table>

  <h3>Examples</h3>

  <h4>String (Immutable)</h4>
  <pre>
String s1 = "Hello";
String s2 = s1.concat(" World");
System.out.println(s1); // Hello
System.out.println(s2); // Hello World
  </pre>

  <h4>StringBuilder (Mutable)</h4>
  <pre>
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb); // Hello World
  </pre>

  <h4>StringBuffer (Mutable & Thread-safe)</h4>
  <pre>
StringBuffer sbf = new StringBuffer("Hello");
sbf.append(" World");
System.out.println(sbf); // Hello World
  </pre>

  <hr>
  <h2> Commonly Used String Methods</h2>

<h3>✅ String Methods (Immutable)</h3>
<ul>
  <li><b>length()</b> – Returns the number of characters in the string.</li>
  <li><b>charAt(int index)</b> – Returns the character at the specified index.</li>
  <li><b>substring(int beginIndex)</b> – Returns the substring from the given index to the end.</li>
  <li><b>substring(int begin, int end)</b> – Returns the substring from begin (inclusive) to end (exclusive).</li>
  <li><b>contains(String s)</b> – Returns true if the string contains the specified substring.</li>
  <li><b>equals(String s)</b> – Compares two strings for exact match (case-sensitive).</li>
  <li><b>equalsIgnoreCase(String s)</b> – Compares two strings ignoring case differences.</li>
  <li><b>isEmpty()</b> – Returns true if the string is empty (length == 0).</li>
  <li><b>toUpperCase()</b> – Converts all characters to uppercase.</li>
  <li><b>toLowerCase()</b> – Converts all characters to lowercase.</li>
  <li><b>trim()</b> – Removes leading and trailing whitespace.</li>
  <li><b>replace(old, new)</b> – Replaces all occurrences of old character/substring with new.</li>
  <li><b>indexOf(char/string)</b> – Returns the first index of the character or substring.</li>
  <li><b>lastIndexOf(char/string)</b> – Returns the last index of the character or substring.</li>
  <li><b>split(String regex)</b> – Splits the string based on the given regex and returns an array.</li>
  <li><b>startsWith(String)</b> – Checks if the string starts with the specified prefix.</li>
  <li><b>endsWith(String)</b> – Checks if the string ends with the specified suffix.</li>
  <li><b>toCharArray()</b> – Converts the string into a character array.</li>
  <li><b>valueOf(data)</b> – Converts any data type to a string (static method).</li>
  <li><b>compareTo(String)</b> – Compares two strings lexicographically.</li>
</ul>

<h3>✅ StringBuilder Methods (Mutable, Not Thread-Safe)</h3>
<ul>
  <li><b>append(String s)</b> – Adds the given string to the end.</li>
  <li><b>insert(int offset, String s)</b> – Inserts the string at the specified index.</li>
  <li><b>replace(int start, int end, String s)</b> – Replaces the characters between start and end with the given string.</li>
  <li><b>delete(int start, int end)</b> – Deletes characters from start (inclusive) to end (exclusive).</li>
  <li><b>deleteCharAt(int index)</b> – Deletes the character at the given index.</li>
  <li><b>reverse()</b> – Reverses the character sequence.</li>
  <li><b>capacity()</b> – Returns the current capacity of the builder.</li>
  <li><b>ensureCapacity(int min)</b> – Ensures the capacity is at least the specified minimum.</li>
  <li><b>length()</b> – Returns the length of the current sequence.</li>
  <li><b>charAt(int index)</b> – Returns the character at the specified index.</li>
  <li><b>setCharAt(int index, char)</b> – Changes the character at the given index.</li>
  <li><b>toString()</b> – Converts the builder content to a string.</li>
</ul>

<h3>✅ StringBuffer Methods (Mutable, Thread-Safe)</h3>
<ul>
  <li><b>append(String s)</b> – Adds the given string to the end.</li>
  <li><b>insert(int offset, String s)</b> – Inserts the string at the specified index.</li>
  <li><b>replace(int start, int end, String s)</b> – Replaces the characters between start and end with the given string.</li>
  <li><b>delete(int start, int end)</b> – Deletes characters from start to end.</li>
  <li><b>reverse()</b> – Reverses the sequence of characters.</li>
  <li><b>length()</b> – Returns the number of characters.</li>
  <li><b>capacity()</b> – Returns the current capacity.</li>
  <li><b>setCharAt(index, char)</b> – Sets the character at the specified index.</li>
  <li><b>toString()</b> – Converts the buffer content to a string.</li>
</ul>

  <hr>
  <h2>Bonus: Conversion Methods</h2>
  <table border="1" cellpadding="8">
    <thead>
      <tr>
        <th>From</th>
        <th>To</th>
        <th>Method</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>char</td><td>String</td><td>String.valueOf(ch), ch + ""</td></tr>
      <tr><td>char[]</td><td>String</td><td>new String(char[])</td></tr>
      <tr><td>String</td><td>StringBuilder</td><td>new StringBuilder(str)</td></tr>
      <tr><td>String</td><td>StringBuffer</td><td>new StringBuffer(str)</td></tr>
      <tr><td>StringBuilder</td><td>String</td><td>toString()</td></tr>
      <tr><td>StringBuffer</td><td>String</td><td>toString()</td></tr>
      <tr><td>StringBuilder</td><td>StringBuffer</td><td>new StringBuffer(sb.toString())</td></tr>
      <tr><td>StringBuffer</td><td>StringBuilder</td><td>new StringBuilder(sb.toString())</td></tr>
    </tbody>
  </table>
</div>

<hr>

<div class="section">
  <h2>🌳 Java Exception Hierarchy (Flowchart Style)</h2>

  <ul>
    <li><b>Object</b>
      <ul>
        <li><b>Throwable</b>
          <ul>
            <li><b>Error</b> (Unrecoverable)
              <ul>
                <li>VirtualMachineError
                  <ul>
                    <li>StackOverflowError</li>
                    <li>OutOfMemoryError</li>
                  </ul>
                </li>
                <li>AssertionError</li>
              </ul>
            </li>
            <li><b>Exception</b> (Recoverable)
              <ul>
                <li><b>Checked Exceptions (Compile-Time)</b>
                  <ul>
                    <li>IOException
                      <ul>
                        <li>FileNotFoundException</li>
                        <li>EOFException</li>
                        <li>InterruptedIOException</li>
                      </ul>
                    </li>
                    <li>SQLException</li>
                    <li>AWTException</li>
                    <li>InterruptedException</li>
                  </ul>
                </li>
                <li><b>Unchecked Exceptions (Runtime)</b>
                  <ul>
                    <li>RuntimeException
                      <ul>
                        <li>ArithmeticException</li>
                        <li>NullPointerException</li>
                        <li>ArrayIndexOutOfBoundsException</li>
                        <li>StringIndexOutOfBoundsException</li>
                        <li>NumberFormatException</li>
                        <li>ClassCastException</li>
                        <li>IllegalArgumentException</li>
                        <li>IllegalStateException</li>
                        <li>NegativeArraySizeException</li>
                        <li>UnsupportedOperationException</li>
                        <li>IndexOutOfBoundsException</li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</div>

<div class="section">
  <h1>🛠️ Java Exception Handling (Basics)</h1>

  <h2>What is an Exception?</h2>
  <ul>
    <li>An <strong>exception</strong> is an <strong>unexpected error</strong> that occurs during program execution.</li>
    <li>It interrupts the normal flow of the program.</li>
  </ul>
  <div class="highlight">
    <strong>Examples:</strong>
    <ul>
      <li>Dividing by zero</li>
      <li>Accessing an invalid array index</li>
      <li>Opening a file that doesn't exist</li>
    </ul>
  </div>

  <h2>Types of Errors in Java</h2>
  <ol>
    <li><strong>Compile-Time Errors</strong> ➝ Syntax issues</li>
    <li><strong>Runtime Errors</strong> ➝ Exceptions (handled using try-catch)</li>
    <li><strong>Logical Errors</strong> ➝ Program runs but gives wrong output</li>
  </ol>

  <h2>Types of Exceptions</h2>
  <h3>1️⃣ Checked Exceptions (Compile-time)</h3>
  <ul>
    <li>Must be handled using <code>try-catch</code> or <code>throws</code>.</li>
    <li>Examples: <code>IOException</code>, <code>SQLException</code>, <code>FileNotFoundException</code></li>
  </ul>

  <h3>2️⃣ Unchecked Exceptions (Runtime)</h3>
  <ul>
    <li>Occurs during execution, optional to handle.</li>
    <li>Examples: <code>ArithmeticException</code>, <code>NullPointerException</code>, <code>ArrayIndexOutOfBoundsException</code></li>
  </ul>

  <h2>Java Exception Hierarchy</h2>
  <pre>
Object
   |
Throwable
 /       \
Error   Exception
        /        \
 Checked     Unchecked (Runtime)
  </pre>

  <h2>Basic Syntax of try-catch</h2>
  <pre>
try {
    // Code that may cause exception
} catch (ExceptionType e) {
    // Handling code
}
  </pre>

  <table>
    <tr>
      <th>Keyword</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td><code>try</code></td>
      <td>Wraps risky code that may throw exception</td>
    </tr>
    <tr>
      <td><code>catch</code></td>
      <td>Handles exception type</td>
    </tr>
    <tr>
      <td><code>finally</code></td>
      <td>Runs always (for cleanup)</td>
    </tr>
    <tr>
      <td><code>throw</code></td>
      <td>Used to throw an exception manually</td>
    </tr>
    <tr>
      <td><code>throws</code></td>
      <td>Declares exceptions in method signature</td>
    </tr>
  </table>

  <pre>
try {
    // Risky code
} catch (ExceptionType e) {
    // Handle exception
} finally {
    // Always runs
}
  </pre>

  <h3>Example:</h3>
  <pre>
try {
    int[] arr = {1, 2, 3};
    System.out.println(arr[5]);
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Invalid index!");
} finally {
    System.out.println("Cleanup code here.");
}
  </pre>

  <h2>throw vs throws</h2>
  <table>
    <tr>
      <th>throw</th>
      <th>throws</th>
    </tr>
    <tr>
      <td>Used to <strong>manually throw</strong> an exception</td>
      <td>Declares that method <strong>might throw</strong> exception</td>
    </tr>
    <tr>
      <td>Used inside method</td>
      <td>Used in method declaration</td>
    </tr>
    <tr>
      <td>Can throw only <strong>one</strong> exception at a time</td>
      <td>Can declare multiple exceptions</td>
    </tr>
    <tr>
      <td><code>throw new ArithmeticException();</code></td>
      <td><code>void read() throws IOException</code></td>
    </tr>
  </table>

  <h3>Example:</h3>
  <pre>
public class Demo {
    static void test(int age) {
        if (age < 18)
            throw new ArithmeticException("Not eligible");
        else
            System.out.println("Eligible");
    }

    public static void main(String[] args) {
        test(16);
    }
}
  </pre>

  <h2>Multiple Catch Blocks</h2>
  <pre>
try {
    String s = null;
    System.out.println(s.length());
} catch (NullPointerException e) {
    System.out.println("Null object!");
} catch (Exception e) {
    System.out.println("Other exception!");
}
  </pre>

  <h2>Nested try-catch</h2>
  <pre>
try {
    try {
        int a = 10 / 0;
    } catch (ArithmeticException e) {
        System.out.println("Divide by zero!");
    }

    String s = null;
    System.out.println(s.length());

} catch (NullPointerException e) {
    System.out.println("Null value!");
}
  </pre>

  <h2>Key Points on Exceptions</h2>
  <ul>
    <li>Every exception arises because of a statement at runtime.</li>
    <li>The type of exception object created depends on the statement causing it.</li>
    <li>To manually throw an exception, use <code>throw</code> keyword.</li>
  </ul>

  <h3>throw Keyword Syntax:</h3>
  <pre>
throw new NumberFormatException();
  </pre>

  <h3>Checked vs Unchecked Exception:</h3>
  <ul>
    <li><strong>Checked:</strong> Compiler-aware, must handle or declare. Examples: <code>FileNotFoundException</code>, <code>IOException</code></li>
    <li><strong>Unchecked:</strong> Compiler-unaware, optional to handle. Examples: <code>ArithmeticException</code>, <code>NullPointerException</code></li>
  </ul>

  <h2>printStackTrace()</h2>
  <p>This method (inherited from <code>Throwable</code>) displays the class name, reason, and the stack trace of the exception.</p>

  <h2>finally Block</h2>
  <ul>
    <li>Contains important code that must always execute.</li>
    <li>Executes whether exception occurs or not.</li>
    <li>Execution can be avoided by using <code>System.exit()</code>.</li>
  </ul>

  <h2>Object Propagation</h2>
  <p>The movement of an exception object from one method (frame) to another in the call stack.</p>
  <ul>
    <li>Unchecked exceptions propagate implicitly.</li>
    <li>Checked exceptions must be explicitly declared using <code>throws</code> or handled.</li>
  </ul>

  <h2>throws Keyword</h2>
  <ul>
    <li>Used to propagate exceptions from one method to another.</li>
    <li>Mostly used for checked exceptions.</li>
    <li>Can declare multiple exceptions.</li>
  </ul>

  <h2>Custom Exceptions</h2>
  <p>When built-in exceptions are insufficient, you can create your own.</p>
  <div class="highlight">
    <strong>Steps:</strong>
    <ol>
      <li>Create a class extending <code>Exception</code> (checked) or <code>RuntimeException</code> (unchecked).</li>
      <li>Create a constructor with a reason and pass it to <code>super()</code>.</li>
    </ol>
  </div>

  <h2>Error</h2>
  <p>An <strong>Error</strong> represents serious problems that occur during runtime, usually caused by the system, not the code.</p>
  <div class="highlight">
    <strong>Examples:</strong> <code>OutOfMemoryError</code>, <code>StackOverflowError</code>
  </div>

  <h2>Feature Comparison</h2>
  <table>
    <tr>
      <th>Feature</th>
      <th>Checked Exception</th>
      <th>Unchecked Exception</th>
    </tr>
    <tr>
      <td>Compiler Check</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Must use <code>throws</code> if not handled</td>
      <td>✅ Yes</td>
      <td>❌ No</td>
    </tr>
    <tr>
      <td>Example</td>
      <td><code>IOException</code>, <code>SQLException</code></td>
      <td><code>NullPointerException</code>, <code>ArithmeticException</code></td>
    </tr>
  </table>
</div>

<hr>

<div class="section">
  <h1>📂 Java File Handling</h1>

  <h2>Definition</h2>
  <p>
    <strong>File Handling</strong> in Java is the process of creating, reading, writing, and updating files stored on disk using the <code>java.io</code> package.
    It allows persistent data storage beyond the program’s execution.
  </p>

  <h2>Flowchart: File Handling Process</h2>
  <pre>
          ┌───────────────────────┐
          │    Create/Open File   │
          └──────────┬────────────┘
                     │
           ┌─────────▼─────────┐
           │ Read / Write Data │
           └─────────┬─────────┘
                     │
           ┌─────────▼─────────┐
           │ Close the Stream  │
           └───────────────────┘
  </pre>

  <h2>Key Points</h2>
  <ul>
    <li><code>createNewFile()</code> → Returns <code>true</code> if file is created, <code>false</code> if it already exists.</li>
    <li><code>FileWriter</code> overwrites the file. Use <code>new FileWriter(file, true)</code> to append instead of overwrite.</li>
    <li>Always close streams using <code>close()</code> to prevent data loss.</li>
    <li>Most file handling methods throw <strong>checked exceptions</strong> (like <code>IOException</code>), so they must be handled using <code>try-catch</code> or declared with <code>throws</code>.</li>
  </ul>

  <h2>Character Stream vs Byte Stream</h2>
  <table>
    <tr>
      <th>Feature</th>
      <th>Character Stream</th>
      <th>Byte Stream</th>
    </tr>
    <tr>
      <td>Classes</td>
      <td><code>FileReader</code>, <code>FileWriter</code>, <code>BufferedReader</code>, <code>BufferedWriter</code></td>
      <td><code>FileInputStream</code>, <code>FileOutputStream</code>, <code>BufferedInputStream</code>, <code>BufferedOutputStream</code></td>
    </tr>
    <tr>
      <td>Data type handled</td>
      <td>Reads/Writes <strong>characters</strong> (text)</td>
      <td>Reads/Writes <strong>raw bytes</strong> (binary or text)</td>
    </tr>
    <tr>
      <td>Encoding aware</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Use case</td>
      <td>Text files (.txt, .java, .csv)</td>
      <td>Binary files (.jpg, .mp3, .pdf)</td>
    </tr>
  </table>

  <h2>Common File Handling Classes</h2>
  <table>
    <tr>
      <th>Class</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td><code>File</code></td>
      <td>Represents file/directory path.</td>
    </tr>
    <tr>
      <td><code>FileWriter</code></td>
      <td>Write text to a file (character stream).</td>
    </tr>
    <tr>
      <td><code>FileReader</code></td>
      <td>Read text from a file (character stream).</td>
    </tr>
    <tr>
      <td><code>BufferedReader</code></td>
      <td>Read text efficiently, line-by-line.</td>
    </tr>
    <tr>
      <td><code>PrintWriter</code></td>
      <td>Write text easily using <code>print</code>/<code>println</code>.</td>
    </tr>
  </table>

  <h2>Basic Syntax Examples</h2>
  <h3>Create a File</h3>
  <pre>
import java.io.*;

public class CreateFileExample {
    public static void main(String[] args) {
        try {
            File file = new File("example.txt");
            if (file.createNewFile()) {
                System.out.println("File created: " + file.getName());
            } else {
                System.out.println("File already exists.");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
  </pre>

  <h3>Write to a File</h3>
  <pre>
import java.io.*;

public class WriteFileExample {
    public static void main(String[] args) {
        try {
            FileWriter writer = new FileWriter("example.txt");
            writer.write("Hello, Java File Handling!");
            writer.close();
            System.out.println("Data written to file.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
  </pre>

  <h3>Append to a File</h3>
  <pre>
FileWriter writer = new FileWriter("example.txt", true);
writer.write("\nThis is appended text.");
writer.close();
  </pre>

  <h3>Read from a File</h3>
  <pre>
import java.io.*;

public class ReadFileExample {
    public static void main(String[] args) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader("example.txt"));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
  </pre>

  <hr>

  <h1>🗄️ Serialization & Deserialization</h1>

  <h2>Definition</h2>
  <ul>
    <li><strong>Serialization</strong> → Converting a Java object into a byte stream so it can be stored in a file or sent over a network.</li>
    <li><strong>Deserialization</strong> → Reconstructing the object from the byte stream back into memory.</li>
  </ul>

  <h2>Key Points</h2>
  <ul>
    <li>Uses <code>ObjectOutputStream</code> (for writing) and <code>ObjectInputStream</code> (for reading).</li>
    <li>The class must implement <code>Serializable</code> interface (marker interface).</li>
    <li>If a field is marked as <code>transient</code>, it will not be serialized.</li>
    <li>During deserialization, <code>transient</code> fields get default values (e.g., <code>null</code> for objects, <code>0</code> for numbers).</li>
  </ul>

  <h2>Flow: Serialization</h2>
  <pre>
Object → Serialize (ObjectOutputStream) → Byte Stream → File / Network
  </pre>

  <h2>Example: Serialization</h2>
  <pre>
import java.io.*;

class Student implements Serializable {
    String name;
    transient int age; // will not be serialized

    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class SerializeExample {
    public static void main(String[] args) {
        try {
            Student s1 = new Student("Alice", 22);
            FileOutputStream fos = new FileOutputStream("student.ser");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(s1);
            oos.close();
            fos.close();
            System.out.println("Object serialized.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
  </pre>

  <h2>Example: Deserialization</h2>
  <pre>
import java.io.*;

class DeserializeExample {
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream("student.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            Student s = (Student) ois.readObject();
            ois.close();
            fis.close();

            System.out.println("Name: " + s.name);
            System.out.println("Age: " + s.age); // will be 0 because 'age' is transient
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
  </pre>

  <div class="highlight">
    <strong>Important:</strong>  
    - Use <code>transient</code> to skip sensitive data during serialization.  
    - Always close streams after use.  
    - Serialization is mostly used for saving object state or sending objects over networks.
  </div>
</div>

<hr>

<div class="section">
  <h1>📦 Wrapper Classes</h1>

  <h2>Primitive → Wrapper mapping</h2>
  <table>
    <tr>
      <th>Primitive</th>
      <th>Wrapper Class</th>
      <th>Size / Notes</th>
    </tr>
    <tr><td><code>byte</code></td><td><code>Byte</code></td><td>8-bit signed</td></tr>
    <tr><td><code>short</code></td><td><code>Short</code></td><td>16-bit signed</td></tr>
    <tr><td><code>int</code></td><td><code>Integer</code></td><td>32-bit signed</td></tr>
    <tr><td><code>long</code></td><td><code>Long</code></td><td>64-bit signed</td></tr>
    <tr><td><code>float</code></td><td><code>Float</code></td><td>32-bit IEEE 754</td></tr>
    <tr><td><code>double</code></td><td><code>Double</code></td><td>64-bit IEEE 754</td></tr>
    <tr><td><code>char</code></td><td><code>Character</code></td><td>16-bit Unicode</td></tr>
    <tr><td><code>boolean</code></td><td><code>Boolean</code></td><td>true / false</td></tr>
  </table>

  <h2>Why wrapper classes?</h2>
  <ul>
    <li>Java is <strong>not 100% object-oriented</strong> because primitives are not objects. Wrapper classes were introduced so primitive values can be treated as objects.</li>
    <li>Wrappers are required by many APIs that work with objects (for example, Java Collections and Generics: <code>List<Integer></code>).</li>
    <li>Wrapper classes provide utility methods (parsing, conversions, constants like <code>Integer.MAX_VALUE</code>).</li>
  </ul>

  <h2>Boxing / Unboxing (and auto versions)</h2>
  <p><strong>Boxing</strong> = converting primitive → wrapper (explicitly using <code>valueOf()</code> or constructor).<br>
     <strong>Autoboxing</strong> = automatic boxing performed by compiler (since Java 5).</p>

  <p><strong>Unboxing</strong> = converting wrapper → primitive (explicitly using <code>xxxValue()</code>).<br>
     <strong>Auto-unboxing</strong> = automatic unboxing performed by compiler.</p>

  <h3>Syntax & examples</h3>
  <pre>
// Boxing (explicit)
Integer boxed = Integer.valueOf(42);

// Autoboxing (compiler does it)
Integer autoBoxed = 42;  // same as Integer.valueOf(42)

// Unboxing (explicit)
int primitive = boxed.intValue();

// Auto-unboxing
int autoUnboxed = boxed; // compiler inserts intValue()
  </pre>

  <h2>Parsing Strings → primitives</h2>
  <p>All numeric wrapper classes (except <code>Character</code>) provide <code>parseXxx(String)</code> that returns a primitive and <code>valueOf(String)</code> that returns a wrapper object.</p>

  <h3>Examples</h3>
  <pre>
int n = Integer.parseInt("123");             // returns primitive int
Integer i = Integer.valueOf("123");          // returns Integer object

boolean b = Boolean.parseBoolean("true");    // returns primitive boolean (false if not "true")
Boolean B = Boolean.valueOf("true");         // returns Boolean object

char c = "hello".charAt(0);                  // use String.charAt — Character has no parseChar(String)
Character C = Character.valueOf('x');
  </pre>

  <h3>NumberFormatException (common pitfall)</h3>
  <pre>
try {
    int bad = Integer.parseInt("12a"); // throws NumberFormatException
} catch (NumberFormatException e) {
    System.out.println("Invalid number: " + e.getMessage());
}
  </pre>

  <h2>Useful wrapper methods</h2>
  <ul>
    <li><code>xxx.parseXxx(String)</code> → primitive (e.g., <code>Integer.parseInt</code>).</li>
    <li><code>xxx.valueOf(String)</code> → wrapper object (may use caching).</li>
    <li><code>xxxValue()</code> → convert wrapper to other primitives (e.g., <code>doubleValue()</code>, <code>longValue()</code>).</li>
    <li><code>toString()</code> → string representation.</li>
    <li><code>compareTo()</code> and <code>equals()</code> → comparisons (wrappers implement <code>Comparable</code>).</li>
    <li><code>Integer.MAX_VALUE</code>, <code>MIN_VALUE</code> and similar constants.</li>
    <li><code>Double.isNaN()</code>, <code>Double.isInfinite()</code> — special checks for floating point wrappers.</li>
  </ul>

  <h2>Number class</h2>
  <p><code>Byte, Short, Integer, Long, Float, Double</code> extend <code>Number</code>. <code>Number</code> provides methods:</p>
  <pre>
int intValue()
long longValue()
float floatValue()
double doubleValue()
byte byteValue()
short shortValue()
  </pre>
  <p>Useful when you have a generic number and need a specific primitive value.</p>

  <h2>Important behaviors & pitfalls</h2>
  <ul>
    <li><strong>Caching</strong>: <code>Integer.valueOf</code> (and other wrappers) cache commonly used values (standard -128..127 for <code>Integer</code>), so:</li>
  </ul>
  <pre>
Integer a = 127;
Integer b = 127;
System.out.println(a == b);   // true (cached)
Integer x = 128;
Integer y = 128;
System.out.println(x == y);   // usually false (different objects)
  </pre>
  <ul>
    <li>Use <code>equals()</code> to compare wrapper values reliably: <code>a.equals(b)</code>.</li>
    <li><strong>NullPointerException on unboxing:</strong></li>
  </ul>
  <pre>
Integer n = null;
int m = n; // throws NullPointerException (auto-unboxing attempts to read value)
  </pre>
  <ul>
    <li><strong>Performance:</strong> boxing/unboxing creates objects (or uses cached ones) which is slower and uses more memory than primitives — avoid in tight loops.</li>
    <li><strong>Immutability:</strong> wrapper instances are immutable and final — they are safe to share between threads.</li>
    <li><strong>Use-cases:</strong> Collections/Generics, Reflection, APIs requiring <code>Object</code>, streams with boxed types (<code>Stream<Integer></code>), or when you need methods on the value (e.g., <code>toString()</code>, <code>compareTo()</code>).</li>
  </ul>

  <h2>Small, focused examples</h2>
  <h3>1) Autoboxing with collections</h3>
  <pre>
import java.util.*;

List<Integer> list = new ArrayList<>();
list.add(10);        // autoboxing from int -> Integer
int val = list.get(0); // auto-unboxing from Integer -> int
  </pre>

  <h3>2) Parsing with exception handling</h3>
  <pre>
String s = "12a";
try {
    int v = Integer.parseInt(s); // NumberFormatException here
} catch (NumberFormatException e) {
    System.out.println("Not a number: " + s);
}
  </pre>

  <h3>3) Beware of == vs equals()</h3>
  <pre>
Integer a = 100; Integer b = 100;
System.out.println(a == b);           // often true (cached)
System.out.println(a.equals(b));      // true

Integer x = 128; Integer y = 128;
System.out.println(x == y);           // often false
System.out.println(x.equals(y));      // true
  </pre>

  <h3>4) Null unboxing problem</h3>
  <pre>
Integer maybe = null;
if (maybe != null && maybe > 0) {  // even this may auto-unbox; check for null first
    System.out.println("positive");
}
  </pre>

  <h2>Extras — small checklist / best practices</h2>
  <ul>
    <li>Prefer <code>valueOf()</code> or autoboxing; avoid unnecessary <code>new Integer(...)</code> to benefit from caching and lower memory.</li>
    <li>Use primitives in performance-critical code; use wrappers when objects are required.</li>
    <li>Always guard against <code>null</code> when auto-unboxing values that might be null.</li>
    <li>Use <code>parseXxx</code> when you need primitives; use <code>valueOf</code> when you want wrapper objects.</li>
    <li>Use <code>equals()</code> to compare wrapper values instead of <code>==</code>.</li>
  </ul>

  <div class="highlight">
    <strong>Summary:</strong>
    Wrapper classes make primitives behave like objects (required for collections and many APIs). Autoboxing/unboxing (since Java 5) makes conversions convenient, but be aware of performance costs, caching behavior, and null-related pitfalls. Use parsing methods carefully (they throw <code>NumberFormatException</code> on bad input).
  </div>
</div>

<hr>

<div class="section">
  <h1>🧩 Java Collection Framework (Overview)</h1>

  <h2>What is a Framework?</h2>
  <p>
    A <strong>framework</strong> is a ready-made architecture — a set of interfaces and classes that provide common functionality so you don't build everything from scratch.
    The <strong>Java Collections Framework</strong> (sometimes called the Collection API or collection hierarchy) gives reusable data structures and algorithms for storing and manipulating groups of objects.
  </p>

  <h2>What is a Collection?</h2>
  <p>
    A <strong>collection</strong> represents a group of related objects treated as a single unit (for example, a list of users). Collections provide convenient methods to add, remove, search and iterate elements.
  </p>

  <h2>Why use the Collection Framework?</h2>
  <ul>
    <li>Arrays are <strong>fixed-size</strong> and require manual resizing; collections are dynamic and grow as needed.</li>
    <li>Arrays require more boilerplate for common ops (insert, delete, search); collections provide ready methods (<code>add</code>, <code>remove</code>, <code>contains</code>, <code>sort</code>, etc.).</li>
    <li>Collections integrate with Java generics and iterators, improving type-safety and traversal.</li>
    <li>Different implementations offer different performance/ordering characteristics — pick one to suit your use-case (fast lookup, ordered iteration, sorted, concurrent, etc.).</li>
    <li>Collection utilities (class <code>Collections</code>) provide algorithms like <code>sort</code>, <code>binarySearch</code>, <code>synchronizedXxx</code>, <code>unmodifiableXxx</code>.</li>
  </ul>

  <h2>Where it lives</h2>
  <p>The core interfaces and classes are in <code>java.util</code>.</p>

  <h2>High-level Hierarchy (visual)</h2>
  <pre>
           Iterable
              |
           Collection
          /    |     \
        List   Set   Queue
       / | \   / \    /  \
   ArrayList Linked HashSet PriorityQueue
     Vector       TreeSet   ArrayDeque
           (Map is separate, not a Collection)
  Map
   ├─ HashMap
   ├─ LinkedHashMap
   ├─ TreeMap (Sorted)
   └─ Hashtable (legacy, synchronized)
  </pre>

  <h2>Key Interfaces & Characteristics</h2>

  <h3>List</h3>
  <ul>
    <li>Ordered sequence of elements, indexed access (<code>get(index)</code>), allows duplicates.</li>
    <li>Common implementations: <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code> (legacy).</li>
    <li>Typical uses: dynamic arrays, when you need random access or maintain insertion order.</li>
    <li>Small example: <code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></li>
  </ul>

  <h3>Set</h3>
  <ul>
    <li>No duplicate elements.</li>
    <li>Common implementations: <code>HashSet</code> (unordered), <code>LinkedHashSet</code> (insertion order), <code>TreeSet</code> (sorted).</li>
    <li>Use when uniqueness matters (e.g., distinct IDs).</li>
    <li>Small example: <code>Set&lt;String&gt; s = new HashSet&lt;&gt;();</code></li>
  </ul>

  <h3>Queue</h3>
  <ul>
    <li>Designed for holding elements prior to processing. Often FIFO, but semantics depend on implementation.</li>
    <li>Implementations: <code>PriorityQueue</code> (priority-based), <code>ArrayDeque</code> (double-ended), <code>LinkedList</code> (can act as queue/deque).</li>
    <li>Use for task scheduling, breadth-first search, producer-consumer buffers.</li>
    <li>Small example: <code>Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();</code></li>
  </ul>

  <h3>Map (not a Collection)</h3>
  <ul>
    <li>Key → Value pairs. Keys are unique, values may repeat.</li>
    <li>Implementations: <code>HashMap</code> (fast, allows one null key), <code>LinkedHashMap</code> (insertion order), <code>TreeMap</code> (sorted by key), <code>Hashtable</code> (legacy, synchronized).</li>
    <li>Use when you need lookup by key (dictionaries, caches).</li>
    <li>Small example: <code>Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();</code></li>
  </ul>

  <h2>Important behavioral notes</h2>
  <ul>
    <li><strong>Null handling:</strong> <code>HashMap</code> and <code>HashSet</code> allow <code>null</code> (HashMap allows one null key); <code>TreeMap</code>/ <code>TreeSet</code> generally disallow null keys if natural ordering is used.</li>
    <li><strong>Ordering:</strong> ArrayList & LinkedList preserve insertion order; HashSet/HashMap do not (LinkedHash* do); Tree* maintain sorted order.</li>
    <li><strong>Duplicates:</strong> Lists allow duplicates; Sets do not; Map keys are unique.</li>
    <li><strong>Thread-safety:</strong> <code>Vector</code> and <code>Hashtable</code> are synchronized (legacy). Prefer modern concurrent collections like <code>ConcurrentHashMap</code> or wrapper methods: <code>Collections.synchronizedList(...)</code> when needed.</li>
    <li><strong>Generics:</strong> Collections are generic (e.g., <code>List&lt;String&gt;</code>) — use generics to avoid casts and get compile-time type safety.</li>
  </ul>

  <h2>Performance Cheatsheet (common cases)</h2>
  <table>
    <tr><th>Structure</th><th>Typical ops</th><th>Avg complexity</th></tr>
    <tr><td>ArrayList</td><td>get(index), add(end), remove(mid)</td><td>get O(1), add amortized O(1), remove O(n)</td></tr>
    <tr><td>LinkedList</td><td>add/remove ends, get(index)</td><td>add/remove at ends O(1), get O(n)</td></tr>
    <tr><td>HashMap / HashSet</td><td>put / get / contains</td><td>average O(1), worst O(n)</td></tr>
    <tr><td>TreeMap / TreeSet</td><td>sorted ops, range queries</td><td>O(log n)</td></tr>
    <tr><td>PriorityQueue</td><td>offer / poll (min/max)</td><td>O(log n)</td></tr>
    <tr><td>ArrayDeque</td><td>push / pop / offer / poll</td><td>O(1)</td></tr>
  </table>

  <h2>Useful utilities & tips</h2>
  <ul>
    <li>Use <code>Collections</code> for algorithms: <code>Collections.sort(list)</code>, <code>Collections.binarySearch(list, key)</code>, <code>Collections.reverse(list)</code>.</li>
    <li>To get a thread-safe view: <code>List&lt;T&gt; sync = Collections.synchronizedList(new ArrayList&lt;&gt;());</code></li>
    <li>To make unmodifiable collections: <code>Collections.unmodifiableList(list)</code>.</li>
    <li>Prefer coding to interfaces: <code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> so you can swap implementations easily.</li>
    <li>Pick the implementation by behavior & complexity you need (fast random access → <code>ArrayList</code>; frequent insert/removal at ends → <code>LinkedList</code>; unique elements → <code>HashSet</code>; sorted → <code>TreeSet</code>).</li>
  </ul>

  <div class="highlight">
    <strong>Summary:</strong>
    The Collection Framework is a standardized set of interfaces and implementations for handling groups of objects. Choose List/Set/Queue/Map and their concrete classes according to ordering, duplication rules, and performance needs. Use generics, prefer interface types, and use utility methods from <code>Collections</code> to simplify common tasks.
  </div>
</div>

<hr>

<h1>Java <code>List</code> Interface and Implementations</h1>

<div class="section" id="list-interface">
  <h2>1️⃣ List Interface</h2>

  <h3>Definition</h3>
  <p>
    The <code>List</code> interface in Java is part of the <code>java.util</code> package and extends the <code>Collection</code> interface.
    It represents an <strong>ordered collection of elements</strong> where the <strong>order of insertion is preserved</strong> and <strong>duplicates are allowed</strong>.
    It provides methods to access elements by their index, iterate through them, and perform positional insertions or deletions.
  </p>

  <h3>Syntax</h3>
  <pre><code>List&lt;Type&gt; listName = new ArrayList&lt;&gt;();</code></pre>
  <p>Here:</p>
  <ul>
    <li><code>Type</code> is the element type (e.g., <code>Integer</code>, <code>String</code>, or custom objects).</li>
    <li>The actual object created can be <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>, etc.</li>
  </ul>

  <h3>Characteristics</h3>
  <ol>
    <li><strong>Ordered</strong> – Elements are stored and accessed in the exact order they were inserted.</li>
    <li><strong>Index-based Access</strong> – Each element can be accessed via an integer index (starting from 0).</li>
    <li><strong>Allows Duplicates</strong> – Multiple occurrences of the same value are allowed.</li>
    <li><strong>Allows Nulls</strong> – <code>null</code> values can be stored as elements (some implementations may allow multiple nulls, some only one).</li>
    <li><strong>Resizable</strong> – Most implementations grow dynamically as elements are added.</li>
  </ol>

  <h3>Advantages</h3>
  <ul>
    <li>Maintains <strong>predictable iteration order</strong>.</li>
    <li>Flexible choice of underlying data structure (ArrayList, LinkedList, etc.).</li>
    <li>Supports both <strong>random access</strong> and <strong>sequential access</strong> depending on implementation.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Not inherently thread-safe (unless using a synchronized implementation like <code>Vector</code> or <code>CopyOnWriteArrayList</code>).</li>
    <li>Performance may degrade depending on choice of implementation for specific operations.</li>
  </ul>

  <h3>When to Use</h3>
  <ul>
    <li>When <strong>ordering matters</strong> (e.g., task sequences, history logs).</li>
    <li>When <strong>duplicates are required</strong>.</li>
    <li>When <strong>indexed access</strong> is important.</li>
  </ul>

  <h3>When Not to Use</h3>
  <ul>
    <li>If <strong>uniqueness of elements</strong> is required → use <code>Set</code>.</li>
    <li>If performance is critical and a specialized collection is better (e.g., <code>Queue</code> for FIFO, <code>Map</code> for key-value).</li>
  </ul>

  <h3>Capacity</h3>
  <p><code>List</code> itself has no fixed capacity — it depends on the implementation.</p>

  <h3>Underlying Data Structure</h3>
  <ul>
    <li><code>ArrayList</code> → Dynamic Array</li>
    <li><code>LinkedList</code> → Doubly Linked List</li>
    <li><code>Vector</code> / <code>Stack</code> → Dynamic Array</li>
  </ul>
</div>

<hr />

<div class="section" id="arraylist">
  <h2>2️⃣ ArrayList</h2>

  <h3>Definition</h3>
  <p>
    <code>ArrayList</code> is a <strong>resizable array implementation</strong> of the <code>List</code> interface.
    It stores elements in a <strong>contiguous memory block</strong> and automatically grows when capacity is exceeded.
  </p>

  <h3>Syntax</h3>
  <pre><code>ArrayList&lt;Type&gt; list = new ArrayList&lt;&gt;();
ArrayList&lt;Type&gt; listWithCapacity = new ArrayList&lt;&gt;(initialCapacity);</code></pre>

  <h3>Characteristics</h3>
  <ol>
    <li><strong>Random Access</strong> – O(1) time complexity for getting/setting elements.</li>
    <li><strong>Resizable</strong> – Automatically increases capacity when full.</li>
    <li><strong>Insertion at End is Fast</strong> – O(1) amortized.</li>
    <li><strong>Insertion/Removal in Middle is Slow</strong> – O(n) due to shifting elements.</li>
    <li><strong>Allows Duplicates and Nulls</strong>.</li>
  </ol>

  <h3>Advantages</h3>
  <ul>
    <li>Excellent for <strong>read-heavy</strong> operations.</li>
    <li>Predictable iteration order.</li>
    <li>Easy to convert to array and back.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Insertion/removal in the middle is costly.</li>
    <li>Capacity increases cause <strong>reallocation and copying</strong>, which can be expensive for very large lists.</li>
  </ul>

  <h3>When to Use</h3>
  <ul>
    <li>When you need <strong>fast random reads</strong>.</li>
    <li>When insertions/removals are mostly at the <strong>end</strong>.</li>
  </ul>

  <h3>When Not to Use</h3>
  <ul>
    <li>When frequent middle insertions/removals occur → use <code>LinkedList</code>.</li>
  </ul>

  <h3>Capacity Details</h3>
  <ul>
    <li><strong>Default Initial Capacity:</strong> 10</li>
    <li><strong>Growth Formula:</strong> <code>(oldCapacity * 3/2) + 1</code><br />
    Example: 10 → 16 → 25 → 38, etc.</li>
  </ul>

  <h3>Underlying Data Structure</h3>
  <p><strong>Dynamic Array</strong></p>
</div>

<hr />

<div class="section" id="linkedlist">
  <h2>3️⃣ LinkedList</h2>

  <h3>Definition</h3>
  <p>
    <code>LinkedList</code> is a <strong>doubly linked list implementation</strong> of both <code>List</code> and <code>Deque</code>.
    It stores elements in nodes, each containing data plus pointers to the previous and next node.
  </p>

  <h3>Syntax</h3>
  <pre><code>LinkedList&lt;Type&gt; list = new LinkedList&lt;&gt;();</code></pre>

  <h3>Characteristics</h3>
  <ol>
    <li><strong>No Capacity Limit</strong> – Grows until memory is exhausted.</li>
    <li><strong>Efficient Insert/Remove</strong> – O(1) when you already have a reference to the node.</li>
    <li><strong>Slow Random Access</strong> – O(n) since traversal is required.</li>
    <li><strong>Can be Used as Queue/Deque</strong> – Implements <code>Deque</code> interface.</li>
  </ol>

  <h3>Advantages</h3>
  <ul>
    <li>Fast insertion and deletion anywhere in the list.</li>
    <li>No shifting of elements needed.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Uses extra memory for pointers.</li>
    <li>Slower to access elements by index.</li>
  </ul>

  <h3>When to Use</h3>
  <ul>
    <li>When insertion/removal is frequent, especially in the middle.</li>
    <li>As a <code>Queue</code> or <code>Deque</code>.</li>
  </ul>

  <h3>When Not to Use</h3>
  <ul>
    <li>When you need a lot of random access by index.</li>
  </ul>

  <h3>Capacity</h3>
  <p>Not applicable (linked structure).</p>

  <h3>Underlying Data Structure</h3>
  <p><strong>Doubly Linked List</strong></p>
</div>

<hr />

<div class="section" id="stack">
  <h2>4️⃣ Stack</h2>

  <h3>Definition</h3>
  <p>
    <code>Stack</code> is a <strong>LIFO (Last-In-First-Out)</strong> collection that extends <code>Vector</code>.
    It is synchronized and supports <code>push()</code>, <code>pop()</code>, and <code>peek()</code>.
  </p>

  <h3>Syntax</h3>
  <pre><code>Stack&lt;Type&gt; stack = new Stack&lt;&gt;();</code></pre>

  <h3>Characteristics</h3>
  <ol>
    <li><strong>Thread-Safe</strong> due to synchronization.</li>
    <li>Allows duplicates and nulls.</li>
    <li>Uses dynamic array internally.</li>
  </ol>

  <h3>Advantages</h3>
  <ul>
    <li>Simple for LIFO use cases.</li>
    <li>Thread-safe without external synchronization.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Slower due to synchronization.</li>
    <li><code>ArrayDeque</code> is faster in single-threaded stacks.</li>
  </ul>

  <h3>When to Use</h3>
  <ul>
    <li>Undo/Redo operations, expression parsing, backtracking.</li>
  </ul>

  <h3>When Not to Use</h3>
  <ul>
    <li>High-performance applications → prefer <code>ArrayDeque</code>.</li>
  </ul>

  <h3>Capacity</h3>
  <p>Same as <code>Vector</code> (starts at 10, doubles when full).</p>

  <h3>Underlying Data Structure</h3>
  <p><strong>Dynamic Array</strong></p>
</div>

<hr />

<div class="section" id="vector">
  <h2>5️⃣ Vector</h2>

  <h3>Definition</h3>
  <p>
    <code>Vector</code> is a <strong>synchronized dynamic array</strong> that implements <code>List</code>.
  </p>

  <h3>Syntax</h3>
  <pre><code>Vector&lt;Type&gt; vector = new Vector&lt;&gt;();
Vector&lt;Type&gt; vectorWithCapacity = new Vector&lt;&gt;(initialCapacity);</code></pre>

  <h3>Characteristics</h3>
  <ol>
    <li><strong>Thread-Safe</strong> – All methods synchronized.</li>
    <li>Allows nulls and duplicates.</li>
    <li>Random Access – O(1) for get/set.</li>
  </ol>

  <h3>Advantages</h3>
  <ul>
    <li>Safe for concurrent access.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Slower in single-threaded applications.</li>
  </ul>

  <h3>When to Use</h3>
  <ul>
    <li>Multi-threaded contexts needing a List.</li>
  </ul>

  <h3>When Not to Use</h3>
  <ul>
    <li>Single-threaded → use <code>ArrayList</code>.</li>
  </ul>

  <h3>Capacity</h3>
  <ul>
    <li><strong>Default Initial Capacity:</strong> 10</li>
    <li><strong>Growth:</strong> Doubles when full.</li>
  </ul>

  <h3>Underlying Data Structure</h3>
  <p><strong>Dynamic Array</strong></p>
</div>

<hr />

  <h1>Java Collections: List Interface and Implementations</h1>

  <h2>1. <code>List</code> Interface (java.util.List) — Common Methods</h2>

  <p>
    The <code>List</code> interface is the root interface for ordered collections in Java.
    These methods are implemented by <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code>, and <code>Stack</code>.
  </p>

  <table>
    <thead>
      <tr>
        <th>Method</th>
        <th>Return Type</th>
        <th>Purpose</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr><td><code>add(E e)</code></td><td><code>boolean</code></td><td>Appends element to end of list.</td><td><code>list.add("Apple");</code></td></tr>
      <tr><td><code>add(int index, E element)</code></td><td><code>void</code></td><td>Inserts element at given index.</td><td><code>list.add(1, "Banana");</code></td></tr>
      <tr><td><code>addAll(Collection&lt;? extends E&gt; c)</code></td><td><code>boolean</code></td><td>Appends all elements from given collection.</td><td><code>list.addAll(Arrays.asList("A", "B"));</code></td></tr>
      <tr><td><code>addAll(int index, Collection&lt;? extends E&gt; c)</code></td><td><code>boolean</code></td><td>Inserts all elements at given index.</td><td><code>list.addAll(1, Arrays.asList("X", "Y"));</code></td></tr>
      <tr><td><code>clear()</code></td><td><code>void</code></td><td>Removes all elements.</td><td><code>list.clear();</code></td></tr>
      <tr><td><code>contains(Object o)</code></td><td><code>boolean</code></td><td>Checks if list contains the element.</td><td><code>list.contains("Apple");</code></td></tr>
      <tr><td><code>containsAll(Collection&lt;?&gt; c)</code></td><td><code>boolean</code></td><td>Checks if list contains all elements in given collection.</td><td><code>list.containsAll(Arrays.asList("A", "B"));</code></td></tr>
      <tr><td><code>equals(Object o)</code></td><td><code>boolean</code></td><td>Compares lists for equality.</td><td><code>list1.equals(list2);</code></td></tr>
      <tr><td><code>get(int index)</code></td><td><code>E</code></td><td>Returns element at index.</td><td><code>list.get(2);</code></td></tr>
      <tr><td><code>indexOf(Object o)</code></td><td><code>int</code></td><td>Returns first occurrence index or -1.</td><td><code>list.indexOf("Banana");</code></td></tr>
      <tr><td><code>isEmpty()</code></td><td><code>boolean</code></td><td>Checks if list is empty.</td><td><code>list.isEmpty();</code></td></tr>
      <tr><td><code>iterator()</code></td><td><code>Iterator&lt;E&gt;</code></td><td>Returns iterator for elements.</td><td><code>Iterator&lt;String&gt; it = list.iterator();</code></td></tr>
      <tr><td><code>lastIndexOf(Object o)</code></td><td><code>int</code></td><td>Returns last occurrence index.</td><td><code>list.lastIndexOf("Banana");</code></td></tr>
      <tr><td><code>listIterator()</code></td><td><code>ListIterator&lt;E&gt;</code></td><td>Returns bidirectional list iterator.</td><td><code>ListIterator&lt;String&gt; li = list.listIterator();</code></td></tr>
      <tr><td><code>listIterator(int index)</code></td><td><code>ListIterator&lt;E&gt;</code></td><td>Returns list iterator starting at index.</td><td><code>list.listIterator(2);</code></td></tr>
      <tr><td><code>remove(Object o)</code></td><td><code>boolean</code></td><td>Removes first occurrence of element.</td><td><code>list.remove("Apple");</code></td></tr>
      <tr><td><code>remove(int index)</code></td><td><code>E</code></td><td>Removes element at index.</td><td><code>list.remove(1);</code></td></tr>
      <tr><td><code>removeAll(Collection&lt;?&gt; c)</code></td><td><code>boolean</code></td><td>Removes all elements in given collection.</td><td><code>list.removeAll(Arrays.asList("A", "B"));</code></td></tr>
      <tr><td><code>retainAll(Collection&lt;?&gt; c)</code></td><td><code>boolean</code></td><td>Keeps only elements in given collection.</td><td><code>list.retainAll(Arrays.asList("A", "B"));</code></td></tr>
      <tr><td><code>replaceAll(UnaryOperator&lt;E&gt; op)</code></td><td><code>void</code></td><td>Replaces each element with function result.</td><td><code>list.replaceAll(s -&gt; s.toUpperCase());</code></td></tr>
      <tr><td><code>set(int index, E element)</code></td><td><code>E</code></td><td>Replaces element at index.</td><td><code>list.set(1, "Kiwi");</code></td></tr>
      <tr><td><code>size()</code></td><td><code>int</code></td><td>Returns number of elements.</td><td><code>list.size();</code></td></tr>
      <tr><td><code>sort(Comparator&lt;? super E&gt; c)</code></td><td><code>void</code></td><td>Sorts list using comparator.</td><td><code>list.sort(String::compareTo);</code></td></tr>
      <tr><td><code>spliterator()</code></td><td><code>Spliterator&lt;E&gt;</code></td><td>Returns spliterator for parallel iteration.</td><td><code>Spliterator&lt;String&gt; sp = list.spliterator();</code></td></tr>
      <tr><td><code>subList(int from, int to)</code></td><td><code>List&lt;E&gt;</code></td><td>Returns portion of list.</td><td><code>list.subList(1, 3);</code></td></tr>
      <tr><td><code>toArray()</code></td><td><code>Object[]</code></td><td>Returns array of elements.</td><td><code>Object[] arr = list.toArray();</code></td></tr>
      <tr><td><code>toArray(T[] a)</code></td><td><code>&lt;T&gt; T[]</code></td><td>Returns array of given type.</td><td><code>String[] arr = list.toArray(new String[0]);</code></td></tr>
    </tbody>
  </table>

  <h2>2. <code>ArrayList</code> — Extra Methods</h2>

  <table>
    <thead>
      <tr>
        <th>Method</th>
        <th>Return Type</th>
        <th>Purpose</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr><td><code>ensureCapacity(int minCapacity)</code></td><td><code>void</code></td><td>Ensures internal capacity.</td><td><code>((ArrayList&lt;String&gt;) list).ensureCapacity(50);</code></td></tr>
      <tr><td><code>trimToSize()</code></td><td><code>void</code></td><td>Shrinks storage to current size.</td><td><code>((ArrayList&lt;String&gt;) list).trimToSize();</code></td></tr>
      <tr><td><code>clone()</code></td><td><code>Object</code></td><td>Returns a shallow copy.</td><td><code>ArrayList&lt;String&gt; copy = (ArrayList&lt;String&gt;) list.clone();</code></td></tr>
    </tbody>
  </table>

  <h2>3. <code>LinkedList</code> — Extra Methods</h2>

  <table>
    <thead>
      <tr>
        <th>Method</th>
        <th>Return Type</th>
        <th>Purpose</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr><td><code>addFirst(E e)</code></td><td><code>void</code></td><td>Inserts at beginning.</td><td><code>linkedList.addFirst("First");</code></td></tr>
      <tr><td><code>addLast(E e)</code></td><td><code>void</code></td><td>Inserts at end.</td><td><code>linkedList.addLast("Last");</code></td></tr>
      <tr><td><code>offerFirst(E e)</code></td><td><code>boolean</code></td><td>Offers element at beginning.</td><td><code>linkedList.offerFirst("First");</code></td></tr>
      <tr><td><code>offerLast(E e)</code></td><td><code>boolean</code></td><td>Offers element at end.</td><td><code>linkedList.offerLast("Last");</code></td></tr>
      <tr><td><code>getFirst()</code></td><td><code>E</code></td><td>Retrieves first element.</td><td><code>linkedList.getFirst();</code></td></tr>
      <tr><td><code>getLast()</code></td><td><code>E</code></td><td>Retrieves last element.</td><td><code>linkedList.getLast();</code></td></tr>
      <tr><td><code>peekFirst()</code></td><td><code>E</code></td><td>Retrieves first element, null if empty.</td><td><code>linkedList.peekFirst();</code></td></tr>
      <tr><td><code>peekLast()</code></td><td><code>E</code></td><td>Retrieves last element, null if empty.</td><td><code>linkedList.peekLast();</code></td></tr>
      <tr><td><code>removeFirst()</code></td><td><code>E</code></td><td>Removes first element.</td><td><code>linkedList.removeFirst();</code></td></tr>
      <tr><td><code>removeLast()</code></td><td><code>E</code></td><td>Removes last element.</td><td><code>linkedList.removeLast();</code></td></tr>
      <tr><td><code>pollFirst()</code></td><td><code>E</code></td><td>Removes first element, null if empty.</td><td><code>linkedList.pollFirst();</code></td></tr>
      <tr><td><code>pollLast()</code></td><td><code>E</code></td><td>Removes last element, null if empty.</td><td><code>linkedList.pollLast();</code></td></tr>
      <tr><td><code>push(E e)</code></td><td><code>void</code></td><td>Pushes to front (stack).</td><td><code>linkedList.push("Top");</code></td></tr>
      <tr><td><code>pop()</code></td><td><code>E</code></td><td>Pops from front (stack).</td><td><code>linkedList.pop();</code></td></tr>
    </tbody>
  </table>

  <h2>4. <code>Vector</code> — Extra Methods</h2>

  <table>
    <thead>
      <tr>
        <th>Method</th>
        <th>Return Type</th>
        <th>Purpose</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr><td><code>capacity()</code></td><td><code>int</code></td><td>Returns capacity.</td><td><code>vector.capacity();</code></td></tr>
      <tr><td><code>copyInto(Object[] anArray)</code></td><td><code>void</code></td><td>Copies elements into array.</td><td><code>vector.copyInto(arr);</code></td></tr>
      <tr><td><code>elementAt(int index)</code></td><td><code>E</code></td><td>Gets element at index.</td><td><code>vector.elementAt(2);</code></td></tr>
      <tr><td><code>firstElement()</code></td><td><code>E</code></td><td>Gets first element.</td><td><code>vector.firstElement();</code></td></tr>
      <tr><td><code>lastElement()</code></td><td><code>E</code></td><td>Gets last element.</td><td><code>vector.lastElement();</code></td></tr>
      <tr><td><code>removeAllElements()</code></td><td><code>void</code></td><td>Clears vector.</td><td><code>vector.removeAllElements();</code></td></tr>
      <tr><td><code>setElementAt(E obj, int index)</code></td><td><code>void</code></td><td>Sets element at index.</td><td><code>vector.setElementAt("X", 2);</code></td></tr>
      <tr><td><code>insertElementAt(E obj, int index)</code></td><td><code>void</code></td><td>Inserts at index.</td><td><code>vector.insertElementAt("X", 1);</code></td></tr>
      <tr><td><code>addElement(E obj)</code></td><td><code>void</code></td><td>Adds at end.</td><td><code>vector.addElement("New");</code></td></tr>
      <tr><td><code>removeElementAt(int index)</code></td><td><code>void</code></td><td>Removes at index.</td><td><code>vector.removeElementAt(1);</code></td></tr>
      <tr><td><code>removeElement(Object obj)</code></td><td><code>boolean</code></td><td>Removes first occurrence.</td><td><code>vector.removeElement("A");</code></td></tr>
      <tr><td><code>trimToSize()</code></td><td><code>void</code></td><td>Shrinks capacity to size.</td><td><code>vector.trimToSize();</code></td></tr>
      <tr><td><code>ensureCapacity(int minCapacity)</code></td><td><code>void</code></td><td>Ensures capacity.</td><td><code>vector.ensureCapacity(50);</code></td></tr>
      <tr><td><code>setSize(int newSize)</code></td><td><code>void</code></td><td>Changes size.</td><td><code>vector.setSize(10);</code></td></tr>
</tbody>
  </table>

<h2>5. <code>Stack</code> — Extra Methods</h2>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Return Type</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>push(E item)</code></td><td><code>E</code></td><td>Pushes onto stack.</td><td><code>stack.push("A");</code></td></tr>
    <tr><td><code>pop()</code></td><td><code>E</code></td><td>Removes top element.</td><td><code>stack.pop();</code></td></tr>
    <tr><td><code>peek()</code></td><td><code>E</code></td><td>Looks at top element.</td><td><code>stack.peek();</code></td></tr>
    <tr><td><code>empty()</code></td><td><code>boolean</code></td><td>Checks if stack is empty.</td><td><code>stack.empty();</code></td></tr>
    <tr><td><code>search(Object o)</code></td><td><code>int</code></td><td>1-based position from top.</td><td><code>stack.search("A");</code></td></tr>
  </tbody>
</table>

<hr/>

<h2><code>Iterator</code> Methods</h2>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>boolean hasNext()</code></td><td>Checks if more elements exist.</td></tr>
    <tr><td><code>E next()</code></td><td>Returns the next element.</td></tr>
    <tr><td><code>void remove()</code></td><td>Removes the last returned element (optional).</td></tr>
    <tr><td><code>default void forEachRemaining(Consumer)</code></td><td>Applies action to remaining elements (Java 8+).</td></tr>
  </tbody>
</table>

<hr/>

<h2><code>ListIterator</code> Methods</h2>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>boolean hasNext()</code></td><td>Check forward elements.</td></tr>
    <tr><td><code>E next()</code></td><td>Get next element.</td></tr>
    <tr><td><code>boolean hasPrevious()</code></td><td>Check backward elements.</td></tr>
    <tr><td><code>E previous()</code></td><td>Get previous element.</td></tr>
    <tr><td><code>int nextIndex()</code></td><td>Index of next element.</td></tr>
    <tr><td><code>int previousIndex()</code></td><td>Index of previous element.</td></tr>
    <tr><td><code>void remove()</code></td><td>Removes current element.</td></tr>
    <tr><td><code>void set(E e)</code></td><td>Replaces last element returned.</td></tr>
    <tr><td><code>void add(E e)</code></td><td>Inserts an element.</td></tr>
  </tbody>
</table>

<hr/>

<h2>Explanation: <code>Iterator</code> and <code>ListIterator</code></h2>

<p>
  Both <code>Iterator</code> and <code>ListIterator</code> are interfaces in Java's Collections Framework used to traverse collections, but they differ in capabilities and use cases.
</p>

<h3><code>Iterator</code></h3>
<p>
  An <code>Iterator</code> provides a simple way to traverse a collection sequentially in the forward direction only.
</p>
<ul>
  <li><strong>Key Methods:</strong> <code>hasNext()</code>, <code>next()</code>, <code>remove()</code>, and <code>forEachRemaining()</code> (Java 8+)</li>
  <li><strong>Usage:</strong> Mainly used to iterate over collections like <code>List</code>, <code>Set</code>, and <code>Queue</code>.</li>
  <li><strong>Advantages:</strong>
    <ul>
      <li>Simplifies element traversal without exposing internal structure.</li>
      <li>Supports safe removal of elements during iteration (<code>remove()</code> method).</li>
      <li>Works with any collection implementing <code>Iterable</code>.</li>
    </ul>
  </li>
  <li><strong>Limitations:</strong>
    <ul>
      <li>Can only move forward through the collection.</li>
      <li>No ability to add or replace elements during iteration.</li>
      <li>Does not provide index information.</li>
    </ul>
  </li>
</ul>

<h3><code>ListIterator</code></h3>
<p>
  <code>ListIterator</code> extends <code>Iterator</code> and is specifically designed for use with <code>List</code> implementations.
</p>
<ul>
  <li><strong>Key Methods:</strong> Includes all <code>Iterator</code> methods plus <code>hasPrevious()</code>, <code>previous()</code>, <code>nextIndex()</code>, <code>previousIndex()</code>, <code>set(E e)</code>, and <code>add(E e)</code>.</li>
  <li><strong>Usage:</strong> Allows bi-directional traversal (forward and backward) of lists.</li>
  <li><strong>Advantages:</strong>
    <ul>
      <li>Traverse lists both forwards and backwards.</li>
      <li>Can modify the list during iteration with <code>set()</code> and <code>add()</code>.</li>
      <li>Provides positional information via <code>nextIndex()</code> and <code>previousIndex()</code>.</li>
    </ul>
  </li>
  <li><strong>Limitations:</strong>
    <ul>
      <li>Only applicable to List implementations (not general collections).</li>
      <li>More complex interface compared to Iterator.</li>
    </ul>
  </li>
</ul>

<h3>Use Cases</h3>
<ul>
  <li><strong>Iterator:</strong> Best when you need simple forward traversal and optional safe removal of elements (e.g., looping over a <code>Set</code> or <code>List</code> when no modification except removal is needed).</li>
  <li><strong>ListIterator:</strong> Ideal when you need to traverse a list in both directions, or modify elements during iteration (e.g., editing or inserting elements while looping through a <code>LinkedList</code> or <code>ArrayList</code>).</li>
</ul>

<h3>Summary</h3>
<p>
  - Use <code>Iterator</code> for basic forward-only iteration and safe element removal.<br/>
  - Use <code>ListIterator</code> for advanced bidirectional iteration and in-place list modifications.<br/>
</p>

<hr>

<h1>Java <code>Set</code> Interface and Implementations</h1>

<h3>1️⃣ Set Interface</h3>

<h4>Definition</h4>
<p>
  The <code>Set</code> interface in Java (from <code>java.util</code>) extends <code>Collection</code> and represents an <strong>unordered collection of unique elements</strong>.
  It <strong>does not allow duplicates</strong> and at most <strong>one null element</strong> (depending on implementation).
  Unlike <code>List</code>, <code>Set</code> does <strong>not preserve insertion order</strong> (except for ordered variants like <code>LinkedHashSet</code>).
</p>

<h4>Syntax</h4>
<pre><code>Set&lt;Type&gt; setName = new HashSet&lt;&gt;();</code></pre>
<p>Here:</p>
<ul>
  <li><code>Type</code> → Element type (e.g., <code>Integer</code>, <code>String</code>, custom object).</li>
  <li>Can be implemented by <code>HashSet</code>, <code>LinkedHashSet</code>, <code>TreeSet</code>, etc.</li>
</ul>

<h4>Characteristics</h4>
<ol>
  <li><strong>Uniqueness</strong> – No duplicate elements allowed.</li>
  <li><strong>Order</strong> – Not guaranteed (except in ordered variants).</li>
  <li><strong>Null Handling</strong> – Allows one null in most implementations.</li>
  <li><strong>Efficient Lookup</strong> – Implementations like <code>HashSet</code> provide near O(1) average time for search, insert, delete.</li>
  <li><strong>No Index Access</strong> – You cannot get elements by index like a <code>List</code>.</li>
</ol>

<h4>Advantages</h4>
<ul>
  <li>Prevents duplicates automatically.</li>
  <li>Fast searching and lookups (for hash-based sets).</li>
  <li>Good for membership tests (<code>contains()</code>).</li>
</ul>

<h4>Disadvantages</h4>
<ul>
  <li>No positional access.</li>
  <li>Unordered (unless using ordered variant).</li>
  <li>Slightly more memory overhead due to hashing or tree nodes.</li>
</ul>

<h4>When to Use</h4>
<ul>
  <li>When uniqueness is required.</li>
  <li>For <strong>fast lookups</strong> and membership checks.</li>
  <li>When you don’t care about order (use <code>HashSet</code>) or you need sorted order (<code>TreeSet</code>).</li>
</ul>

<h4>When Not to Use</h4>
<ul>
  <li>If you need duplicates → use <code>List</code>.</li>
  <li>If positional/indexed access is required.</li>
</ul>

<h4>Capacity</h4>
<p>Depends on implementation (e.g., <code>HashSet</code> default 16 buckets, load factor 0.75).</p>

<h4>Underlying Data Structure</h4>
<ul>
  <li><code>HashSet</code> → <strong>Hash table</strong></li>
  <li><code>LinkedHashSet</code> → <strong>Hash table + linked list</strong> (for order)</li>
  <li><code>TreeSet</code> → <strong>Red-Black tree</strong> (sorted)</li>
</ul>

<hr/>

<h3>2️⃣ HashSet</h3>

<h4>Definition</h4>
<p><code>HashSet</code> is an <strong>unordered collection</strong> that uses a <strong>hash table</strong> for storage and ensures <strong>unique elements</strong>.</p>

<h4>Syntax</h4>
<pre><code>HashSet&lt;Type&gt; set = new HashSet&lt;&gt;();
HashSet&lt;Type&gt; setWithCapacity = new HashSet&lt;&gt;(initialCapacity, loadFactor);</code></pre>

<h4>Characteristics</h4>
<ol>
  <li><strong>Unordered</strong> – No guarantee of iteration order.</li>
  <li>Allows one null.</li>
  <li><strong>O(1) average</strong> performance for add, remove, contains.</li>
  <li>Backed by <code>HashMap</code> internally (elements are keys, values are dummy objects).</li>
</ol>

<h4>Advantages</h4>
<ul>
  <li>Fast operations.</li>
  <li>Automatically handles duplicates.</li>
  <li>Good for large datasets where order doesn’t matter.</li>
</ul>

<h4>Disadvantages</h4>
<ul>
  <li>Unpredictable iteration order.</li>
  <li>Performance depends on good <code>hashCode()</code> implementation.</li>
</ul>

<h4>When to Use</h4>
<ul>
  <li>When you need <strong>fast, unique storage</strong>.</li>
</ul>

<h4>When Not to Use</h4>
<ul>
  <li>When order is important → use <code>LinkedHashSet</code> or <code>TreeSet</code>.</li>
</ul>

<h4>Capacity Growth</h4>
<ul>
  <li><strong>Default Initial Capacity:</strong> 16</li>
  <li><strong>Load Factor:</strong> 0.75 (resizes when 75% full)</li>
  <li><strong>Growth:</strong> Doubles capacity when resized.</li>
</ul>

<h4>Underlying Data Structure</h4>
<p><strong>Hash table</strong> (via <code>HashMap</code>).</p>

<hr/>

<h3>3️⃣ LinkedHashSet</h3>

<h4>Definition</h4>
<p><code>LinkedHashSet</code> is an <strong>ordered version of HashSet</strong> that maintains <strong>insertion order</strong> using a linked list along with the hash table.</p>

<h4>Syntax</h4>
<pre><code>LinkedHashSet&lt;Type&gt; set = new LinkedHashSet&lt;&gt;();</code></pre>

<h4>Characteristics</h4>
<ol>
  <li>Maintains Insertion Order.</li>
  <li>Slightly slower than <code>HashSet</code> due to linked list overhead.</li>
  <li>Allows one null.</li>
</ol>

<h4>Advantages</h4>
<ul>
  <li>Predictable iteration order.</li>
  <li>Still fast (close to O(1) operations).</li>
</ul>

<h4>Disadvantages</h4>
<ul>
  <li>Slightly more memory than <code>HashSet</code>.</li>
</ul>

<h4>When to Use</h4>
<ul>
  <li>When both uniqueness and <strong>insertion order</strong> matter.</li>
</ul>

<h4>Capacity</h4>
<p>Same as <code>HashSet</code>.</p>

<h4>Underlying Data Structure</h4>
<p><strong>Hash table + doubly linked list</strong>.</p>

<hr/>

<h3>4️⃣ TreeSet</h3>

<h4>Definition</h4>
<p><code>TreeSet</code> is a <strong>sorted</strong> implementation of the <code>Set</code> interface using a <strong>Red-Black tree</strong>.</p>

<h4>Syntax</h4>
<pre><code>TreeSet&lt;Type&gt; set = new TreeSet&lt;&gt;();
TreeSet&lt;Type&gt; customOrderSet = new TreeSet&lt;&gt;(Comparator.reverseOrder());</code></pre>

<h4>Characteristics</h4>
<ol>
  <li><strong>Sorted Order</strong> – Natural order or via custom comparator.</li>
  <li><strong>O(log n)</strong> performance for all operations.</li>
  <li><strong>No nulls allowed</strong> (throws <code>NullPointerException</code> if null is inserted).</li>
</ol>

<h4>Advantages</h4>
<ul>
  <li>Maintains sorted order automatically.</li>
  <li>Good for range queries (<code>subSet()</code>, <code>headSet()</code>, <code>tailSet()</code>).</li>
</ul>

<h4>Disadvantages</h4>
<ul>
  <li>Slower than <code>HashSet</code> for add/remove/contains.</li>
  <li>No null elements allowed.</li>
</ul>

<h4>When to Use</h4>
<ul>
  <li>When sorted order is required.</li>
</ul>

<h4>Capacity</h4>
<p>Not applicable (tree structure).</p>

<h4>Underlying Data Structure</h4>
<p><strong>Red-Black Tree</strong>.</p>

<hr/>

<h3>5️⃣ Other Set Implementations</h3>

<h4>EnumSet</h4>
<ul>
  <li>Special set for enums.</li>
  <li>Very fast and memory efficient (bit vector representation).</li>
  <li>No nulls allowed.</li>
</ul>

<h4>CopyOnWriteArraySet</h4>
<ul>
  <li>Thread-safe set backed by <code>CopyOnWriteArrayList</code>.</li>
  <li>Good for read-heavy concurrent applications.</li>
  <li>Slower writes (copying array on every modification).</li>
</ul>

<hr>

<h1>Java Collections: Set Interface and Implementations</h1>
<h2>1. <code>Set</code> Interface (<code>java.util.Set</code>) — Common Methods</h2>

<p>
  The <code>Set</code> interface is implemented by classes like <code>HashSet</code>, <code>LinkedHashSet</code>, and <code>TreeSet</code>.
  It represents a collection that contains no duplicate elements.
</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Return Type</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>add(E e)</code></td>
      <td><code>boolean</code></td>
      <td>Adds element if not already present. Returns <code>true</code> if added.</td>
      <td><code>set.add("Apple");</code></td>
    </tr>
    <tr>
      <td><code>addAll(Collection&lt;? extends E&gt; c)</code></td>
      <td><code>boolean</code></td>
      <td>Adds all elements from given collection (ignores duplicates).</td>
      <td><code>set.addAll(Arrays.asList("A", "B"));</code></td>
    </tr>
    <tr>
      <td><code>clear()</code></td>
      <td><code>void</code></td>
      <td>Removes all elements.</td>
      <td><code>set.clear();</code></td>
    </tr>
    <tr>
      <td><code>contains(Object o)</code></td>
      <td><code>boolean</code></td>
      <td>Checks if element exists.</td>
      <td><code>set.contains("Apple");</code></td>
    </tr>
    <tr>
      <td><code>containsAll(Collection&lt;?&gt; c)</code></td>
      <td><code>boolean</code></td>
      <td>Checks if all given elements exist.</td>
      <td><code>set.containsAll(Arrays.asList("A", "B"));</code></td>
    </tr>
    <tr>
      <td><code>equals(Object o)</code></td>
      <td><code>boolean</code></td>
      <td>Checks equality of sets.</td>
      <td><code>set1.equals(set2);</code></td>
    </tr>
    <tr>
      <td><code>hashCode()</code></td>
      <td><code>int</code></td>
      <td>Returns hash code for set.</td>
      <td><code>int code = set.hashCode();</code></td>
    </tr>
    <tr>
      <td><code>isEmpty()</code></td>
      <td><code>boolean</code></td>
      <td>Checks if empty.</td>
      <td><code>set.isEmpty();</code></td>
    </tr>
    <tr>
      <td><code>iterator()</code></td>
      <td><code>Iterator&lt;E&gt;</code></td>
      <td>Returns iterator over elements.</td>
      <td><code>Iterator&lt;String&gt; it = set.iterator();</code></td>
    </tr>
    <tr>
      <td><code>remove(Object o)</code></td>
      <td><code>boolean</code></td>
      <td>Removes element if present.</td>
      <td><code>set.remove("Apple");</code></td>
    </tr>
    <tr>
      <td><code>removeAll(Collection&lt;?&gt; c)</code></td>
      <td><code>boolean</code></td>
      <td>Removes all given elements.</td>
      <td><code>set.removeAll(Arrays.asList("A", "B"));</code></td>
    </tr>
    <tr>
      <td><code>retainAll(Collection&lt;?&gt; c)</code></td>
      <td><code>boolean</code></td>
      <td>Keeps only elements in given collection.</td>
      <td><code>set.retainAll(Arrays.asList("A", "B"));</code></td>
    </tr>
    <tr>
      <td><code>size()</code></td>
      <td><code>int</code></td>
      <td>Number of elements.</td>
      <td><code>set.size();</code></td>
    </tr>
    <tr>
      <td><code>spliterator()</code></td>
      <td><code>Spliterator&lt;E&gt;</code></td>
      <td>Returns spliterator for parallel iteration.</td>
      <td><code>Spliterator&lt;String&gt; sp = set.spliterator();</code></td>
    </tr>
    <tr>
      <td><code>toArray()</code></td>
      <td><code>Object[]</code></td>
      <td>Returns array of all elements.</td>
      <td><code>Object[] arr = set.toArray();</code></td>
    </tr>
    <tr>
      <td><code>toArray(T[] a)</code></td>
      <td><code>&lt;T&gt; T[]</code></td>
      <td>Returns array of given type.</td>
      <td><code>String[] arr = set.toArray(new String[0]);</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Explanation:</strong> These methods provide basic operations for managing unique collections of elements. Since <code>Set</code> doesn’t allow duplicates, the <code>add</code> method only adds an element if it is not already present. The <code>retainAll</code> method helps filter the set to only keep elements also present in the specified collection.</p>

<hr/>

<h2>2. <code>HashSet</code> — Extra Methods</h2>

<p><code>HashSet</code> inherits from <code>AbstractSet</code> and does not add extra public methods beyond constructors.</p>

<p><strong>Note:</strong> It uses a <strong>hash table</strong> internally (via <code>HashMap</code>) to provide fast add, remove, and lookup operations (~O(1) average).</p>

<hr/>

<h2>3. <code>LinkedHashSet</code> — Extra Methods</h2>

<p><code>LinkedHashSet</code> extends <code>HashSet</code> but maintains <strong>insertion order</strong> by using a linked list running through the hash table.</p>

<p>It does not add any extra public methods either, but preserves order when iterating over elements.</p>

<hr/>

<h2>4. <code>TreeSet</code> — Extra Methods</h2>

<p><code>TreeSet</code> implements <code>NavigableSet</code>, adding a rich set of navigation and sorted set operations.</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Return Type</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ceiling(E e)</code></td>
      <td><code>E</code></td>
      <td>Returns least element ≥ given element, or <code>null</code> if none.</td>
      <td><code>treeSet.ceiling("B");</code></td>
    </tr>
    <tr>
      <td><code>floor(E e)</code></td>
      <td><code>E</code></td>
      <td>Returns greatest element ≤ given element, or <code>null</code> if none.</td>
      <td><code>treeSet.floor("B");</code></td>
    </tr>
    <tr>
      <td><code>higher(E e)</code></td>
      <td><code>E</code></td>
      <td>Returns least element > given element.</td>
      <td><code>treeSet.higher("B");</code></td>
    </tr>
    <tr>
      <td><code>lower(E e)</code></td>
      <td><code>E</code></td>
      <td>Returns greatest element < given element.</td>
      <td><code>treeSet.lower("B");</code></td>
    </tr>
    <tr>
      <td><code>first()</code></td>
      <td><code>E</code></td>
      <td>Returns smallest element.</td>
      <td><code>treeSet.first();</code></td>
    </tr>
    <tr>
      <td><code>last()</code></td>
      <td><code>E</code></td>
      <td>Returns largest element.</td>
      <td><code>treeSet.last();</code></td>
    </tr>
    <tr>
      <td><code>headSet(E toElement)</code></td>
      <td><code>SortedSet&lt;E&gt;</code></td>
      <td>Returns all elements less than given element.</td>
      <td><code>treeSet.headSet("C");</code></td>
    </tr>
    <tr>
      <td><code>headSet(E toElement, boolean inclusive)</code></td>
      <td><code>NavigableSet&lt;E&gt;</code></td>
      <td>Returns elements ≤ given element if <code>inclusive</code> is true.</td>
      <td><code>treeSet.headSet("C", true);</code></td>
    </tr>
    <tr>
      <td><code>tailSet(E fromElement)</code></td>
      <td><code>SortedSet&lt;E&gt;</code></td>
      <td>Returns all elements ≥ given element.</td>
      <td><code>treeSet.tailSet("B");</code></td>
    </tr>
    <tr>
      <td><code>tailSet(E fromElement, boolean inclusive)</code></td>
      <td><code>NavigableSet&lt;E&gt;</code></td>
      <td>Returns elements ≥ given element, inclusive if true.</td>
      <td><code>treeSet.tailSet("B", false);</code></td>
    </tr>
    <tr>
      <td><code>subSet(E from, E to)</code></td>
      <td><code>SortedSet&lt;E&gt;</code></td>
      <td>Returns elements in range <code>[from, to)</code>.</td>
      <td><code>treeSet.subSet("A", "C");</code></td>
    </tr>
    <tr>
      <td><code>subSet(E from, boolean fromInclusive, E to, boolean toInclusive)</code></td>
      <td><code>NavigableSet&lt;E&gt;</code></td>
      <td>Returns range with custom bounds inclusivity.</td>
      <td><code>treeSet.subSet("A", true, "C", false);</code></td>
    </tr>
    <tr>
      <td><code>descendingSet()</code></td>
      <td><code>NavigableSet&lt;E&gt;</code></td>
      <td>Returns set in reverse order.</td>
      <td><code>treeSet.descendingSet();</code></td>
    </tr>
    <tr>
      <td><code>pollFirst()</code></td>
      <td><code>E</code></td>
      <td>Removes and returns first element.</td>
      <td><code>treeSet.pollFirst();</code></td>
    </tr>
    <tr>
      <td><code>pollLast()</code></td>
      <td><code>E</code></td>
      <td>Removes and returns last element.</td>
      <td><code>treeSet.pollLast();</code></td>
    </tr>
    <tr>
      <td><code>descendingIterator()</code></td>
      <td><code>Iterator&lt;E&gt;</code></td>
      <td>Returns iterator in reverse order.</td>
      <td><code>Iterator&lt;String&gt; it = treeSet.descendingIterator();</code></td>
    </tr>
    <tr>
      <td><code>comparator()</code></td>
      <td><code>Comparator&lt;? super E&gt;</code></td>
      <td>Returns comparator or <code>null</code> if natural ordering.</td>
      <td><code>treeSet.comparator();</code></td>
    </tr>
  </tbody>
</table>

<p><strong>Explanation:</strong> These methods allow powerful navigation of sorted elements, retrieval of subsets by range, and iteration in reverse order. For example, <code>ceiling()</code> finds the smallest element greater than or equal to the argument, useful for floor/ceiling operations in sorted sets.</p>

<hr/>

<h2>Summary and Notes</h2>

<ul>
  <li><strong>Set interface</strong> methods provide the standard operations for unique element collections.</li>
  <li><code>HashSet</code> and <code>LinkedHashSet</code> don’t add unique public methods beyond those inherited; they differ in iteration order.</li>
  <li><code>TreeSet</code> provides extensive navigation methods due to sorted order and implements <code>NavigableSet</code>.</li>
  <li>Always remember that <code>Set</code> disallows duplicates and offers no index-based access.</li>
  <li>Iteration order depends on implementation — unordered in <code>HashSet</code>, insertion order in <code>LinkedHashSet</code>, sorted order in <code>TreeSet</code>.</li>
</ul>

<hr>
<h1>Java <code>Queue</code> Interface and Implementations</h1>

<h2>1️⃣ Queue Interface</h2>

<h3>Definition</h3>
<p>
  The <code>Queue</code> interface in Java (<code>java.util</code>) represents a collection designed for holding elements prior to processing,
  typically following <strong>FIFO</strong> (First-In-First-Out) ordering.
  Some implementations modify the ordering, e.g., <code>PriorityQueue</code> orders elements by priority.
</p>

<h3>Syntax</h3>
<pre><code>Queue&lt;Type&gt; queueName = new LinkedList&lt;&gt;();
Queue&lt;Type&gt; queueName = new PriorityQueue&lt;&gt;();</code></pre>
<ul>
  <li><code>Type</code> → Element type (e.g., Integer, String, custom class).</li>
  <li>Implemented by classes like <code>LinkedList</code>, <code>PriorityQueue</code>, <code>ArrayDeque</code>, etc.</li>
</ul>

<h3>Characteristics</h3>
<ol>
  <li>Usually <strong>FIFO</strong>, but ordering depends on implementation.</li>
  <li>No indexed access — elements are retrieved in queue order.</li>
  <li>Supports methods like <code>offer()</code>, <code>poll()</code>, <code>peek()</code> in addition to <code>Collection</code> methods.</li>
  <li>May or may not allow <code>null</code> (depends on implementation).</li>
  <li>Performance depends on the underlying data structure.</li>
</ol>

<h3>Advantages</h3>
<ul>
  <li>Natural choice for task scheduling, buffering, and breadth-first algorithms.</li>
  <li>Built-in methods make queue operations expressive and clean.</li>
  <li>Supports both bounded and unbounded capacity implementations.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>No random access like <code>List</code>.</li>
  <li>Bounded queues’ <code>add()</code> may throw exceptions if full — use <code>offer()</code> for safe insertions.</li>
</ul>

<h3>When to Use</h3>
<ul>
  <li>Processing tasks in arrival order.</li>
  <li>Implementing <strong>producer-consumer</strong> patterns.</li>
  <li>Managing work pipelines or messaging systems.</li>
</ul>

<h3>When Not to Use</h3>
<ul>
  <li>If you need frequent random access — use a <code>List</code>.</li>
  <li>If sorting is the main requirement — use a <code>List</code> or <code>TreeSet</code>.</li>
</ul>

<h3>Capacity</h3>
<ul>
  <li>Unbounded queues grow as needed.</li>
  <li>Bounded queues (like <code>ArrayBlockingQueue</code>) have fixed capacity.</li>
  <li>Some queues (like <code>ArrayDeque</code>) expand dynamically.</li>
</ul>

<h3>Underlying Data Structure</h3>
<ul>
  <li><code>LinkedList</code> → Doubly linked list</li>
  <li><code>PriorityQueue</code> → Binary heap</li>
  <li><code>ArrayDeque</code> → Resizable circular array</li>
</ul>

<hr/>

<h2>2️⃣ LinkedList (as Queue)</h2>

<h3>Definition</h3>
<p>
  <code>LinkedList</code> implements <code>Queue</code>, allowing <strong>FIFO</strong> operations while maintaining insertion order.
</p>

<h3>Syntax</h3>
<pre><code>Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
queue.offer(10);
queue.offer(20);</code></pre>

<h3>Characteristics</h3>
<ol>
  <li>Maintains insertion order.</li>
  <li>Allows <code>null</code> elements.</li>
  <li>O(1) insertion/removal at head and tail.</li>
</ol>

<h3>Advantages</h3>
<ul>
  <li>Flexible: can act as <code>List</code> or <code>Deque</code>.</li>
  <li>Good for frequent insertions/removals at both ends.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>Higher memory overhead due to node objects and links.</li>
  <li>Slightly slower access than array-based queues.</li>
</ul>

<h3>Capacity</h3>
<p>Unbounded (limited only by memory).</p>

<h3>Underlying Data Structure</h3>
<p>Doubly linked list.</p>

<hr/>

<h2>3️⃣ PriorityQueue</h2>

<h3>Definition</h3>
<p>
  <code>PriorityQueue</code> orders elements by their natural ordering or a custom <code>Comparator</code>.
</p>

<h3>Syntax</h3>
<pre><code>Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();
Queue&lt;Integer&gt; customPQ = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());</code></pre>

<h3>Characteristics</h3>
<ol>
  <li>Not FIFO — ordered by priority.</li>
  <li>Null elements are not allowed.</li>
  <li><code>peek()</code> returns smallest (or highest priority) element.</li>
</ol>

<h3>Advantages</h3>
<ul>
  <li>Automatic sorting by priority.</li>
  <li>O(log n) insertion and removal.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>Iteration order is not sorted — only the head is guaranteed.</li>
  <li>Slower than O(1) queues for insertion/removal.</li>
</ul>

<h3>Capacity</h3>
<p>Default initial capacity is 11; grows automatically as needed.</p>

<h3>Underlying Data Structure</h3>
<p>Binary heap backed by array.</p>

<hr/>

<h2>4️⃣ ArrayDeque</h2>

<h3>Definition</h3>
<p>
  <code>ArrayDeque</code> implements <code>Deque</code> (double-ended queue) backed by a resizable circular array.
</p>

<h3>Syntax</h3>
<pre><code>Queue&lt;String&gt; adq = new ArrayDeque&lt;&gt;();</code></pre>

<h3>Characteristics</h3>
<ol>
  <li>Maintains insertion order.</li>
  <li>Null elements are not allowed.</li>
  <li>Faster than <code>LinkedList</code> for most queue operations.</li>
</ol>

<h3>Advantages</h3>
<ul>
  <li>No capacity restrictions (auto-expands).</li>
  <li>Fast O(1) amortized time for head/tail operations.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>Not thread-safe.</li>
  <li>No null elements allowed.</li>
</ul>

<h3>Capacity</h3>
<p>Grows automatically, typically doubles capacity when needed.</p>

<h3>Underlying Data Structure</h3>
<p>Resizable circular array.</p>

<hr/>

<h2>5️⃣ Other Queue Implementations</h2>

<h3>ConcurrentLinkedQueue</h3>
<ul>
  <li>Thread-safe, non-blocking FIFO queue.</li>
  <li>Good for high-concurrency scenarios.</li>
  <li>Unbounded capacity.</li>
</ul>

<h3>ArrayBlockingQueue</h3>
<ul>
  <li>Fixed-size, thread-safe blocking queue.</li>
  <li>Blocks when full (on add) or empty (on poll).</li>
</ul>

<h3>DelayQueue</h3>
<ul>
  <li>Orders elements by delay expiration.</li>
  <li>Useful for scheduling and timer tasks.</li>
</ul>

<h3>SynchronousQueue</h3>
<ul>
  <li>No internal storage — each insert waits for a remove and vice versa.</li>
  <li>Used for thread handoff scenarios.</li>
</ul>

<hr/>

<h2>🔍 Summary Table — Queue Implementations</h2>

<table>
  <thead>
    <tr>
      <th>Implementation</th>
      <th>Ordering</th>
      <th>Nulls</th>
      <th>Thread-safe</th>
      <th>Growth</th>
      <th>Backing Data Structure</th>
      <th>Typical Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LinkedList</td>
      <td>FIFO</td>
      <td>Yes</td>
      <td>No</td>
      <td>Unbounded</td>
      <td>Doubly linked list</td>
      <td>Simple FIFO queue</td>
    </tr>
    <tr>
      <td>PriorityQueue</td>
      <td>Priority order</td>
      <td>No</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Binary heap</td>
      <td>Task scheduling by priority</td>
    </tr>
    <tr>
      <td>ArrayDeque</td>
      <td>FIFO</td>
      <td>No</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Circular array</td>
      <td>Fast head/tail operations</td>
    </tr>
    <tr>
      <td>ConcurrentLinkedQueue</td>
      <td>FIFO</td>
      <td>No</td>
      <td>Yes</td>
      <td>Unbounded</td>
      <td>Linked nodes</td>
      <td>Concurrent task queue</td>
    </tr>
    <tr>
      <td>ArrayBlockingQueue</td>
      <td>FIFO</td>
      <td>No</td>
      <td>Yes</td>
      <td>Fixed</td>
      <td>Array</td>
      <td>Bounded producer-consumer</td>
    </tr>
    <tr>
      <td>DelayQueue</td>
      <td>Delay expiry</td>
      <td>No</td>
      <td>Yes</td>
      <td>Dynamic</td>
      <td>Priority queue</td>
      <td>Delayed task execution</td>
    </tr>
    <tr>
      <td>SynchronousQueue</td>
      <td>Direct handoff</td>
      <td>No</td>
      <td>Yes</td>
      <td>None</td>
      <td>None</td>
      <td>Thread handoff without storage</td>
    </tr>
  </tbody>
</table>

<hr>

<h1>Java Collections: Queue Interface and Implementations</h1>
<h2>1. <code>Queue</code> Interface (java.util.Queue) — Common Methods</h2>

<p>These methods are available in all Queue implementations.</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Return Type</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>boolean add(E e)</code></td>
      <td>boolean</td>
      <td>Inserts the element into the queue; throws <code>IllegalStateException</code> if full.</td>
      <td><code>queue.add("A");</code></td>
    </tr>
    <tr>
      <td><code>boolean offer(E e)</code></td>
      <td>boolean</td>
      <td>Inserts element; returns <code>false</code> if full (preferred for bounded queues).</td>
      <td><code>queue.offer("B");</code></td>
    </tr>
    <tr>
      <td><code>E remove()</code></td>
      <td>E</td>
      <td>Retrieves and removes head; throws <code>NoSuchElementException</code> if empty.</td>
      <td><code>queue.remove();</code></td>
    </tr>
    <tr>
      <td><code>E poll()</code></td>
      <td>E</td>
      <td>Retrieves and removes head; returns <code>null</code> if empty.</td>
      <td><code>queue.poll();</code></td>
    </tr>
    <tr>
      <td><code>E element()</code></td>
      <td>E</td>
      <td>Retrieves (but does not remove) head; throws <code>NoSuchElementException</code> if empty.</td>
      <td><code>queue.element();</code></td>
    </tr>
    <tr>
      <td><code>E peek()</code></td>
      <td>E</td>
      <td>Retrieves (but does not remove) head; returns <code>null</code> if empty.</td>
      <td><code>queue.peek();</code></td>
    </tr>
    <tr>
      <td><code>int size()</code></td>
      <td>int</td>
      <td>Returns number of elements in queue.</td>
      <td><code>queue.size();</code></td>
    </tr>
    <tr>
      <td><code>boolean isEmpty()</code></td>
      <td>boolean</td>
      <td>Checks if queue is empty.</td>
      <td><code>queue.isEmpty();</code></td>
    </tr>
    <tr>
      <td><code>boolean contains(Object o)</code></td>
      <td>boolean</td>
      <td>Checks if queue contains element.</td>
      <td><code>queue.contains("X");</code></td>
    </tr>
    <tr>
      <td><code>Iterator&lt;E&gt; iterator()</code></td>
      <td><code>Iterator&lt;E&gt;</code></td>
      <td>Iterates through queue elements in order.</td>
      <td><code>Iterator&lt;String&gt; it = queue.iterator();</code></td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>2. <code>PriorityQueue</code> — Extra Methods</h2>
<p><em>(Implements <code>Queue</code> + priority ordering)</em></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Return Type</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>comparator()</code></td>
      <td><code>Comparator&lt;? super E&gt;</code></td>
      <td>Returns comparator used, or <code>null</code> if natural ordering.</td>
      <td><code>pq.comparator();</code></td>
    </tr>
    <tr>
      <td colspan="4"><em>Other queue methods behave according to priority order.</em></td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>3. <code>ArrayDeque</code> — Extra Methods</h2>
<p><em>(Implements <code>Deque</code>, so supports double-ended operations)</em></p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>Return Type</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>void addFirst(E e)</code></td><td>void</td><td>Inserts at front.</td><td><code>deque.addFirst("A");</code></td></tr>
    <tr><td><code>void addLast(E e)</code></td><td>void</td><td>Inserts at rear.</td><td><code>deque.addLast("B");</code></td></tr>
    <tr><td><code>boolean offerFirst(E e)</code></td><td>boolean</td><td>Offers at front; returns false if full.</td><td><code>deque.offerFirst("C");</code></td></tr>
    <tr><td><code>boolean offerLast(E e)</code></td><td>boolean</td><td>Offers at rear.</td><td><code>deque.offerLast("D");</code></td></tr>
    <tr><td><code>E removeFirst()</code></td><td>E</td><td>Removes front; throws exception if empty.</td><td><code>deque.removeFirst();</code></td></tr>
    <tr><td><code>E removeLast()</code></td><td>E</td><td>Removes rear; throws exception if empty.</td><td><code>deque.removeLast();</code></td></tr>
    <tr><td><code>E pollFirst()</code></td><td>E</td><td>Removes front; returns null if empty.</td><td><code>deque.pollFirst();</code></td></tr>
    <tr><td><code>E pollLast()</code></td><td>E</td><td>Removes rear; returns null if empty.</td><td><code>deque.pollLast();</code></td></tr>
    <tr><td><code>E getFirst()</code></td><td>E</td><td>Retrieves front without removing; throws exception if empty.</td><td><code>deque.getFirst();</code></td></tr>
    <tr><td><code>E getLast()</code></td><td>E</td><td>Retrieves rear without removing; throws exception if empty.</td><td><code>deque.getLast();</code></td></tr>
    <tr><td><code>E peekFirst()</code></td><td>E</td><td>Retrieves front without removing; returns null if empty.</td><td><code>deque.peekFirst();</code></td></tr>
    <tr><td><code>E peekLast()</code></td><td>E</td><td>Retrieves rear without removing; returns null if empty.</td><td><code>deque.peekLast();</code></td></tr>
    <tr><td><code>boolean removeFirstOccurrence(Object o)</code></td><td>boolean</td><td>Removes first occurrence of given element.</td><td><code>deque.removeFirstOccurrence("X");</code></td></tr>
    <tr><td><code>boolean removeLastOccurrence(Object o)</code></td><td>boolean</td><td>Removes last occurrence of given element.</td><td><code>deque.removeLastOccurrence("X");</code></td></tr>
  </tbody>
</table>

<hr/>

<h2>4. <code>LinkedList</code> (as Queue) — Notes</h2>

<ul>
  <li>
    Implements <code>List</code>, <code>Deque</code>, and <code>Queue</code> interfaces — thus supports methods from all:
    <ul>
      <li><strong>Queue interface</strong> (as above)</li>
      <li><strong>Deque interface</strong> (like <code>ArrayDeque</code>)</li>
      <li><strong>List interface</strong> (index-based operations)</li>
    </ul>
  </li>
</ul>

<h3>Example</h3>
<pre><code>Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();
queue.offer("A");
queue.offer("B");
System.out.println(queue.poll()); // Output: A
System.out.println(queue.peek()); // Output: B
</code></pre>

<hr/>

<h3>Additional Points / Explanation</h3>
<ul>
  <li><strong>add() vs offer():</strong> Both insert elements, but <code>add()</code> throws exception if queue is full (bounded queues), whereas <code>offer()</code> returns false, making it safer for bounded queues.</li>
  <li><strong>remove() vs poll():</strong> Both remove and return head element; <code>remove()</code> throws exception if empty, <code>poll()</code> returns null.</li>
  <li><strong>element() vs peek():</strong> Both retrieve (but don’t remove) head element; <code>element()</code> throws exception if empty, <code>peek()</code> returns null.</li>
  <li><strong>ArrayDeque and LinkedList</strong> are the most common queue implementations, with ArrayDeque generally faster and preferred if no nulls and no thread safety required.</li>
  <li><strong>Thread safety:</strong> None of these implementations are thread-safe by default; for thread-safe queues, consider classes from <code>java.util.concurrent</code> package like <code>ConcurrentLinkedQueue</code>, <code>ArrayBlockingQueue</code>, etc.</li>
</ul>

<hr>

<h1>Java <code>Map</code> Interface and Implementations</h1>
<h2>1️⃣ Map Interface (java.util.Map)</h2>

<h3>Definition</h3>
<p>The <code>Map</code> interface represents a <strong>collection of key-value pairs</strong> where:</p>
<ul>
  <li><strong>Keys</strong> are unique (no duplicates).</li>
  <li>Each key maps to at most <strong>one value</strong>.</li>
  <li>Keys can be null (depending on implementation), values can be null (except in <code>Hashtable</code>).</li>
</ul>

<h3>Syntax</h3>
<pre><code>Map&lt;KeyType, ValueType&gt; mapName = new HashMap&lt;&gt;();
Map&lt;KeyType, ValueType&gt; mapName = new TreeMap&lt;&gt;();</code></pre>

<h3>Characteristics</h3>
<ul>
  <li>No duplicate keys — inserting an existing key replaces the old value.</li>
  <li>Values can be duplicated.</li>
  <li>No positional index — accessed via keys.</li>
  <li>Ordering depends on implementation (unordered, insertion-order, or sorted).</li>
  <li>Provides collection views:
    <ul>
      <li><code>keySet()</code> — set of keys</li>
      <li><code>values()</code> — collection of values</li>
      <li><code>entrySet()</code> — set of key-value pairs</li>
    </ul>
  </li>
</ul>

<h3>Advantages</h3>
<ul>
  <li>Fast key-based lookup.</li>
  <li>Flexible — choose ordering and performance by selecting implementation.</li>
  <li>Can store null keys/values in some implementations.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>No indexed access like a list.</li>
  <li>Memory overhead for key-value object wrappers.</li>
</ul>

<h3>When to Use</h3>
<ul>
  <li>Associating keys with values (like a dictionary).</li>
  <li>Caching, lookup tables, configuration storage.</li>
</ul>

<h3>When Not to Use</h3>
<ul>
  <li>If you need ordered sequential data without keys → use <code>List</code>.</li>
  <li>If multiple duplicate keys needed → use <code>Multimap</code> (Guava) or <code>Map&lt;K, List&lt;V&gt;&gt;</code> pattern.</li>
</ul>

<h3>Capacity</h3>
<ul>
  <li><strong>Initial Capacity:</strong> Starting bucket size (HashMap default = 16).</li>
  <li><strong>Load Factor:</strong> Threshold to resize (default 0.75 in HashMap).</li>
  <li><strong>Incremental Growth:</strong> Capacity usually doubles when threshold exceeded.</li>
</ul>

<h3>Underlying Data Structure</h3>
<ul>
  <li><code>HashMap</code>, <code>Hashtable</code> — hash table (array + linked list/tree bins for Java 8+).</li>
  <li><code>LinkedHashMap</code> — hash table + doubly linked list.</li>
  <li><code>TreeMap</code> — Red-Black Tree.</li>
  <li><code>EnumMap</code> — array indexed by enum ordinal.</li>
</ul>

<hr/>

<h2>2️⃣ HashMap</h2>

<h3>Definition</h3>
<p>Unordered map using <strong>hashing</strong> for key lookup.</p>

<h3>Syntax</h3>
<pre><code>Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
map.put("A", 1);</code></pre>

<h3>Characteristics</h3>
<ul>
  <li>Allows one <code>null</code> key and multiple null values.</li>
  <li>Unordered iteration.</li>
  <li>O(1) average time for <code>get</code> and <code>put</code> (worst case O(log n) due to tree bins).</li>
</ul>

<h3>Advantages</h3>
<ul>
  <li>Very fast for large datasets.</li>
  <li>Allows null key.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>No ordering guarantee.</li>
  <li>Not thread-safe.</li>
</ul>

<h3>Capacity</h3>
<ul>
  <li>Default initial capacity = 16.</li>
  <li>Load factor = 0.75, resizes by doubling capacity.</li>
</ul>

<h3>Underlying Data Structure</h3>
<p>Hash table with array + linked list/tree bins.</p>

<hr/>

<h2>3️⃣ LinkedHashMap</h2>

<h3>Definition</h3>
<p>Ordered version of <code>HashMap</code> — maintains <strong>insertion order</strong> or <strong>access order</strong>.</p>

<h3>Syntax</h3>
<pre><code>Map&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();</code></pre>

<h3>Characteristics</h3>
<ul>
  <li>Allows null key.</li>
  <li>Predictable iteration order.</li>
  <li>Slightly slower than <code>HashMap</code> due to ordering overhead.</li>
</ul>

<h3>Advantages</h3>
<ul>
  <li>Preserves order.</li>
  <li>Supports LRU caches using access-order mode.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>More memory overhead than <code>HashMap</code>.</li>
</ul>

<h3>Underlying Data Structure</h3>
<p>Hash table + doubly linked list.</p>

<hr/>

<h2>4️⃣ TreeMap</h2>

<h3>Definition</h3>
<p>Sorted map implemented with a <strong>Red-Black Tree</strong>.</p>

<h3>Syntax</h3>
<pre><code>Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;();
Map&lt;String, Integer&gt; customMap = new TreeMap&lt;&gt;(Comparator.reverseOrder());</code></pre>

<h3>Characteristics</h3>
<ul>
  <li>No <code>null</code> keys allowed; multiple null values allowed.</li>
  <li>Keys sorted by natural order or custom comparator.</li>
  <li>O(log n) time for <code>get</code> and <code>put</code>.</li>
</ul>

<h3>Advantages</h3>
<ul>
  <li>Automatically sorted keys.</li>
</ul>

<h3>Disadvantages</h3>
<ul>
  <li>Slower than <code>HashMap</code> for large data.</li>
</ul>

<h3>Underlying Data Structure</h3>
<p>Red-Black Tree.</p>

<hr/>

<h2>5️⃣ Hashtable</h2>

<h3>Definition</h3>
<p>Legacy synchronized map.</p>

<h3>Characteristics</h3>
<ul>
  <li>No <code>null</code> keys or values allowed.</li>
  <li>Thread-safe but slower.</li>
</ul>

<h3>When to Use</h3>
<p>Rarely; prefer <code>ConcurrentHashMap</code> for concurrency.</p>

<hr/>

<h2>6️⃣ Other Map Implementations</h2>
<ul>
  <li><strong>ConcurrentHashMap</strong> — thread-safe, high concurrency, segmented locking.</li>
  <li><strong>WeakHashMap</strong> — keys eligible for GC when no longer referenced.</li>
  <li><strong>IdentityHashMap</strong> — compares keys by reference (<code>==</code>) instead of <code>equals()</code>.</li>
  <li><strong>EnumMap</strong> — optimized for enum keys, backed by an array.</li>
</ul>

<hr/>

<h2>🔍 Summary Table — Map Implementations</h2>

<table border="1" cellpadding="6" cellspacing="0">
  <thead>
    <tr>
      <th>Implementation</th>
      <th>Ordering</th>
      <th>Null Key</th>
      <th>Null Value</th>
      <th>Thread-safe</th>
      <th>Growth</th>
      <th>Backing DS</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HashMap</td>
      <td>None</td>
      <td>1</td>
      <td>Yes</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Hash table</td>
      <td>General-purpose key-value</td>
    </tr>
    <tr>
      <td>LinkedHashMap</td>
      <td>Insertion/Access</td>
      <td>1</td>
      <td>Yes</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Hash + Doubly linked list</td>
      <td>Predictable iteration, LRU cache</td>
    </tr>
    <tr>
      <td>TreeMap</td>
      <td>Sorted</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Red-Black Tree</td>
      <td>Sorted keys</td>
    </tr>
    <tr>
      <td>Hashtable</td>
      <td>None</td>
      <td>No</td>
      <td>No</td>
      <td>Yes</td>
      <td>Dynamic</td>
      <td>Hash table</td>
      <td>Legacy synchronized map</td>
    </tr>
    <tr>
      <td>ConcurrentHashMap</td>
      <td>None</td>
      <td>No</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>Dynamic</td>
      <td>Segmented hash</td>
      <td>High concurrency</td>
    </tr>
    <tr>
      <td>WeakHashMap</td>
      <td>None</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Hash + weak references</td>
      <td>Auto-remove GC-collected keys</td>
    </tr>
    <tr>
      <td>IdentityHashMap</td>
      <td>None</td>
      <td>Yes</td>
      <td>Yes</td>
      <td>No</td>
      <td>Dynamic</td>
      <td>Hash table</td>
      <td>Key identity-based mapping</td>
    </tr>
    <tr>
      <td>EnumMap</td>
      <td>Natural (enum)</td>
      <td>No</td>
      <td>Yes</td>
      <td>No</td>
      <td>Fixed size</td>
      <td>Array</td>
      <td>Enum keys only, fast lookup</td>
    </tr>
  </tbody>
</table>

<hr>

<h1>Java Collections: Map Interface and Implementations</h1>
<h2>📌 Map in Java</h2>

<p>A <strong>Map</strong> in Java is <strong>not</strong> part of the <code>Collection</code> interface but belongs to a separate hierarchy.<br>
It stores <strong>key–value pairs</strong> — each key is <strong>unique</strong>, and each key maps to exactly <strong>one value</strong>.</p>

<hr/>

<h3>Hierarchy</h3>
<pre><code>Map&lt;K, V&gt; (interface)
    |
    +-- HashMap
    +-- LinkedHashMap
    +-- TreeMap
    +-- Hashtable
</code></pre>

<hr/>

<h3>Key Points</h3>
<ul>
  <li>Keys <strong>must be unique</strong> (if duplicate key is inserted, old value is replaced).</li>
  <li>Values <strong>can be duplicated</strong>.</li>
  <li>Allows <strong>null</strong> keys and values (implementation-dependent):
    <ul>
      <li><code>HashMap</code> → 1 null key, multiple null values allowed.</li>
      <li><code>Hashtable</code> → no null keys or values allowed.</li>
      <li><code>TreeMap</code> → no null keys (throws <code>NullPointerException</code>), null values allowed if comparator supports.</li>
    </ul>
  </li>
</ul>

<hr/>

<h3>Main Methods</h3>
<table border="1" cellpadding="6" cellspacing="0">
  <thead>
    <tr>
      <th>Method</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>put(K key, V value)</code></td>
      <td>Adds or updates a key-value pair.</td>
    </tr>
    <tr>
      <td><code>putIfAbsent(K key, V value)</code></td>
      <td>Adds the pair only if the key is not already present.</td>
    </tr>
    <tr>
      <td><code>get(Object key)</code></td>
      <td>Returns the value mapped to the given key.</td>
    </tr>
    <tr>
      <td><code>getOrDefault(Object key, V defaultValue)</code></td>
      <td>Returns the value for the key or a default value if key not found.</td>
    </tr>
    <tr>
      <td><code>remove(Object key)</code></td>
      <td>Removes the mapping for the key.</td>
    </tr>
    <tr>
      <td><code>containsKey(Object key)</code></td>
      <td>Checks if the map contains the specified key.</td>
    </tr>
    <tr>
      <td><code>containsValue(Object value)</code></td>
      <td>Checks if the map contains the specified value.</td>
    </tr>
    <tr>
      <td><code>keySet()</code></td>
      <td>Returns a <code>Set</code> view of the keys.</td>
    </tr>
    <tr>
      <td><code>values()</code></td>
      <td>Returns a <code>Collection</code> view of the values.</td>
    </tr>
    <tr>
      <td><code>entrySet()</code></td>
      <td>Returns a <code>Set</code> view of key-value mappings.</td>
    </tr>
  </tbody>
</table>

<hr/>

<h3>Example: Using HashMap</h3>
<pre><code>import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();

        // Adding entries
        map.put(1, "Apple");
        map.put(2, "Banana");
        map.put(3, "Cherry");

        // Duplicate key (replaces value)
        map.put(2, "Blueberry");

        // Accessing
        System.out.println("Key 2 → " + map.get(2));

        // Checking
        System.out.println("Contains key 3? " + map.containsKey(3));

        // Iterating using entrySet()
        for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) {
            System.out.println(entry.getKey() + " → " + entry.getValue());
        }
    }
}
</code></pre>

<h4>Output</h4>
<pre><code>Key 2 → Blueberry
Contains key 3? true
1 → Apple
2 → Blueberry
3 → Cherry
</code></pre>

<hr/>

<h3>Types of Map Implementations</h3>
<table border="1" cellpadding="6" cellspacing="0">
  <thead>
    <tr>
      <th>Implementation</th>
      <th>Ordering</th>
      <th>Null Keys</th>
      <th>Thread-Safe?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>HashMap</strong></td>
      <td>No ordering</td>
      <td>1 null key allowed</td>
      <td>No</td>
    </tr>
    <tr>
      <td><strong>LinkedHashMap</strong></td>
      <td>Maintains insertion order</td>
      <td>1 null key allowed</td>
      <td>No</td>
    </tr>
    <tr>
      <td><strong>TreeMap</strong></td>
      <td>Sorted by keys (natural order or comparator)</td>
      <td>No null keys allowed</td>
      <td>No</td>
    </tr>
    <tr>
      <td><strong>Hashtable</strong></td>
      <td>No ordering</td>
      <td>No null keys or values allowed</td>
      <td>Yes</td>
    </tr>
  </tbody>
</table>

<hr/>

<h3>Additional Notes</h3>
<ul>
  <li><strong>Thread Safety:</strong> Most implementations (except <code>Hashtable</code> and <code>ConcurrentHashMap</code>) are <em>not</em> thread-safe. Use synchronization or concurrent collections for multithreaded access.</li>
  <li><strong>Iteration:</strong> Iteration order depends on implementation (unordered, insertion order, or sorted).</li>
  <li><strong>Null Handling:</strong> Be mindful of null keys and values, as some implementations disallow them.</li>
</ul>

<hr>

</body>
</html>
