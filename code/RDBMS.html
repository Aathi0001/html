
<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>RDBMS Basics</title>
     <style>
          body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      line-height: 1.6;
      padding: 20px;
      color: #333;
      max-width: 100%;
    word-wrap: break-word;
    }
pre, table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}

    code {
  background-color: #f0f0f0;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 0.95em;
  color: #c7254e;
}
    h1, h2, h3 {
      margin-top: 30px;
      border-left: 5px solid #ff6347;
      padding-left: 12px;
      color: #333;
    }

    h1 {
      font-size: 32px;
      color: #e91e63;
    }

    h2 {
      font-size: 26px;
      color: #3f51b5;
    }

    h3 {
      font-size: 22px;
      color: #009688;
    }

    pre {
      background: #eee;
      padding: 10px 15px;
      border-left: 5px solid #607d8b;
      white-space: pre-wrap;
      font-family: 'Consolas', monospace;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin: 4px 0;
    }

table { 
    width: 100%; 
    border-collapse: collapse; 
    margin: 15px 0; 
}

th, td { 
    border: 1px solid #ccc; 
    padding: 8px; 
    text-align: left; 
}

th { 
    background: #34495e; 
    color: white; 
}
    .section {
      margin-bottom: 40px;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 10px;
      border-left: 4px solid #ffc107;
    }
     </style>
</head>
<body>

<div class="topic">
  <h2>ER Model Basics</h2>

  <h3>1. Entity</h3>
  <p>
    An <b>Entity</b> is a real-world object or concept that can be uniquely identified.  
    It can be a physical object (like <i>Student</i>, <i>Teacher</i>, <i>Car</i>) or a conceptual object (like <i>Course</i>, <i>Department</i>).  
  </p>
  <p>
    Example: <b>Student</b> is an entity.
  </p>

  <h3>2. Attributes</h3>
  <p>
    Attributes are the <b>properties</b> that describe an entity.  
    For example, the entity <b>Student</b> can have attributes:
  </p>
  <ul>
    <li>StudentID</li>
    <li>Name</li>
    <li>Email</li>
    <li>Phone</li>
  </ul>
  <p>
    <b>Types of Attributes:</b>
    <ul>
      <li><b>Simple</b> ‚Äì cannot be divided further (e.g., Name, Age).</li>
      <li><b>Composite</b> ‚Äì can be divided into smaller parts (e.g., FullName ‚Üí FirstName + LastName).</li>
      <li><b>Derived</b> ‚Äì values derived from other attributes (e.g., Age from DateOfBirth).</li>
      <li><b>Multivalued</b> ‚Äì can have multiple values (e.g., PhoneNumbers for a person).</li>
    </ul>
  </p>

  <h3>3. Relationships</h3>
  <p>
    A <b>Relationship</b> defines how two entities are connected.  
    Example:  
    - <b>Student</b> <i>enrolls in</i> <b>Course</b>  
    - <b>Teacher</b> <i>teaches</i> <b>Course</b>
  </p>

  <h3>4. Cardinality</h3>
  <p>
    <b>Cardinality</b> specifies the number of instances of one entity that can/must be associated with the number of instances of another entity.
  </p>
  <p>
    Types of Cardinality:
    <ul>
      <li><b>One-to-One (1:1)</b> ‚Äì One person has one passport.</li>
      <li><b>One-to-Many (1:N)</b> ‚Äì One teacher teaches many students.</li>
      <li><b>Many-to-One (N:1)</b> ‚Äì Many students belong to one department.</li>
      <li><b>Many-to-Many (M:N)</b> ‚Äì Students enroll in many courses, and each course has many students.</li>
    </ul>
  </p>
</div>

<hr>

<div class="topic">
  <h2>Normalization in DBMS</h2>

  <p>
    <b>Normalization</b> is the process of organizing data in a database to remove redundancy 
    and improve data integrity.  
    It divides larger tables into smaller ones and defines relationships between them.
  </p>

  <h3>Why Normalization?</h3>
  <ul>
    <li>To eliminate duplicate data.</li>
    <li>To reduce data redundancy and inconsistency.</li>
    <li>To make data retrieval efficient.</li>
    <li>To maintain data integrity.</li>
  </ul>

  <h3>Normal Forms</h3>
  <p>Normalization is done in stages called <b>Normal Forms (NF)</b>:</p>
  
  <h4>1. First Normal Form (1NF)</h4>
  <ul>
    <li>Each column must contain atomic (indivisible) values.</li>
    <li>No repeating groups or arrays allowed.</li>
  </ul>
  <p>
    Example:<br>
    ‚ùå Wrong: Student(ID, Name, Phone1, Phone2)<br>
    ‚úî Correct: Student(ID, Name, Phone)
  </p>

  <h4>2. Second Normal Form (2NF)</h4>
  <ul>
    <li>Table must be in 1NF.</li>
    <li>Functional dependency - All non-Primary key is depending on primary key column.</li>
    <li>No partial dependency ‚Äì every non-Primary key attribute must depend on the whole primary key.</li>
  </ul>
  <p>
    Example: If (StudentID, CourseID) is PK, then StudentName should not depend only on StudentID.
  </p>

  <h4>3. Third Normal Form (3NF)</h4>
  <ul>
    <li>Table must be in 2NF.</li>
    <li>No transitive dependency ‚Äì non-Primary key attributes should not depend on other non- Primary key attributes.</li>
  </ul>
  <p>
    Example:<br>
    ‚ùå Wrong: Student(ID, Name, DeptID, DeptName)<br>
    (DeptName depends on DeptID, not directly on StudentID)<br>
    ‚úî Correct: Separate Department table.
  </p>

  <h4>4. Boyce-Codd Normal Form (BCNF)</h4>
  <ul>
    <li>Stronger version of 3NF.</li>
    <li>Every determinant must be a candidate key.</li>
  </ul>

  <h3>Advantages of Normalization</h3>
  <ul>
    <li>Removes redundancy.</li>
    <li>Ensures data consistency.</li>
    <li>Makes database flexible and efficient.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Requires more joins while querying.</li>
    <li>Too many small tables may reduce performance in complex queries.</li>
  </ul>
</div>

<hr>

<section class="card">

    <h2>Normalization: <strong>1NF ‚Äî First Normal Form</strong></h2>
    <p class="note">Goal: Ensure that each table column holds <em>atomic</em> (indivisible) values and that each row is unique. 1NF is the foundation for higher normal forms.</p>

    <h3>What 1NF requires</h3>
    <ul>
      <li>Every column must contain atomic (single) values ‚Äî no repeating groups or arrays inside a column.</li>
      <li>Each row must be unique (usually enforced by a primary key).</li>
      <li>The order of rows and columns does not matter.</li>
    </ul>

    <h3 class="example-title">Example ‚Äî a table that <em>violates</em> 1NF</h3>
    <p class="note">Consider a simple <code>Students</code> table where phone numbers are stored as a comma-separated list in the <code>phones</code> column:</p>

    <table>
      <thead>
        <tr><th>student_id</th><th>name</th><th>phones</th></tr>
      </thead>
      <tbody>
        <tr><td>101</td><td>Asha</td><td>+91-99999-11111, +91-99999-22222</td></tr>
        <tr><td>102</td><td>Vikram</td><td>+91-88888-33333</td></tr>
        <tr><td>103</td><td>Meera</td><td>+91-77777-44444, +91-77777-55555, +91-77777-66666</td></tr>
      </tbody>
    </table>

    <p class="note">Problem: the <code>phones</code> column contains multiple values (lists). This violates 1NF because values are not atomic. It makes querying and indexing phone numbers difficult.</p>

    <h3 class="example-title">Normalized to 1NF ‚Äî make values atomic</h3>
    <p class="note">Split phone numbers into a separate table so each cell holds a single phone number and each row represents one student-phone relationship.</p>

    <table>
      <caption style="text-align:left;font-weight:600;margin-bottom:6px">Students</caption>
      <thead><tr><th>student_id</th><th>name</th></tr></thead>
      <tbody>
        <tr><td>101</td><td>Asha</td></tr>
        <tr><td>102</td><td>Vikram</td></tr>
        <tr><td>103</td><td>Meera</td></tr>
      </tbody>
    </table>

    <table>
      <caption style="text-align:left;font-weight:600;margin-bottom:6px">StudentPhones</caption>
      <thead><tr><th>phone_id</th><th>student_id</th><th>phone</th></tr></thead>
      <tbody>
        <tr><td>1</td><td>101</td><td>+91-99999-11111</td></tr>
        <tr><td>2</td><td>101</td><td>+91-99999-22222</td></tr>
        <tr><td>3</td><td>102</td><td>+91-88888-33333</td></tr>
        <tr><td>4</td><td>103</td><td>+91-77777-44444</td></tr>
        <tr><td>5</td><td>103</td><td>+91-77777-55555</td></tr>
        <tr><td>6</td><td>103</td><td>+91-77777-66666</td></tr>
      </tbody>
 
</table>

    <h3 class="example-title">SQL example (create + insert)</h3>
    <pre><code>-- Students table (student_id is primary key)
CREATE TABLE Students (
  student_id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL
);

-- StudentPhones table (each row stores one phone number)
CREATE TABLE StudentPhones (
  phone_id INT PRIMARY KEY AUTO_INCREMENT,
  student_id INT NOT NULL,
  phone VARCHAR(30) NOT NULL,
  FOREIGN KEY (student_id) REFERENCES Students(student_id)
);

-- Insert sample data
INSERT INTO Students (student_id, name) VALUES (101, 'Asha'), (102, 'Vikram'), (103, 'Meera');
INSERT INTO StudentPhones (student_id, phone) VALUES
  (101, '+91-99999-11111'),
  (101, '+91-99999-22222'),
  (102, '+91-88888-33333'),
  (103, '+91-77777-44444'),
  (103, '+91-77777-55555'),
  (103, '+91-77777-66666');
</code></pre>

    <h3 class="example-title">Why 1NF matters</h3>
    <ul>
      <li>Queries like <code>WHERE phone = '...'</code> are simple and efficient when phones are atomic.</li>
      <li>Data integrity and indexing are much easier (each phone can be indexed separately).</li>
      <li>Prepares the schema for higher normal forms (2NF, 3NF, etc.).</li>
    </ul>

    <h3 class="example-title">Quick checklist to confirm 1NF</h3>
    <ol>
      <li>Are all columns atomic (no lists or sets inside a cell)?</li>
      <li>Is there a clear primary key to identify each row?</li>
      <li>Can you query/filter each value directly without string parsing?</li>
    </ol>

    <p class="note" style="margin-top:10px">That's 1NF ‚Äî would you like me to generate the next HTML file for <strong>2NF (Second Normal Form)</strong> now?</p>
  </section>
<section id="1nf-repeating-groups">
  <h2>üìò Understanding "No Repeating Groups" in <code>1NF</code></h2>

  <h3>üîπ What Does ‚ÄúNo Repeating Groups‚Äù Mean?</h3>
  <p>
    It does <b>not</b> mean you cannot have repeated values.  
    It means that you should <b>not create multiple columns to store the same type of data</b>.
  </p>
  <p>
    Each column must store <b>atomic (single) values</b>, and there should be only <b>one column per data type</b>.
  </p>

  <h3>‚ùå Example: Not in 1NF (Repeating Groups)</h3>
  <p>This table uses multiple columns for the same kind of data (phone numbers):</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Student_ID</th>
      <th>Name</th>
      <th>Phone1</th>
      <th>Phone2</th>
      <th>Phone3</th>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>98765...</td>
      <td>97543...</td>
      <td>98452...</td>
    </tr>
  </table>

  <p>
    üî∏ This violates 1NF because:
  </p>
  <ul>
    <li>There are <b>repeating groups</b> (Phone1, Phone2, Phone3).</li>
    <li>Columns are <b>not atomic</b> ‚Äî they represent multiple values for the same attribute.</li>
    <li>It‚Äôs hard to add or remove phone numbers without changing the table structure.</li>
  </ul>

  <h3>‚úÖ Example: In 1NF (No Repeating Groups)</h3>
  <p>Store each phone number as a separate row instead of separate columns:</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Student_ID</th>
      <th>Name</th>
      <th>Phone</th>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>98765...</td>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>97543...</td>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>98452...</td>
    </tr>
  </table>

  <p>
    üîπ Now the table is in <b>First Normal Form (1NF)</b> because:
  </p>
  <ul>
    <li>Each column has only <b>one value</b> per row.</li>
    <li>No repeating columns for the same attribute.</li>
    <li>Table structure is <b>flexible</b> ‚Äî you can add more phones by inserting new rows.</li>
  </ul>

  <h3>üß† Quick Summary</h3>
  <ul>
    <li>‚ùå ‚ÄúRepeating groups‚Äù ‚Üí multiple columns for same kind of data (e.g., Phone1, Phone2...)</li>
    <li>‚úÖ ‚ÄúNo repeating groups‚Äù ‚Üí one column, multiple rows if needed</li>
    <li>‚ùå Does <b>not</b> mean no repeated values ‚Äî duplicates are allowed if they represent valid data.</li>
  </ul>
</section>

  <!-- 2NF ‚Äî Second Normal Form (copy this section only) -->
<section id="2nf">
  <h2>Normalization: <strong>2NF ‚Äî Second Normal Form</strong></h2>
  <p><em>Goal:</em> Remove <strong>partial dependencies</strong> ‚Äî every non-key column must depend on the <strong>whole</strong> primary key, not just part of it. (Applies only when the table has a composite primary key.)</p>

  <h3>What 2NF requires</h3>
  <ul>
    <li>Table must already be in <strong>1NF</strong>.</li>
    <li>If the primary key is composite (more than one column), no non-key attribute may depend on only part of that key.</li>
    <li>Solve partial dependencies by splitting into separate tables so each non-key attribute depends on the full key.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 2NF (has partial dependency)</h3>
  <p>Imagine an <code>OrderDetails</code> table where the primary key is (<code>order_id</code>, <code>product_id</code>), but product-related info repeats:</p>

  <table>
    <thead>
      <tr><th>order_id</th><th>product_id</th><th>product_name</th><th>price</th><th>quantity</th></tr>
    </thead>
    <tbody>
      <tr><td>5001</td><td>101</td><td>Pen</td><td>10</td><td>2</td></tr>
      <tr><td>5001</td><td>102</td><td>Notebook</td><td>40</td><td>1</td></tr>
      <tr><td>5002</td><td>101</td><td>Pen</td><td>10</td><td>5</td></tr>
    </tbody>
  </table>

  <p><strong>Problem:</strong> <code>product_name</code> and <code>price</code> depend only on <code>product_id</code> (part of the composite key), not on the full key (<code>order_id, product_id</code>). This is a partial dependency ‚Üí violates 2NF.</p>

  <h3>Normalize to 2NF ‚Äî split into tables</h3>
  <p>Separate product details into a <code>Products</code> table; keep order-specific columns in <code>OrderDetails</code> (or <code>OrderItems</code>).</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Orders (example)</caption>
    <thead><tr><th>order_id</th><th>order_date</th><th>customer_id</th></tr></thead>
    <tbody>
      <tr><td>5001</td><td>2025-11-01</td><td>200</td></tr>
      <tr><td>5002</td><td>2025-11-02</td><td>201</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Products</caption>
    <thead><tr><th>product_id</th><th>product_name</th><th>price</th></tr></thead>
    <tbody>
      <tr><td>101</td><td>Pen</td><td>10</td></tr>
      <tr><td>102</td><td>Notebook</td><td>40</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">OrderItems (composite PK: order_id, product_id)</caption>
    <thead><tr><th>order_id</th><th>product_id</th><th>quantity</th></tr></thead>
    <tbody>
      <tr><td>5001</td><td>101</td><td>2</td></tr>
      <tr><td>5001</td><td>102</td><td>1</td></tr>
      <tr><td>5002</td><td>101</td><td>5</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- Products: product_id is primary key
CREATE TABLE Products (
  product_id INT PRIMARY KEY,
  product_name VARCHAR(100) NOT NULL,
  price DECIMAL(10,2) NOT NULL
);

-- Orders: order header
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  order_date DATE,
  customer_id INT
);

-- OrderItems: composite primary key (order_id, product_id)
CREATE TABLE OrderItems (
  order_id INT NOT NULL,
  product_id INT NOT NULL,
  quantity INT NOT NULL,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (order_id) REFERENCES Orders(order_id),
  FOREIGN KEY (product_id) REFERENCES Products(product_id)
);

-- sample data
INSERT INTO Products VALUES (101, 'Pen', 10.00), (102, 'Notebook', 40.00);
INSERT INTO Orders VALUES (5001, '2025-11-01', 200), (5002, '2025-11-02', 201);
INSERT INTO OrderItems VALUES (5001, 101, 2), (5001, 102, 1), (5002, 101, 5);
</code></pre>

  <h3>Why this fixes 2NF</h3>
  <ul>
    <li>Product attributes (<code>product_name</code>, <code>price</code>) now depend solely on <code>Products.product_id</code>, not on (<code>order_id, product_id</code>).</li>
    <li>Order-specific attributes (like <code>quantity</code>) depend on the full composite key (<code>order_id, product_id</code>) in <code>OrderItems</code>.</li>
    <li>This removes redundancy (product info stored once) and prevents update anomalies.</li>
  </ul>

  <h3>Quick checklist to confirm 2NF</h3>
  <ol>
    <li>Is the table already in <strong>1NF</strong>?</li>
    <li>Does the table use a composite primary key? If yes, check each non-key column ‚Äî does it depend on the full key or just part of it?</li>
    <li>If partial dependencies exist, split the table so each non-key column depends on the whole key.</li>
  </ol>
</section>

<!-- 3NF ‚Äî Third Normal Form (copy this section only) -->
<section id="3nf">
  <h2>Normalization: <strong>3NF ‚Äî Third Normal Form</strong></h2>
  <p><em>Goal:</em> Remove <strong>transitive dependencies</strong> ‚Äî every non-key attribute must depend <strong>only on the primary key</strong> and not on another non-key attribute.</p>

  <h3>What 3NF requires</h3>
  <ul>
    <li>Table must already be in <strong>2NF</strong>.</li>
    <li>No non-key attribute should depend on another non-key attribute (transitive dependency).</li>
    <li>Each non-key column should depend directly on the key and nothing else.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 3NF (has transitive dependency)</h3>
  <p>Consider an <code>Orders</code> table where <code>customer_city</code> depends on <code>customer_id</code> instead of directly on the primary key (<code>order_id</code>):</p>

  <table>
    <thead>
      <tr><th>order_id</th><th>customer_id</th><th>customer_name</th><th>customer_city</th><th>order_date</th></tr>
    </thead>
    <tbody>
      <tr><td>5001</td><td>201</td><td>Asha</td><td>Chennai</td><td>2025-11-01</td></tr>
      <tr><td>5002</td><td>202</td><td>Vikram</td><td>Delhi</td><td>2025-11-02</td></tr>
      <tr><td>5003</td><td>201</td><td>Asha</td><td>Chennai</td><td>2025-11-03</td></tr>
    </tbody>
  </table>

  <p><strong>Problem:</strong> <code>customer_name</code> and <code>customer_city</code> depend on <code>customer_id</code> (a non-key), not directly on <code>order_id</code>. This creates redundancy ‚Äî if a customer‚Äôs city changes, it must be updated in multiple rows.</p>

  <h3>Normalize to 3NF ‚Äî remove transitive dependency</h3>
  <p>Separate customer details into their own <code>Customers</code> table. Keep only <code>customer_id</code> in the <code>Orders</code> table.</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Customers</caption>
    <thead><tr><th>customer_id</th><th>customer_name</th><th>customer_city</th></tr></thead>
    <tbody>
      <tr><td>201</td><td>Asha</td><td>Chennai</td></tr>
      <tr><td>202</td><td>Vikram</td><td>Delhi</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Orders</caption>
    <thead><tr><th>order_id</th><th>order_date</th><th>customer_id</th></tr></thead>
    <tbody>
      <tr><td>5001</td><td>2025-11-01</td><td>201</td></tr>
      <tr><td>5002</td><td>2025-11-02</td><td>202</td></tr>
      <tr><td>5003</td><td>2025-11-03</td><td>201</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- Customers table
CREATE TABLE Customers (
  customer_id INT PRIMARY KEY,
  customer_name VARCHAR(100) NOT NULL,
  customer_city VARCHAR(100)
);

-- Orders table
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  order_date DATE,
  customer_id INT,
  FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);

-- Insert sample data
INSERT INTO Customers VALUES
  (201, 'Asha', 'Chennai'),
  (202, 'Vikram', 'Delhi');

INSERT INTO Orders VALUES
  (5001, '2025-11-01', 201),
  (5002, '2025-11-02', 202),
  (5003, '2025-11-03', 201);
</code></pre>

  <h3>Why this fixes 3NF</h3>
  <ul>
    <li>All non-key attributes in <code>Orders</code> now depend directly on <code>order_id</code>.</li>
    <li>Customer data is stored once in <code>Customers</code>, removing redundancy.</li>
    <li>Changing a customer‚Äôs city now requires updating only one record.</li>
  </ul>

  <h3>Quick checklist to confirm 3NF</h3>
  <ol>
    <li>Is the table already in 2NF?</li>
    <li>Does any non-key attribute depend on another non-key attribute? (If yes, move it to a separate table.)</li>
    <li>Do all non-key attributes depend directly on the key?</li>
  </ol>
</section>

<section id="bcnf">
  <h2>üß© <code>BCNF</code> ‚Äî Boyce‚ÄìCodd Normal Form (3.5NF)</h2>

  <h3>üìò Description</h3>
  <p>
    BCNF (Boyce‚ÄìCodd Normal Form), also known as <b>3.5 Normal Form</b>, is an advanced version of the Third Normal Form (3NF).  
    It removes anomalies that 3NF cannot handle by ensuring <b>every determinant is a candidate key</b>.
  </p>

  <h3>üí° Rule</h3>
  <ul>
    <li>The table must already satisfy 3NF.</li>
    <li>For every functional dependency <code>X ‚Üí Y</code>, <b>X must be a super key</b>.</li>
    <li>No dependency should exist where a non-prime attribute determines part of a candidate key.</li>
  </ul>

  <h3>üìä Example (Before BCNF)</h3>
  <p>Consider a table of university courses and professors:</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Professor</th>
      <th>Subject</th>
      <th>Textbook</th>
    </tr>
    <tr>
      <td>Dr. Smith</td>
      <td>Database</td>
      <td>DBMS by Korth</td>
    </tr>
    <tr>
      <td>Dr. Smith</td>
      <td>SQL</td>
      <td>DBMS by Korth</td>
    </tr>
  </table>

  <p>
    Functional dependencies:  
    <code>Professor ‚Üí Textbook</code> and <code>Subject ‚Üí Professor</code>.
  </p>

  <p>
    The key here is <code>{Subject, Professor}</code>.  
    But since <code>Professor ‚Üí Textbook</code> and Professor is not a super key, this violates BCNF.
  </p>

  <h3>‚úÖ After Applying BCNF</h3>
  <p>We decompose the table into two BCNF tables:</p>

  <h4>üìÑ Professor_Textbook</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Professor</th>
      <th>Textbook</th>
    </tr>
    <tr>
      <td>Dr. Smith</td>
      <td>DBMS by Korth</td>
    </tr>
  </table>

  <h4>üìÑ Subject_Professor</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Subject</th>
      <th>Professor</th>
    </tr>
    <tr>
      <td>Database</td>
      <td>Dr. Smith</td>
    </tr>
    <tr>
      <td>SQL</td>
      <td>Dr. Smith</td>
    </tr>
  </table>

  <h3>üìà SQL Example</h3>
  <pre><code class="language-sql">
CREATE TABLE Professor_Textbook (
  Professor VARCHAR(50) PRIMARY KEY,
  Textbook VARCHAR(100)
);

CREATE TABLE Subject_Professor (
  Subject VARCHAR(50) PRIMARY KEY,
  Professor VARCHAR(50)
);
  </code></pre>

  <h3>üß† Summary</h3>
  <ul>
    <li>BCNF fixes anomalies not handled by 3NF.</li>
    <li>Every determinant must be a candidate key.</li>
    <li>Stronger form of 3NF; ensures better data integrity.</li>
  </ul>
</section>

<!-- 4NF ‚Äî Fourth Normal Form (copy this section only) -->
<section id="4nf">
  <h2>Normalization: <strong>4NF ‚Äî Fourth Normal Form</strong></h2>
  <p><em>Goal:</em> Remove <strong>multi-valued dependencies</strong>. Each table should represent one type of independent relationship between entities. A record should not contain two or more independent multi-valued facts about the same key.</p>

  <h3>What 4NF requires</h3>
  <ul>
    <li>Table must already be in <strong>Boyce‚ÄìCodd Normal Form (BCNF)</strong>.</li>
    <li>There should be no <strong>multi-valued dependencies</strong> ‚Äî where one key determines multiple independent sets of values.</li>
    <li>Each fact in a table must describe one and only one relationship.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 4NF</h3>
  <p>Consider a <code>Teacher</code> table where each teacher can teach multiple <code>Subjects</code> and also handle multiple <code>Classes</code>. Both are independent relationships.</p>

  <table>
    <thead>
      <tr><th>teacher_id</th><th>teacher_name</th><th>subject</th><th>class</th></tr>
    </thead>
    <tbody>
      <tr><td>1</td><td>Ravi</td><td>Maths</td><td>10A</td></tr>
      <tr><td>1</td><td>Ravi</td><td>Maths</td><td>10B</td></tr>
      <tr><td>1</td><td>Ravi</td><td>Science</td><td>10A</td></tr>
      <tr><td>1</td><td>Ravi</td><td>Science</td><td>10B</td></tr>
    </tbody>
  </table>

  <p><strong>Problem:</strong> The table mixes two independent many-to-many relationships:</p>
  <ul>
    <li>Teacher ‚Üí Subject (Ravi teaches Maths, Science)</li>
    <li>Teacher ‚Üí Class (Ravi handles 10A, 10B)</li>
  </ul>
  <p>This causes redundancy ‚Äî each combination of subject and class creates extra rows (cross-product effect).</p>

  <h3>Normalize to 4NF ‚Äî separate independent relationships</h3>
  <p>We split into two tables: one for which subjects a teacher teaches, and another for which classes they handle.</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">TeacherSubjects</caption>
    <thead><tr><th>teacher_id</th><th>subject</th></tr></thead>
    <tbody>
      <tr><td>1</td><td>Maths</td></tr>
      <tr><td>1</td><td>Science</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">TeacherClasses</caption>
    <thead><tr><th>teacher_id</th><th>class</th></tr></thead>
    <tbody>
      <tr><td>1</td><td>10A</td></tr>
      <tr><td>1</td><td>10B</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- Teachers table
CREATE TABLE Teachers (
  teacher_id INT PRIMARY KEY,
  teacher_name VARCHAR(100)
);

-- TeacherSubjects (teacher_id + subject form composite key)
CREATE TABLE TeacherSubjects (
  teacher_id INT,
  subject VARCHAR(50),
  PRIMARY KEY (teacher_id, subject),
  FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id)
);

-- TeacherClasses (teacher_id + class form composite key)
CREATE TABLE TeacherClasses (
  teacher_id INT,
  class VARCHAR(50),
  PRIMARY KEY (teacher_id, class),
  FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id)
);

-- Sample data
INSERT INTO Teachers VALUES (1, 'Ravi');

INSERT INTO TeacherSubjects VALUES
  (1, 'Maths'),
  (1, 'Science');

INSERT INTO TeacherClasses VALUES
  (1, '10A'),
  (1, '10B');
</code></pre>

  <h3>Why this fixes 4NF</h3>
  <ul>
    <li>Each table now represents one independent relationship.</li>
    <li>No multi-valued dependencies remain (subjects and classes are separate).</li>
    <li>Redundancy and unnecessary combinations are eliminated.</li>
  </ul>

  <h3>Quick checklist to confirm 4NF</h3>
  <ol>
    <li>Is the table already in BCNF?</li>
    <li>Does any key determine multiple independent multi-valued attributes? (If yes, separate them.)</li>
    <li>Does each table represent a single relationship type?</li>
  </ol>
</section>

<!-- 5NF ‚Äî Fifth Normal Form (copy this section only) -->
<section id="5nf">
  <h2>Normalization: <strong>5NF ‚Äî Fifth Normal Form</strong></h2>
  <p><em>Goal:</em> Eliminate <strong>join dependencies</strong> ‚Äî a table should not be decomposable into smaller tables that can be joined back together without data loss, unless necessary. Also known as <strong>Project-Join Normal Form (PJNF)</strong>.</p>

  <h3>What 5NF requires</h3>
  <ul>
    <li>Table must already be in <strong>4NF</strong>.</li>
    <li>All join dependencies must be implied by candidate keys.</li>
    <li>Each table should store facts that cannot be reconstructed by joining smaller tables without introducing redundancy.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 5NF</h3>
  <p>Consider a table showing which <strong>Suppliers</strong> supply which <strong>Products</strong> to which <strong>Projects</strong>.</p>

  <table>
    <thead>
      <tr><th>supplier</th><th>product</th><th>project</th></tr>
    </thead>
    <tbody>
      <tr><td>S1</td><td>P1</td><td>J1</td></tr>
      <tr><td>S1</td><td>P2</td><td>J1</td></tr>
      <tr><td>S1</td><td>P1</td><td>J2</td></tr>
      <tr><td>S2</td><td>P1</td><td>J1</td></tr>
    </tbody>
  </table>

  <p><strong>Observation:</strong> Supplier <code>S1</code> supplies products <code>P1</code> and <code>P2</code> for projects <code>J1</code> and <code>J2</code>. The relationships between supplier‚Äìproduct, supplier‚Äìproject, and product‚Äìproject can be independent but overlap redundantly here.</p>

  <p><strong>Problem:</strong> The table combines three independent relationships ‚Äî if we try to infer new combinations, it can cause spurious tuples when joining decomposed tables improperly.</p>

  <h3>Normalize to 5NF ‚Äî split by independent relationships</h3>
  <p>We decompose into three separate tables representing independent binary relationships:</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">SupplierProduct</caption>
    <thead><tr><th>supplier</th><th>product</th></tr></thead>
    <tbody>
      <tr><td>S1</td><td>P1</td></tr>
      <tr><td>S1</td><td>P2</td></tr>
      <tr><td>S2</td><td>P1</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">SupplierProject</caption>
    <thead><tr><th>supplier</th><th>project</th></tr></thead>
    <tbody>
      <tr><td>S1</td><td>J1</td></tr>
      <tr><td>S1</td><td>J2</td></tr>
      <tr><td>S2</td><td>J1</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">ProductProject</caption>
    <thead><tr><th>product</th><th>project</th></tr></thead>
    <tbody>
      <tr><td>P1</td><td>J1</td></tr>
      <tr><td>P1</td><td>J2</td></tr>
      <tr><td>P2</td><td>J1</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- SupplierProduct table
CREATE TABLE SupplierProduct (
  supplier VARCHAR(10),
  product VARCHAR(10),
  PRIMARY KEY (supplier, product)
);

-- SupplierProject table
CREATE TABLE SupplierProject (
  supplier VARCHAR(10),
  project VARCHAR(10),
  PRIMARY KEY (supplier, project)
);

-- ProductProject table
CREATE TABLE ProductProject (
  product VARCHAR(10),
  project VARCHAR(10),
  PRIMARY KEY (product, project)
);

-- sample data
INSERT INTO SupplierProduct VALUES
  ('S1', 'P1'), ('S1', 'P2'), ('S2', 'P1');

INSERT INTO SupplierProject VALUES
  ('S1', 'J1'), ('S1', 'J2'), ('S2', 'J1');

INSERT INTO ProductProject VALUES
  ('P1', 'J1'), ('P1', 'J2'), ('P2', 'J1');
</code></pre>

  <h3>Why this fixes 5NF</h3>
  <ul>
    <li>Each table now represents one independent relationship.</li>
    <li>No redundancy ‚Äî every combination can be reconstructed by proper joins if valid.</li>
    <li>Prevents insertion and deletion anomalies caused by overlapping relationships.</li>
  </ul>

  <h3>Quick checklist to confirm 5NF</h3>
  <ol>
    <li>Is the table already in 4NF?</li>
    <li>Can it be decomposed into smaller tables without losing information? (If yes, decompose.)</li>
    <li>Do all join dependencies come from candidate keys?</li>
  </ol>
</section>

<section id="6nf">
  <h2>üß© <code>6NF</code> ‚Äî Sixth Normal Form</h2>

  <h3>üìò Description</h3>
  <p>
    Sixth Normal Form (6NF) is the highest level of normalization used in databases.  
    It deals with <b>temporal data (time-variant data)</b> ‚Äî data that changes over time.  
    A table is in 6NF if it is in 5NF and <b>cannot be decomposed any further</b> without losing information, 
    especially when time-based attributes are involved.
  </p>

  <h3>üí° Rule</h3>
  <ul>
    <li>The table must already satisfy 5NF.</li>
    <li>Every non-trivial join dependency must be a consequence of candidate keys.</li>
    <li>Used to handle changes in attribute values over time efficiently.</li>
  </ul>

  <h3>üìä Example (Before 6NF)</h3>
  <p>Consider a table tracking employee department history:</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Emp_ID</th>
      <th>Dept_ID</th>
      <th>Start_Date</th>
      <th>End_Date</th>
      <th>Salary</th>
    </tr>
    <tr>
      <td>101</td>
      <td>D01</td>
      <td>2020-01-01</td>
      <td>2021-12-31</td>
      <td>45000</td>
    </tr>
    <tr>
      <td>101</td>
      <td>D02</td>
      <td>2022-01-01</td>
      <td>NULL</td>
      <td>50000</td>
    </tr>
  </table>

  <p>
    Here, both department and salary can change independently over time.
    The table mixes two time-dependent facts (department history and salary history),
    so it violates 6NF.
  </p>

  <h3>‚úÖ After Applying 6NF</h3>
  <p>We split the table into two separate time-dependent tables:</p>

  <h4>üìÑ Employee_Department</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Emp_ID</th>
      <th>Dept_ID</th>
      <th>Start_Date</th>
      <th>End_Date</th>
    </tr>
    <tr>
      <td>101</td>
      <td>D01</td>
      <td>2020-01-01</td>
      <td>2021-12-31</td>
    </tr>
    <tr>
      <td>101</td>
      <td>D02</td>
      <td>2022-01-01</td>
      <td>NULL</td>
    </tr>
  </table>

  <h4>üìÑ Employee_Salary</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Emp_ID</th>
      <th>Salary</th>
      <th>Start_Date</th>
      <th>End_Date</th>
    </tr>
    <tr>
      <td>101</td>
      <td>45000</td>
      <td>2020-01-01</td>
      <td>2021-12-31</td>
    </tr>
    <tr>
      <td>101</td>
      <td>50000</td>
      <td>2022-01-01</td>
      <td>NULL</td>
    </tr>
  </table>

  <h3>üìà SQL Example</h3>
  <pre><code class="language-sql">
CREATE TABLE Employee_Department (
  Emp_ID INT,
  Dept_ID VARCHAR(10),
  Start_Date DATE,
  End_Date DATE
);

CREATE TABLE Employee_Salary (
  Emp_ID INT,
  Salary DECIMAL(10,2),
  Start_Date DATE,
  End_Date DATE
);
  </code></pre>

  <h3>üß† Summary</h3>
  <ul>
    <li>6NF is rarely used in practical systems.</li>
    <li>Mainly applies to temporal databases.</li>
    <li>It ensures each fact is stored in its smallest, indivisible form.</li>
  </ul>
</section>

<section id="normalization-summary">
  <h2>üßæ <code>Normalization Summary Table (1NF ‚Üí 6NF + BCNF)</code></h2>

  <table  cellspacing="0" cellpadding="8">
    <tr style="background:#f0f0f0;">
      <th>Normal Form</th>
      <th>Main Rule / Condition</th>
      <th>Removes</th>
      <th>Example Idea</th>
    </tr>

    <tr>
      <td><b>1NF</b> (First Normal Form)</td>
      <td>Each cell must contain only atomic (single) values.</td>
      <td>Repeating groups, multi-valued attributes.</td>
      <td>Splitting comma-separated phone numbers into rows.</td>
    </tr>

    <tr>
      <td><b>2NF</b> (Second Normal Form)</td>
      <td>Be in 1NF and remove partial dependencies.</td>
      <td>Partial dependency (non-key depends on part of composite key).</td>
      <td>Split student-course table so course details are stored separately.</td>
    </tr>

    <tr>
      <td><b>3NF</b> (Third Normal Form)</td>
      <td>Be in 2NF and remove transitive dependencies.</td>
      <td>Non-key depending on another non-key attribute.</td>
      <td>Move city & state info to a separate city table.</td>
    </tr>

    <tr>
      <td><b>BCNF</b> (Boyce‚ÄìCodd Normal Form / 3.5NF)</td>
      <td>Every determinant must be a candidate key.</td>
      <td>Dependency anomalies that 3NF can‚Äôt handle.</td>
      <td>Separate Professor ‚Üí Textbook and Subject ‚Üí Professor.</td>
    </tr>

    <tr>
      <td><b>4NF</b> (Fourth Normal Form)</td>
      <td>No multi-valued dependencies except candidate keys.</td>
      <td>Multi-valued dependency anomalies.</td>
      <td>Split student‚Äôs multiple skills and hobbies into different tables.</td>
    </tr>

    <tr>
      <td><b>5NF</b> (Fifth Normal Form)</td>
      <td>No join dependency ‚Äî data cannot be reconstructed incorrectly via joins.</td>
      <td>Join anomalies.</td>
      <td>Break down complex supplier‚Äìpart‚Äìproject relations.</td>
    </tr>

    <tr>
      <td><b>6NF</b> (Sixth Normal Form)</td>
      <td>Handle temporal (time-based) data; every fact is indivisible.</td>
      <td>Redundancy in time-variant data.</td>
      <td>Split employee‚Äôs department and salary history tables by time periods.</td>
    </tr>
  </table>

  <h3>üß† Quick Notes</h3>
  <ul>
    <li>1NF ‚Üí 3NF are most commonly used in real-world databases.</li>
    <li>BCNF fixes deeper dependency problems that 3NF misses.</li>
    <li>4NF‚Äì6NF are rare, used in specialized or temporal systems.</li>
  </ul>
</section>

<hr>
<section id="data-model">
  <h2>üß© <code>Data Model</code> ‚Äî In RDBMS</h2>

  <h3>üìò Description</h3>
  <p>
    A <b>Data Model</b> is a logical structure that defines how data is stored, organized, and related within a database.  
    It provides a blueprint for designing and implementing databases effectively.
  </p>
  <p>
    Simply put, a data model tells <b>how data is connected, stored, and accessed</b>.
  </p>

  <h3>üí° Purpose of Data Models</h3>
  <ul>
    <li>Defines structure and relationships between data.</li>
    <li>Improves consistency and data integrity.</li>
    <li>Acts as a communication bridge between developers, designers, and users.</li>
  </ul>

  <h3>üìä Types of Data Models</h3>

  <h4>1Ô∏è‚É£ Conceptual Data Model</h4>
  <p>
    - High-level model used for understanding data at the business level.  
    - Focuses on entities, relationships, and rules ‚Äî not technical details.  
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Concept</th><th>Description</th><th>Example</th></tr>
    <tr>
      <td>Entity</td>
      <td>Objects in the system</td>
      <td>Student, Course</td>
    </tr>
    <tr>
      <td>Relationship</td>
      <td>Association between entities</td>
      <td>Student <b>enrolls in</b> Course</td>
    </tr>
  </table>

  <h4>2Ô∏è‚É£ Logical Data Model</h4>
  <p>
    - Describes <b>how data is structured logically</b> ‚Äî includes tables, columns, and relationships.  
    - Independent of physical storage details.  
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Table</th><th>Columns</th></tr>
    <tr>
      <td>Student</td>
      <td>Student_ID, Name, Email</td>
    </tr>
    <tr>
      <td>Course</td>
      <td>Course_ID, Course_Name</td>
    </tr>
    <tr>
      <td>Enrollment</td>
      <td>Student_ID, Course_ID</td>
    </tr>
  </table>

  <h4>3Ô∏è‚É£ Physical Data Model</h4>
  <p>
    - Shows how data is physically stored in the database.  
    - Includes indexes, data types, constraints, and keys.  
  </p>

  <pre><code class="language-sql">
CREATE TABLE Student (
  Student_ID INT PRIMARY KEY,
  Name VARCHAR(50),
  Email VARCHAR(100)
);

CREATE TABLE Course (
  Course_ID INT PRIMARY KEY,
  Course_Name VARCHAR(50)
);

CREATE TABLE Enrollment (
  Student_ID INT,
  Course_ID INT,
  FOREIGN KEY (Student_ID) REFERENCES Student(Student_ID),
  FOREIGN KEY (Course_ID) REFERENCES Course(Course_ID)
);
  </code></pre>

  <h3>üß† Summary</h3>
  <ul>
    <li><b>Conceptual Model</b> ‚Äî High-level view (entities + relationships).</li>
    <li><b>Logical Model</b> ‚Äî Detailed structure (tables + columns).</li>
    <li><b>Physical Model</b> ‚Äî Implementation in the database (SQL schema).</li>
  </ul>
</section>

<hr>

<section id="er-model">
  <h2>üß© <code>E‚ÄìR Model</code> ‚Äî Entity Relationship Model</h2>

  <h3>üìò Description</h3>
  <p>
    The <b>Entity‚ÄìRelationship (E‚ÄìR) Model</b> is a high-level conceptual data model used to describe the structure of a database in terms of entities, attributes, and relationships.  
    It was proposed by <b>Peter Chen in 1976</b>.
  </p>

  <p>
    The E‚ÄìR model is often represented using an <b>ER diagram</b>, which visually shows how data is connected.
  </p>

  <h3>üí° Components of E‚ÄìR Model</h3>

  <h4>1Ô∏è‚É£ Entity</h4>
  <p>
    - An <b>entity</b> represents a real-world object or concept that can be distinctly identified.  
    - Each entity has a set of attributes.
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Entity Type</th><th>Description</th><th>Example</th></tr>
    <tr><td>Strong Entity</td><td>Has a primary key that uniquely identifies it.</td><td>Student, Course</td></tr>
    <tr><td>Weak Entity</td><td>Cannot be identified uniquely without a related strong entity.</td><td>Dependent of Employee</td></tr>
  </table>

  <h4>2Ô∏è‚É£ Attribute</h4>
  <p>
    - Attributes describe the properties or characteristics of an entity.
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Attribute Type</th><th>Description</th><th>Example</th></tr>
    <tr><td>Simple</td><td>Cannot be divided further</td><td>Name, Age</td></tr>
    <tr><td>Composite</td><td>Can be divided into smaller parts</td><td>Full_Name ‚Üí (First_Name, Last_Name)</td></tr>
    <tr><td>Derived</td><td>Can be derived from another attribute</td><td>Age (from DOB)</td></tr>
    <tr><td>Multivalued</td><td>Can have multiple values</td><td>Phone Numbers</td></tr>
  </table>

  <h4>3Ô∏è‚É£ Relationship</h4>
  <p>
    - A <b>relationship</b> represents the association between two or more entities.
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Description</th><th>Example</th></tr>
    <tr><td>One-to-One (1:1)</td><td>One entity is related to exactly one other entity.</td><td>Student ‚Üí ID Card</td></tr>
    <tr><td>One-to-Many (1:N)</td><td>One entity is related to many others.</td><td>Teacher ‚Üí Students</td></tr>
    <tr><td>Many-to-Many (M:N)</td><td>Many entities are related to many others.</td><td>Student ‚Üî Course</td></tr>
  </table>

  <h3>üß© Example</h3>
  <p><b>Entities:</b> Student, Course</p>
  <p><b>Relationship:</b> Student <code>enrolls in</code> Course</p>

  <pre><code class="language-text">
  [STUDENT] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ enrolls in ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [COURSE]
  </code></pre>

  <h4>üóÇÔ∏è Tables After Conversion</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr><th>Student</th><th>Attributes</th></tr>
    <tr><td>Student_ID (PK)</td><td>Name, Email</td></tr>
  </table>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Course</th><th>Attributes</th></tr>
    <tr><td>Course_ID (PK)</td><td>Course_Name</td></tr>
  </table>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Enrollment (Relation)</th><th>Attributes</th></tr>
    <tr><td>Student_ID (FK)</td><td>Course_ID (FK)</td></tr>
  </table>

  <h3>üß† Summary</h3>
  <ul>
    <li>üìç Entity ‚Üí Real-world object (e.g., Student, Course)</li>
    <li>üè∑Ô∏è Attribute ‚Üí Properties of entities (e.g., Name, Email)</li>
    <li>üîó Relationship ‚Üí Links entities together (e.g., Enrolls In)</li>
    <li>üí° ER Model helps in designing a clear database structure before implementation.</li>
  </ul>
</section>

<section id="er-model">
  <h2>üß© <code>E‚ÄìR Model</code> ‚Äî Entity Relationship Model (ER Model)</h2>

  <h3>üìò Description</h3>
  <p>
    The <b>Entity‚ÄìRelationship (E‚ÄìR) Model</b> is a high-level data model used to design the logical structure of a database.
    It visually represents <b>entities</b> (objects), their <b>attributes</b> (properties), and <b>relationships</b> (associations).
    It was introduced by <b>Peter Chen in 1976</b>.
  </p>

  <h3>üéØ Purpose</h3>
  <p>
    ‚û§ To create a simple and clear diagram of how data is stored and connected in a database before actual implementation.
  </p>

  <h3>üß© Components of ER Model</h3>

  <h4>1Ô∏è‚É£ Entity (Rectangle)</h4>
  <p>
    - An <b>Entity</b> represents a real-world object such as <code>Student</code>, <code>Course</code>, <code>Employee</code>, etc.  
    - Each entity has a set of <b>attributes</b> describing it.
  </p>
  <ul>
    <li>üü© <b>Rectangle:</b> Used to represent an Entity.</li>
    <li>üüß <b>Double Rectangle:</b> Used for a <b>Weak Entity</b> (depends on another entity).</li>
  </ul>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Symbol</th><th>Description</th><th>Example</th></tr>
    <tr><td>Strong Entity</td><td>‚¨ú Rectangle</td><td>Can exist independently</td><td>Student, Course</td></tr>
    <tr><td>Weak Entity</td><td>‚¨ú Double Rectangle</td><td>Depends on a strong entity</td><td>Dependent (of Employee)</td></tr>
  </table>

  <h4>2Ô∏è‚É£ Attributes (Oval)</h4>
  <p>
    - <b>Attributes</b> describe properties of entities or relationships.
  </p>
  <ul>
    <li>‚ö™ <b>Oval:</b> Represents an Attribute.</li>
    <li>‚ö™ <b>Double Oval:</b> Represents a <b>Multivalued Attribute</b>.</li>
    <li>‚ö™ <b>Dashed Oval:</b> Represents a <b>Derived Attribute</b>.</li>
    <li>‚ö™ <b>Oval with underline:</b> Represents a <b>Key Attribute</b>.</li>
  </ul>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Attribute Type</th><th>Symbol</th><th>Description</th><th>Example</th></tr>
    <tr><td>Simple</td><td>Oval</td><td>Cannot be divided further</td><td>Name, Age</td></tr>
    <tr><td>Composite</td><td>Linked Ovals</td><td>Can be divided into sub-parts</td><td>Full_Name ‚Üí (First, Last)</td></tr>
    <tr><td>Derived</td><td>Dashed Oval</td><td>Derived from another value</td><td>Age (from DOB)</td></tr>
    <tr><td>Multivalued</td><td>Double Oval</td><td>Can have multiple values</td><td>Phone Numbers</td></tr>
    <tr><td>Key Attribute</td><td>Underlined Oval</td><td>Uniquely identifies entity</td><td>Roll_No, Emp_ID</td></tr>
  </table>

  <h4>3Ô∏è‚É£ Relationship (Diamond)</h4>
  <p>
    - A <b>Relationship</b> connects two or more entities.
  </p>
  <ul>
    <li>üî∑ <b>Diamond:</b> Represents a Relationship.</li>
    <li>üî∑ <b>Double Diamond:</b> Represents a <b>Weak Relationship</b>.</li>
  </ul>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Symbol</th><th>Description</th><th>Example</th></tr>
    <tr><td>Regular Relationship</td><td>Diamond</td><td>Normal connection</td><td>Student ‚îÄ Enrolls ‚îÄ Course</td></tr>
    <tr><td>Weak Relationship</td><td>Double Diamond</td><td>Connects Weak Entity to Strong Entity</td><td>Dependent ‚îÄ Related_To ‚îÄ Employee</td></tr>
  </table>

  <h3>üîó Types of Relationships (Cardinality Ratios)</h3>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Notation</th><th>Description</th><th>Example</th></tr>
    <tr>
      <td>One-to-One</td>
      <td>1 : 1</td>
      <td>One entity of A is related to one entity of B</td>
      <td>Person ‚Üî Passport</td>
    </tr>
    <tr>
      <td>One-to-Many</td>
      <td>1 : N</td>
      <td>One entity of A is related to many entities of B</td>
      <td>Teacher ‚Üí Students</td>
    </tr>
    <tr>
      <td>Many-to-One</td>
      <td>N : 1</td>
      <td>Many entities of A are related to one entity of B</td>
      <td>Students ‚Üí Department</td>
    </tr>
    <tr>
      <td>Many-to-Many</td>
      <td>M : N</td>
      <td>Many entities of A are related to many entities of B</td>
      <td>Student ‚Üî Course</td>
    </tr>
  </table>

  <h3>üß± Participation Types</h3>
  <ul>
    <li>üî∏ <b>Total Participation:</b> All entities are involved in the relationship (represented by <b>double line</b>).</li>
    <li>üî∏ <b>Partial Participation:</b> Only some entities are involved (represented by <b>single line</b>).</li>
  </ul>

  <h3>üè∑Ô∏è Example ER Diagram Description</h3>
  <pre><code class="language-text">
  [STUDENT] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Enrolls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [COURSE]
        |                         |
     (Roll_No)                (Course_ID)
        |                         |
      (Name)                   (Course_Name)
  </code></pre>

  <h3>üß© Conversion to Tables</h3>
  <table  cellspacing="0" cellpadding="6">
    <tr><th>Entity</th><th>Attributes</th></tr>
    <tr><td>STUDENT</td><td>Roll_No (PK), Name, Age</td></tr>
    <tr><td>COURSE</td><td>Course_ID (PK), Course_Name</td></tr>
    <tr><td>ENROLLMENT</td><td>Roll_No (FK), Course_ID (FK)</td></tr>
  </table>

  <h3>üß† Summary</h3>
  <ul>
    <li>üü© Rectangle ‚Üí Entity</li>
    <li>‚¨ú Double Rectangle ‚Üí Weak Entity</li>
    <li>üî∑ Diamond ‚Üí Relationship</li>
    <li>üî∑ Double Diamond ‚Üí Weak Relationship</li>
    <li>‚ö™ Oval ‚Üí Attribute</li>
    <li>‚ö™ Double Oval ‚Üí Multivalued Attribute</li>
    <li>‚ö™ Dashed Oval ‚Üí Derived Attribute</li>
    <li>‚ö™ Underlined ‚Üí Key Attribute</li>
    <li>‚ûï Lines ‚Üí Connect entities and attributes</li>
    <li>‚ûï Double Line ‚Üí Total Participation</li>
    <li>‚ûï Single Line ‚Üí Partial Participation</li>
    <li>üî¢ Cardinalities ‚Üí 1:1, 1:N, N:1, M:N</li>
  </ul>

  <h3>üìò Advantages of ER Model</h3>
  <ul>
    <li>Easy to understand and visualize database structure.</li>
    <li>Helps in identifying entities, relationships, and attributes clearly.</li>
    <li>Used as a blueprint before creating physical database tables.</li>
  </ul>

  <h3>üß© Example Real-World Case</h3>
  <p>
    <b>Example:</b> In a school database ‚Äî  
    <code>Student</code> enrolls in <code>Course</code>, and each <code>Course</code> is taught by a <code>Teacher</code>.
  </p>

  <pre><code class="language-text">
  STUDENT (Roll_No, Name)
        |
        | Enrolls
        |
  COURSE (Course_ID, Course_Name)
        |
        | Taught_By
        |
  TEACHER (T_ID, T_Name)
  </code></pre>

</section>

<section id="er-attributes">
  <h2>üß© <code>Types of Attributes</code> ‚Äî in ER Model</h2>

  <h3>üìò Description</h3>
  <p>
    In an <b>Entity‚ÄìRelationship (ER) Model</b>, <b>Attributes</b> describe properties or characteristics of an <b>Entity</b> or <b>Relationship</b>.  
    Each attribute represents a <b>data field</b> that stores information about the entity.
  </p>
  <p>
    Example: For an entity <code>STUDENT</code>, attributes can be <code>Roll_No, Name, Age, Email</code>, etc.
  </p>

  <h3>üè∑Ô∏è Attribute Types</h3>

  <h4>1Ô∏è‚É£ Simple Attribute</h4>
  <p>
    ‚û§ Cannot be divided further.  
    ‚û§ Represented by a <b>single oval</b>.
  </p>
  <p><b>Example:</b> Name, Age, Gender</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îú‚îÄ‚îÄ (Name)
     ‚îú‚îÄ‚îÄ (Age)
     ‚îî‚îÄ‚îÄ (Gender)
  </code></pre>

  <h4>2Ô∏è‚É£ Composite Attribute</h4>
  <p>
    ‚û§ Can be divided into smaller sub-parts.  
    ‚û§ Represented by <b>oval connected to sub-ovals</b>.
  </p>
  <p><b>Example:</b> Full_Name ‚Üí (First_Name, Last_Name)</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îî‚îÄ‚îÄ (Full_Name)
             ‚îú‚îÄ‚îÄ (First_Name)
             ‚îî‚îÄ‚îÄ (Last_Name)
  </code></pre>

  <h4>3Ô∏è‚É£ Derived Attribute</h4>
  <p>
    ‚û§ Value can be derived from another attribute.  
    ‚û§ Represented by a <b>dashed oval</b>.
  </p>
  <p><b>Example:</b> Age derived from Date_of_Birth</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îú‚îÄ‚îÄ (DOB)
     ‚îî‚îÄ‚îÄ (---Age---)
  </code></pre>

  <h4>4Ô∏è‚É£ Multivalued Attribute</h4>
  <p>
    ‚û§ Can have multiple values for the same entity.  
    ‚û§ Represented by a <b>double oval</b>.
  </p>
  <p><b>Example:</b> Phone_Number can have more than one value for a student.</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îî‚ïê‚ïê (Phone_Number)
  </code></pre>

  <h4>5Ô∏è‚É£ Key Attribute</h4>
  <p>
    ‚û§ Uniquely identifies each entity in a set.  
    ‚û§ Represented by an <b>underlined oval</b>.
  </p>
  <p><b>Example:</b> Roll_No uniquely identifies each student.</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îú‚îÄ‚îÄ <u>Roll_No</u>
     ‚îú‚îÄ‚îÄ (Name)
     ‚îî‚îÄ‚îÄ (Email)
  </code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Type</th>
      <th>Symbol</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Simple Attribute</td>
      <td>Oval</td>
      <td>Cannot be divided further</td>
      <td>Name, Gender</td>
    </tr>
    <tr>
      <td>Composite Attribute</td>
      <td>Oval connected to sub-ovals</td>
      <td>Can be divided into sub-parts</td>
      <td>Full_Name ‚Üí First, Last</td>
    </tr>
    <tr>
      <td>Derived Attribute</td>
      <td>Dashed Oval</td>
      <td>Derived from other attributes</td>
      <td>Age (from DOB)</td>
    </tr>
    <tr>
      <td>Multivalued Attribute</td>
      <td>Double Oval</td>
      <td>Can have multiple values</td>
      <td>Phone_Number, Email_IDs</td>
    </tr>
    <tr>
      <td>Key Attribute</td>
      <td>Underlined Oval</td>
      <td>Uniquely identifies entity</td>
      <td>Roll_No, Emp_ID</td>
    </tr>
  </table>

  <h3>üß† Quick Summary</h3>
  <ul>
    <li>‚ö™ <b>Simple:</b> Single, indivisible value.</li>
    <li>‚ö™ <b>Composite:</b> Can be divided into smaller attributes.</li>
    <li>‚ö™ <b>Derived:</b> Calculated or derived from another attribute.</li>
    <li>‚ö™ <b>Multivalued:</b> Can have multiple values per entity.</li>
    <li>‚ö™ <b>Key:</b> Unique identifier of entity instances.</li>
  </ul>
</section>

<section id="er-entities">
  <h2>üß© <code>Types of Entities</code> ‚Äî in ER Model</h2>

  <h3>üìò Description</h3>
  <p>
    In the <b>Entity‚ÄìRelationship (ER) Model</b>, an <b>Entity</b> represents any real-world object, concept, or thing
    that can have data stored about it in a database.
  </p>
  <p>
    Example: <code>Student</code>, <code>Teacher</code>, <code>Course</code>, <code>Employee</code>.
  </p>

  <h3>üß© Classification of Entities</h3>

  <h4>1Ô∏è‚É£ Strong Entity (Independent Entity)</h4>
  <p>
    ‚û§ Exists independently and has its own <b>primary key</b>.  
    ‚û§ Represented by a <b>single rectangle</b> in ER diagram.
  </p>
  <p><b>Example:</b> STUDENT (Roll_No, Name, Email)</p>
  <pre><code class="language-text">
  [STUDENT]
     ‚îú‚îÄ‚îÄ Roll_No (PK)
     ‚îú‚îÄ‚îÄ Name
     ‚îî‚îÄ‚îÄ Email
  </code></pre>

  <h4>2Ô∏è‚É£ Weak Entity (Dependent Entity)</h4>
  <p>
    ‚û§ Cannot exist without being linked to a <b>Strong Entity</b>.  
    ‚û§ Does not have a unique key of its own ‚Äî identified by a <b>Partial Key</b>.  
    ‚û§ Represented by a <b>Double Rectangle</b>.  
    ‚û§ Linked with a <b>Double Diamond</b> to its owner (Strong Entity).
  </p>
  <p><b>Example:</b> DEPENDENT (Dependent_Name, Age) depends on EMPLOYEE (Emp_ID)</p>
  <pre><code class="language-text">
  [EMPLOYEE] ‚îÄ‚îÄ<‚©∏>‚îÄ‚îÄ [DEPENDENT]
     |                  |
   (Emp_ID)           (Dependent_Name, Age)
  </code></pre>

  <h4>3Ô∏è‚É£ Associative Entity (Bridge Entity)</h4>
  <p>
    ‚û§ Used to convert <b>many-to-many (M:N)</b> relationships into <b>two one-to-many (1:N)</b> relationships.  
    ‚û§ Has attributes of its own that describe the relationship.  
    ‚û§ Represented as a <b>rectangle inside a diamond</b>.
  </p>
  <p><b>Example:</b> ENROLLMENT connects STUDENT and COURSE.</p>
  <pre><code class="language-text">
  [STUDENT] ‚îÄ‚îÄ‚îÄ Enrolls ‚îÄ‚îÄ‚îÄ [COURSE]
         ‚Üò                ‚Üô
           [ENROLLMENT]
              ‚îú‚îÄ‚îÄ Roll_No (FK)
              ‚îú‚îÄ‚îÄ Course_ID (FK)
              ‚îî‚îÄ‚îÄ Date_of_Join
  </code></pre>

  <h4>4Ô∏è‚É£ Super Entity and Sub Entity (Generalization / Specialization)</h4>
  <p>
    ‚û§ Used when entities share common attributes but also have unique ones.  
    ‚û§ <b>Super Entity</b> (general) contains common attributes.  
    ‚û§ <b>Sub Entities</b> (specialized) contain unique attributes.  
    ‚û§ Represented using a <b>triangle</b> symbol for specialization/generalization.
  </p>
  <p><b>Example:</b> EMPLOYEE can be a TEACHER or an ADMIN.</p>
  <pre><code class="language-text">
        [EMPLOYEE]
          /     \
 [TEACHER]     [ADMIN]
  </code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Entity Type</th>
      <th>Symbol</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Strong Entity</td>
      <td>Single Rectangle</td>
      <td>Can exist independently</td>
      <td>Student, Employee</td>
    </tr>
    <tr>
      <td>Weak Entity</td>
      <td>Double Rectangle</td>
      <td>Depends on Strong Entity</td>
      <td>Dependent (of Employee)</td>
    </tr>
    <tr>
      <td>Associative Entity</td>
      <td>Rectangle inside Diamond</td>
      <td>Used in M:N relationships</td>
      <td>Enrollment between Student & Course</td>
    </tr>
    <tr>
      <td>Super Entity</td>
      <td>Rectangle connected to Triangle</td>
      <td>General (common) entity</td>
      <td>Employee</td>
    </tr>
    <tr>
      <td>Sub Entity</td>
      <td>Triangle to Rectangle</td>
      <td>Specialized version of super entity</td>
      <td>Teacher, Admin</td>
    </tr>
  </table>

  <h3>üß† Quick Summary</h3>
  <ul>
    <li>üü© <b>Strong Entity:</b> Exists independently (Single Rectangle).</li>
    <li>‚¨ú <b>Weak Entity:</b> Needs a strong entity to exist (Double Rectangle).</li>
    <li>üî∑ <b>Associative Entity:</b> Resolves M:N relationships.</li>
    <li>üî∫ <b>Super/Sub Entity:</b> Shows inheritance (Generalization/Specialization).</li>
  </ul>

  <h3>üìò Example Case</h3>
  <pre><code class="language-text">
  STUDENT (Roll_No, Name)
  COURSE (Course_ID, Title)
  ENROLLMENT (Roll_No, Course_ID, Grade)
  TEACHER (Emp_ID, Subject)
  ADMIN (Emp_ID, Department)
  </code></pre>

</section>
<section id="types-of-relationships">
  <h2>üîó <code>Types of Relationships in ER Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    In an <b>Entity Relationship (ER) Model</b>, a relationship defines how two or more entities are connected to each other.
    Relationships help represent <b>real-world associations</b> such as ‚ÄúStudent enrolls in Course‚Äù or ‚ÄúEmployee works in Department‚Äù.
  </p>

  <h3>üí† Relationship Symbols</h3>
  <ul>
    <li>üî∏ <b>Diamond (‚óä)</b> ‚Äî Represents a <b>relationship</b> between entities.</li>
    <li>üî∏ <b>Double Diamond (‚ß´‚ß´)</b> ‚Äî Used for <b>weak relationships</b> (when a weak entity depends on a strong entity).</li>
    <li>üî∏ <b>Rectangle ‚ñ≠</b> ‚Äî Represents an <b>entity</b>.</li>
    <li>üî∏ <b>Double Rectangle ‚ñ≠‚ñ≠</b> ‚Äî Represents a <b>weak entity</b>.</li>
    <li>üî∏ <b>Line</b> ‚Äî Connects entities and relationships.</li>
    <li>üî∏ <b>Oval (‚óØ)</b> ‚Äî Represents an <b>attribute</b>.</li>
    <li>üî∏ <b>Double Oval</b> ‚Äî Represents a <b>multivalued attribute</b>.</li>
    <li>üî∏ <b>Dashed Oval</b> ‚Äî Represents a <b>derived attribute</b>.</li>
  </ul>

  <h3>üß© Types of Relationships</h3>

  <h4>1Ô∏è‚É£ One-to-One (1:1)</h4>
  <p>
    In this type, <b>one entity</b> in set A is associated with <b>only one entity</b> in set B.
  </p>
  <pre><code>Example: Each person has one passport.</code></pre>
  <p><b>Diagram:</b> PERSON ‚ñ≠ ‚Äî‚Äî‚óä‚Äî‚Äî ‚ñ≠ PASSPORT</p>

  <h4>2Ô∏è‚É£ One-to-Many (1:N)</h4>
  <p>
    One entity from set A can be related to <b>many entities</b> in set B, but each entity in B is related to <b>only one</b> entity in A.
  </p>
  <pre><code>Example: One department has many employees.</code></pre>
  <p><b>Diagram:</b> DEPARTMENT ‚ñ≠ ‚Äî‚Äî‚óä‚Äî‚Äî<sub>(N)</sub> ‚ñ≠ EMPLOYEE</p>

  <h4>3Ô∏è‚É£ Many-to-One (N:1)</h4>
  <p>
    Many entities from set A are related to <b>one entity</b> in set B.
  </p>
  <pre><code>Example: Many employees work in one department.</code></pre>
  <p><b>Diagram:</b> EMPLOYEE ‚ñ≠<sub>(N)</sub> ‚Äî‚Äî‚óä‚Äî‚Äî ‚ñ≠ DEPARTMENT</p>

  <h4>4Ô∏è‚É£ Many-to-Many (M:N)</h4>
  <p>
    Entities from both sides can be related to multiple entities from the other side.
  </p>
  <pre><code>Example: A student can enroll in many courses, and each course can have many students.</code></pre>
  <p><b>Diagram:</b> STUDENT ‚ñ≠<sub>(M)</sub> ‚Äî‚Äî‚óä‚Äî‚Äî<sub>(N)</sub> ‚ñ≠ COURSE</p>

  <h4>5Ô∏è‚É£ Recursive (Unary) Relationship</h4>
  <p>
    A relationship between <b>the same entity set</b>. An entity is related to itself.
  </p>
  <pre><code>Example: An employee supervises another employee.</code></pre>
  <p><b>Diagram:</b> EMPLOYEE ‚ñ≠ ‚Äî‚Äî‚óä‚Äî‚Äî (supervises) ‚Äî‚Äî back to EMPLOYEE ‚ñ≠</p>

  <h4>6Ô∏è‚É£ Ternary Relationship</h4>
  <p>
    A relationship that involves <b>three entities</b> simultaneously.
  </p>
  <pre><code>Example: A Doctor prescribes a Drug to a Patient.</code></pre>
  <p><b>Diagram:</b> DOCTOR ‚ñ≠ ‚Äî‚Äî‚óä (prescribes) ‚óä‚Äî‚Äî ‚ñ≠ DRUG ‚Äî‚Äî‚óä‚Äî‚Äî ‚ñ≠ PATIENT</p>

  <h3>üìä Summary Table</h3>
  <table  cellpadding="5">
    <tr><th>Type</th><th>Meaning</th><th>Example</th></tr>
    <tr><td>1:1</td><td>One entity linked to exactly one other</td><td>Person ‚Üî Passport</td></tr>
    <tr><td>1:N</td><td>One entity linked to many others</td><td>Department ‚Üí Employees</td></tr>
    <tr><td>N:1</td><td>Many entities linked to one</td><td>Employees ‚Üí Department</td></tr>
    <tr><td>M:N</td><td>Many entities linked both ways</td><td>Student ‚Üî Course</td></tr>
    <tr><td>Unary</td><td>Entity linked to itself</td><td>Employee supervises Employee</td></tr>
    <tr><td>Ternary</td><td>Three entities linked</td><td>Doctor, Patient, Drug</td></tr>
  </table>

  <h3>üß† Quick Tip</h3>
  <p>
    üëâ If you see <b>double diamonds</b> or <b>double rectangles</b>, it means <b>weak entities or weak relationships</b> ‚Äî they depend on a strong entity for identification.
  </p>

</section>

<section id="participation-cardinality">
  <h2>üìè <code>Participation & Cardinality in ER Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    In an <b>Entity Relationship (ER) Model</b>, <b>cardinality</b> and <b>participation</b> describe how entities are related in a relationship set.
    They define <b>how many instances</b> of one entity can be associated with instances of another entity and whether participation is <b>mandatory or optional</b>.
  </p>

  <h3>üîπ Cardinality (Multiplicity)</h3>
  <p>
    Cardinality defines the <b>number of occurrences</b> of one entity that can be associated with another entity.
  </p>

  <h4>üí† Common Types</h4>
  <ul>
    <li><b>1:1 (One-to-One)</b> ‚Äî One entity of A is related to one entity of B.</li>
    <li><b>1:N (One-to-Many)</b> ‚Äî One entity of A can relate to many entities of B.</li>
    <li><b>N:1 (Many-to-One)</b> ‚Äî Many entities of A relate to one entity of B.</li>
    <li><b>M:N (Many-to-Many)</b> ‚Äî Many entities of A relate to many entities of B.</li>
  </ul>

  <h4>üìä Example</h4>
  <pre><code>Entity A: DEPARTMENT
Entity B: EMPLOYEE
Relationship: WORKS_IN
Cardinality: 1:N (One department has many employees)</code></pre>

  <table  cellpadding="5">
    <tr><th>Cardinality</th><th>Meaning</th><th>Example</th></tr>
    <tr><td>1:1</td><td>One entity of A ‚Üí one entity of B</td><td>Person ‚Üî Passport</td></tr>
    <tr><td>1:N</td><td>One entity of A ‚Üí many entities of B</td><td>Department ‚Üí Employees</td></tr>
    <tr><td>N:1</td><td>Many entities of A ‚Üí one entity of B</td><td>Employees ‚Üí Department</td></tr>
    <tr><td>M:N</td><td>Many entities of A ‚Üî many entities of B</td><td>Student ‚Üî Course</td></tr>
  </table>

  <h3>üî∏ Participation</h3>
  <p>
    Participation indicates whether <b>all entities</b> in a set take part in the relationship or only <b>some</b> of them do.
  </p>

  <h4>Types of Participation</h4>
  <ul>
    <li><b>Total Participation</b> ‚Äî Every entity in the set must participate in the relationship.<br>
      <i>Notation:</i> Double line between entity and relationship.<br>
      <i>Example:</i> Every employee must belong to a department.
    </li>
    <li><b>Partial Participation</b> ‚Äî Only some entities participate in the relationship.<br>
      <i>Notation:</i> Single line between entity and relationship.<br>
      <i>Example:</i> Some employees may not have a manager.
    </li>
  </ul>

  <h3>üìâ Min‚ÄìMax Notation</h3>
  <p>
    Another way to represent cardinality is the <b>(min, max)</b> notation, which defines the minimum and maximum number of relationships an entity can participate in.
  </p>

  <pre><code>Example:
STUDENT ‚îÄ‚îÄ (0, N) ENROLLS (1, 1) ‚îÄ‚îÄ COURSE

Meaning:
A student can enroll in zero or many courses.
A course must have at least one student.</code></pre>

  <table  cellpadding="5">
    <tr><th>Symbol</th><th>Meaning</th><th>Example</th></tr>
    <tr><td>(0,1)</td><td>Optional, at most one</td><td>Employee may manage at most one project</td></tr>
    <tr><td>(1,1)</td><td>Mandatory, exactly one</td><td>Each person must have one passport</td></tr>
    <tr><td>(0,N)</td><td>Optional, many</td><td>Student may enroll in many courses or none</td></tr>
    <tr><td>(1,N)</td><td>Mandatory, many</td><td>Department must have at least one employee</td></tr>
  </table>

  <h3>üß† Quick Tip</h3>
  <ul>
    <li>üí° <b>Total Participation</b> = double line connection.</li>
    <li>üí° <b>Partial Participation</b> = single line connection.</li>
    <li>üí° <b>Min‚ÄìMax notation</b> gives exact participation counts.</li>
  </ul>

</section>

<section id="generalization-specialization">
  <h2>üß≠ <code>Generalization, Specialization & Aggregation in ER Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    These are advanced concepts in the <b>Entity Relationship (ER) Model</b> that help simplify and organize complex data relationships.
    They are mainly used to represent <b>hierarchies and real-world inheritance</b> among entities.
  </p>

  <h3>üå≥ 1Ô∏è‚É£ Generalization</h3>
  <p>
    <b>Generalization</b> is the process of combining two or more entities with similar attributes into a <b>single, generalized (superclass) entity</b>.
  </p>
  <pre><code>Example:
Entities: Car, Bike
Common attributes ‚Üí Vehicle

Generalized Entity: Vehicle
Sub-entities: Car, Bike</code></pre>

  <h4>üí† Symbol</h4>
  <ul>
    <li>Shown using a <b>triangle (Œî)</b> pointing <b>upwards</b>.</li>
    <li>Superclass (generalized entity) at the <b>top</b>.</li>
    <li>Subclasses (specific entities) at the <b>bottom</b>.</li>
  </ul>

  <p><b>Diagram Representation:</b></p>
  <pre><code>     Vehicle
        ‚ñ≥
       / \
     Car  Bike</code></pre>

  <h3>üß© 2Ô∏è‚É£ Specialization</h3>
  <p>
    <b>Specialization</b> is the reverse of generalization. It creates <b>subclasses</b> from an existing <b>superclass</b> based on specific attributes.
  </p>
  <pre><code>Example:
Entity: Employee
Specialized entities:
  - Manager (has team)
  - Developer (has programming language)</code></pre>

  <h4>üí† Symbol</h4>
  <ul>
    <li>Shown using a <b>triangle (Œî)</b> pointing <b>downwards</b>.</li>
    <li>Superclass (general entity) at the <b>top</b>.</li>
    <li>Subclasses (special entities) at the <b>bottom</b>.</li>
  </ul>

  <p><b>Diagram Representation:</b></p>
  <pre><code>     Employee
        ‚ñΩ
       / \
  Manager  Developer</code></pre>

  <h3>üßÆ 3Ô∏è‚É£ Aggregation</h3>
  <p>
    <b>Aggregation</b> is an abstraction where a <b>relationship itself acts as an entity</b> and participates in another relationship.
    It is used when a relationship involves another relationship.
  </p>
  <pre><code>Example:
  A project is assigned to a department, and employees work on that project.
  The "Works_On" relationship between Employee and Project can be aggregated with Department.
  </code></pre>

  <h4>üí† Symbol</h4>
  <ul>
    <li>Represented by a <b>rectangle around a diamond</b>.</li>
    <li>Shows that a relationship is treated as a <b>higher-level entity</b>.</li>
  </ul>

  <p><b>Diagram Representation:</b></p>
  <pre><code>EMPLOYEE ‚îÄ‚îÄ‚óä Works_On ‚óä‚îÄ‚îÄ PROJECT
       ‚¨ö
        \
        DEPARTMENT</code></pre>

  <h3>üß± 4Ô∏è‚É£ Difference Summary</h3>
  <table  cellpadding="5">
    <tr>
      <th>Concept</th>
      <th>Direction</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Generalization</td>
      <td>Bottom ‚Üí Top</td>
      <td>Combine similar entities</td>
      <td>Car + Bike ‚Üí Vehicle</td>
    </tr>
    <tr>
      <td>Specialization</td>
      <td>Top ‚Üí Bottom</td>
      <td>Divide entity into sub-entities</td>
      <td>Employee ‚Üí Manager, Developer</td>
    </tr>
    <tr>
      <td>Aggregation</td>
      <td>Relationship ‚Üí Entity</td>
      <td>Represent relationship between relationships</td>
      <td>Works_On (Employee‚ÄìProject) linked with Department</td>
    </tr>
  </table>

  <h3>üß† Quick Tips</h3>
  <ul>
    <li>üîº <b>Generalization</b> ‚Äî Triangle points upward (merge entities).</li>
    <li>üîΩ <b>Specialization</b> ‚Äî Triangle points downward (split entity).</li>
    <li>‚¨ö <b>Aggregation</b> ‚Äî Rectangle around diamond (relationship as entity).</li>
  </ul>
</section>

<section id="mapping-er-to-relational">
  <h2>üó∫Ô∏è <code>Mapping ER Diagram to Relational Model (Conversion Rules)</code></h2>

  <h3>üìò Description</h3>
  <p>
    The process of <b>converting an ER (Entity‚ÄìRelationship) Diagram</b> into a <b>Relational Model</b> is known as 
    <b>ER-to-Relational Mapping</b>.  
    This step helps to transform a conceptual design (ERD) into a logical schema (tables in RDBMS).
  </p>

  <h3>‚öôÔ∏è Steps / Conversion Rules</h3>

  <h4>1Ô∏è‚É£ Mapping of Strong Entities</h4>
  <p>
    For every <b>strong entity</b> in the ER diagram, create a <b>table</b>.  
    Each <b>attribute</b> of the entity becomes a <b>column</b> of the table, and the <b>primary key</b> remains the same.
  </p>
  <pre><code>Entity: STUDENT (Student_ID, Name, Age)
‚Üí Table: STUDENT(Student_ID PRIMARY KEY, Name, Age)</code></pre>

  <h4>2Ô∏è‚É£ Mapping of Weak Entities</h4>
  <p>
    A <b>weak entity</b> cannot be identified by its own attributes, so it depends on a <b>strong entity</b>.
    Create a table for the weak entity and include the <b>primary key of the strong entity</b> as a <b>foreign key</b>.
  </p>
  <pre><code>Entity: DEPENDENT (Dep_Name, Age) depends on EMPLOYEE(Emp_ID)
‚Üí Table: DEPENDENT(Emp_ID, Dep_Name, Age, PRIMARY KEY(Emp_ID, Dep_Name),
   FOREIGN KEY(Emp_ID) REFERENCES EMPLOYEE(Emp_ID))</code></pre>

  <h4>3Ô∏è‚É£ Mapping 1:1 Relationships</h4>
  <p>
    For a <b>one-to-one relationship</b>, choose one side (preferably the side with total participation)
    and include the <b>primary key of the other entity</b> as a <b>foreign key</b>.
  </p>
  <pre><code>Entities: PERSON(Person_ID, Name), PASSPORT(Passport_No)
Relationship: Each person has one passport
‚Üí Add Person_ID as foreign key in PASSPORT table</code></pre>

  <h4>4Ô∏è‚É£ Mapping 1:N Relationships</h4>
  <p>
    For a <b>one-to-many relationship</b>, add the <b>primary key of the ‚Äúone‚Äù side</b> as a <b>foreign key</b> in the table of the ‚Äúmany‚Äù side.
  </p>
  <pre><code>Entities: DEPARTMENT(Dept_ID, Name), EMPLOYEE(Emp_ID, Name)
Relationship: One department has many employees
‚Üí Add Dept_ID as foreign key in EMPLOYEE table</code></pre>

  <h4>5Ô∏è‚É£ Mapping M:N Relationships</h4>
  <p>
    For a <b>many-to-many relationship</b>, create a <b>new table</b> that stores the primary keys of both entities as <b>foreign keys</b>.
    These two foreign keys together form the <b>composite primary key</b> of the new table.
  </p>
  <pre><code>Entities: STUDENT(Student_ID), COURSE(Course_ID)
Relationship: Enrolls
‚Üí Create table: ENROLLS(Student_ID, Course_ID, PRIMARY KEY(Student_ID, Course_ID),
   FOREIGN KEY(Student_ID) REFERENCES STUDENT(Student_ID),
   FOREIGN KEY(Course_ID) REFERENCES COURSE(Course_ID))</code></pre>

  <h4>6Ô∏è‚É£ Mapping Multivalued Attributes</h4>
  <p>
    For each <b>multivalued attribute</b>, create a <b>new table</b> containing:
    <ul>
      <li>The <b>attribute name</b> itself</li>
      <li>The <b>primary key</b> of the original entity</li>
    </ul>
    Both together form the <b>composite primary key</b>.
  </p>
  <pre><code>Entity: STUDENT(Student_ID, Phone_Number)
‚Üí Create new table: STUDENT_PHONE(Student_ID, Phone_Number,
   PRIMARY KEY(Student_ID, Phone_Number))</code></pre>

  <h4>7Ô∏è‚É£ Mapping Derived Attributes</h4>
  <p>
    Derived attributes (calculated values) are <b>not stored</b> in the relational model;
    they can be <b>computed using queries</b> when needed.
  </p>
  <pre><code>Example: Age (derived from DOB) ‚Üí Not stored in table.</code></pre>

  <h4>8Ô∏è‚É£ Mapping Ternary (or Higher-Order) Relationships</h4>
  <p>
    For relationships involving <b>three or more entities</b>, create a <b>separate table</b>
    containing the <b>primary keys of all participating entities</b> as foreign keys.
  </p>
  <pre><code>Example: DOCTOR prescribes DRUG to PATIENT
‚Üí Table: PRESCRIPTION(Doctor_ID, Drug_ID, Patient_ID, Date, Dose)</code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellpadding="5">
    <tr><th>ER Component</th><th>Relational Model Representation</th><th>Example</th></tr>
    <tr><td>Strong Entity</td><td>One table</td><td>STUDENT(Student_ID, Name)</td></tr>
    <tr><td>Weak Entity</td><td>Table + foreign key of owner</td><td>DEPENDENT(Emp_ID, Dep_Name)</td></tr>
    <tr><td>1:1 Relationship</td><td>Foreign key in one table</td><td>PASSPORT(Person_ID)</td></tr>
    <tr><td>1:N Relationship</td><td>Foreign key in "many" side</td><td>EMPLOYEE(Dept_ID)</td></tr>
    <tr><td>M:N Relationship</td><td>New relationship table</td><td>ENROLLS(Student_ID, Course_ID)</td></tr>
    <tr><td>Multivalued Attribute</td><td>New table with key + attribute</td><td>STUDENT_PHONE</td></tr>
    <tr><td>Derived Attribute</td><td>Not stored, computed via query</td><td>Age from DOB</td></tr>
    <tr><td>Ternary Relationship</td><td>New table with all keys</td><td>PRESCRIPTION</td></tr>
  </table>

  <h3>üß† Quick Tips</h3>
  <ul>
    <li>üí° Each <b>entity ‚Üí table</b>.</li>
    <li>üí° Each <b>relationship ‚Üí foreign key</b> or <b>new table</b>.</li>
    <li>üí° <b>Multivalued attributes</b> become separate tables.</li>
    <li>üí° <b>Derived attributes</b> are <b>not stored</b>.</li>
  </ul>

 
</section>

<hr>

<section id="relational-model">
  <h2>üßÆ <code>Relational Model in DBMS</code></h2>

  <h3>üìò Description</h3>
  <p>
    The <b>Relational Model</b> is the most widely used model in <b>Relational Database Management Systems (RDBMS)</b>.
    It represents data in the form of <b>tables (relations)</b>, where each table consists of <b>rows (tuples)</b> and <b>columns (attributes)</b>.
  </p>

  <h3>üß± Components of the Relational Model</h3>

  <h4>1Ô∏è‚É£ Relation (Table)</h4>
  <p>
    A <b>relation</b> is a <b>table</b> that stores data.  
    Each <b>row</b> in the table is called a <b>tuple</b> and represents a single record.
    Each <b>column</b> represents an <b>attribute</b>.
  </p>
  <pre><code>Example Table: STUDENT
+------------+----------+--------+
| Student_ID | Name     | Age    |
+------------+----------+--------+
| S1         | Arjun    | 21     |
| S2         | Priya    | 22     |
+------------+----------+--------+</code></pre>

  <h4>2Ô∏è‚É£ Tuple (Row)</h4>
  <p>
    A <b>tuple</b> is a single row in a relation that represents one record.
  </p>
  <pre><code>Example: (S1, Arjun, 21)</code></pre>

  <h4>3Ô∏è‚É£ Attribute (Column)</h4>
  <p>
    An <b>attribute</b> is a column that defines a property of the entity.
  </p>
  <pre><code>Example: Student_ID, Name, Age</code></pre>

  <h4>4Ô∏è‚É£ Domain</h4>
  <p>
    A <b>domain</b> is the set of all possible values that an attribute can take.
  </p>
  <pre><code>Example:
Attribute: Age
Domain: {18, 19, 20, 21, 22, 23, ...}</code></pre>

  <h4>5Ô∏è‚É£ Degree and Cardinality</h4>
  <ul>
    <li><b>Degree</b> ‚Üí Number of attributes (columns) in a relation.</li>
    <li><b>Cardinality</b> ‚Üí Number of tuples (rows) in a relation.</li>
  </ul>
  <pre><code>Example:
STUDENT(Student_ID, Name, Age)
‚Üí Degree = 3, Cardinality = 2</code></pre>

  <h4>6Ô∏è‚É£ Schema and Instance</h4>
  <ul>
    <li><b>Schema</b> ‚Äî Structure of the relation (table definition).</li>
    <li><b>Instance</b> ‚Äî Actual content or data present at a specific time.</li>
  </ul>
  <pre><code>Schema: STUDENT(Student_ID, Name, Age)
Instance:
+------------+----------+--------+
| Student_ID | Name     | Age    |
+------------+----------+--------+
| S1         | Arjun    | 21     |
| S2         | Priya    | 22     |
+------------+----------+--------+</code></pre>

  <h4>7Ô∏è‚É£ Keys</h4>
  <p>
    Keys are used to <b>uniquely identify</b> tuples in a relation and establish <b>relationships</b> between tables.
  </p>
  <ul>
    <li><b>Primary Key</b> ‚Äî Uniquely identifies each tuple.</li>
    <li><b>Foreign Key</b> ‚Äî Links one table to another.</li>
    <li><b>Candidate Key</b> ‚Äî Attributes that can act as primary keys.</li>
    <li><b>Alternate Key</b> ‚Äî Remaining candidate keys after choosing the primary key.</li>
    <li><b>Composite Key</b> ‚Äî Key made of two or more attributes.</li>
    <li><b>Super Key</b> ‚Äî Any key that can uniquely identify a tuple.</li>
  </ul>

  <h3>üß© Example</h3>
  <p><b>Entities:</b> STUDENT and COURSE</p>
  <pre><code>STUDENT(Student_ID, Name, Age, Course_ID)
COURSE(Course_ID, Course_Name)

Primary Key: Student_ID
Foreign Key: Course_ID (references COURSE table)</code></pre>

  <h3>üìä Relational Model Diagram</h3>
  <pre><code>+------------+-------------+
|  STUDENT   |  COURSE     |
+------------+-------------+
| Student_ID | Course_ID   |
| Name       | Course_Name |
| Age        |             |
+------------+-------------+
        ‚îÇ
        ‚îÇ (Foreign Key)
        ‚ñº
   COURSE.Course_ID</code></pre>

  <h3>üß† Characteristics of Relational Model</h3>
  <ul>
    <li>‚úÖ Data is stored in <b>tables (relations)</b>.</li>
    <li>‚úÖ Each table has a unique <b>primary key</b>.</li>
    <li>‚úÖ Data integrity is maintained using <b>keys</b> and <b>constraints</b>.</li>
    <li>‚úÖ Operations like <b>SELECT, INSERT, UPDATE, DELETE</b> are used to manipulate data.</li>
    <li>‚úÖ Relationships are established using <b>foreign keys</b>.</li>
  </ul>

  <h3>üß† Advantages</h3>
  <ul>
    <li>‚úîÔ∏è Simple and easy to understand (table-based).</li>
    <li>‚úîÔ∏è Ensures <b>data consistency</b> and <b>integrity</b>.</li>
    <li>‚úîÔ∏è Supports powerful <b>SQL operations</b>.</li>
    <li>‚úîÔ∏è Allows <b>relationships</b> between data.</li>
  </ul>

  <h3>‚ö†Ô∏è Disadvantages</h3>
  <ul>
    <li>‚ùå May be slower for very large or complex data (compared to NoSQL).</li>
    <li>‚ùå Requires <b>normalization</b> to reduce redundancy.</li>
    <li>‚ùå Not ideal for <b>hierarchical</b> or <b>graph-based</b> data.</li>
  </ul>
</section>

<hr>
<section id="buffer-management">
  <h2>üíæ <code>Buffer Management in DBMS</code></h2>

  <h3>üìò Description</h3>
  <p>
    <b>Buffer Management</b> is a crucial part of the <b>DBMS storage management system</b>.
    It is responsible for efficiently handling <b>data transfer between disk and main memory (RAM)</b> using a temporary storage area called the <b>Buffer Pool</b> or <b>Buffer Cache</b>.
  </p>

  <h3>üéØ Purpose</h3>
  <ul>
    <li>Reduce the number of <b>disk I/O operations</b>.</li>
    <li>Provide faster data access by keeping frequently used data in main memory.</li>
    <li>Improve overall <b>DBMS performance</b> and query speed.</li>
  </ul>

  <h3>‚öôÔ∏è How It Works</h3>
  <ol>
    <li>When a query requests data, DBMS checks if that data (page) exists in the <b>Buffer Pool</b>.</li>
    <li>If the page is found ‚Üí Data is fetched directly from memory (fast access).</li>
    <li>If not found ‚Üí DBMS loads it from the disk into an available buffer frame (slow access).</li>
    <li>If the buffer is full ‚Üí DBMS uses a <b>replacement policy</b> to decide which page to remove.</li>
    <li>Modified pages (called <b>dirty pages</b>) are written back to the disk before being replaced.</li>
  </ol>

  <h3>üß± Components of Buffer Management</h3>
  <table  cellspacing="0" cellpadding="5">
    <tr>
      <th>Component</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><b>Buffer Pool</b></td>
      <td>Reserved area in main memory where database pages are temporarily stored.</td>
    </tr>
    <tr>
      <td><b>Frame</b></td>
      <td>A single slot in the buffer pool that holds one page of data.</td>
    </tr>
    <tr>
      <td><b>Page Table</b></td>
      <td>Data structure that keeps track of which database pages are currently in the buffer.</td>
    </tr>
    <tr>
      <td><b>Dirty Page</b></td>
      <td>A page that has been modified in the buffer but not yet written to disk.</td>
    </tr>
  </table>

  <h3>üîÑ Buffer Replacement Policies</h3>
  <p>When the buffer pool is full, one of the following algorithms decides which page to remove:</p>
  <table  cellspacing="0" cellpadding="5">
    <tr>
      <th>Policy</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><b>LRU (Least Recently Used)</b></td>
      <td>Replaces the page that has not been used for the longest time.</td>
    </tr>
    <tr>
      <td><b>MRU (Most Recently Used)</b></td>
      <td>Replaces the page that was most recently accessed.</td>
    </tr>
    <tr>
      <td><b>FIFO (First In First Out)</b></td>
      <td>Replaces the page that entered the buffer first.</td>
    </tr>
    <tr>
      <td><b>LFU (Least Frequently Used)</b></td>
      <td>Removes the page that is used the least often.</td>
    </tr>
    <tr>
      <td><b>Clock Algorithm</b></td>
      <td>A circular list-based efficient version of LRU that uses reference bits to track usage.</td>
    </tr>
  </table>

  <h3>üßÆ Example</h3>
  <pre><code>Suppose the STUDENT table is stored on disk.
1Ô∏è‚É£ When a query requests data for a student record, DBMS checks if it‚Äôs in buffer.
2Ô∏è‚É£ If not, it loads the page from disk into a buffer frame.
3Ô∏è‚É£ After update, the page becomes ‚Äúdirty‚Äù.
4Ô∏è‚É£ When buffer is full, LRU policy may remove the least used page and write dirty pages back to disk.</code></pre>

  <h3>üöÄ Advantages</h3>
  <ul>
    <li>Reduces disk I/O operations (faster query execution).</li>
    <li>Improves CPU‚ÄìI/O overlap efficiency.</li>
    <li>Maintains data consistency through controlled write-back (dirty page handling).</li>
    <li>Enhances DBMS performance for large databases.</li>
  </ul>

  <h3>‚ö†Ô∏è Disadvantages</h3>
  <ul>
    <li>Requires careful tuning of buffer size for best performance.</li>
    <li>Dirty page handling adds complexity to transaction management.</li>
    <li>Poor replacement policy may cause frequent page faults.</li>
  </ul>

</section>

<hr>

 <h1>Relational Algebra vs SQL</h1>
  <table>
    <tr>
      <th>Relational Algebra</th>
      <th>Meaning</th>
      <th>SQL Equivalent</th>
    </tr>
    <tr>
      <td><b>œÉ (Sigma)</b></td>
      <td>Selection (choose rows)</td>
      <td><code>WHERE</code></td>
    </tr>
    <tr>
      <td><b>œÄ (Pi)</b></td>
      <td>Projection (choose columns)</td>
      <td><code>SELECT column_list</code></td>
    </tr>
    <tr>
      <td><b>‚ãà (Join)</b></td>
      <td>Combine two tables based on condition</td>
      <td><code>JOIN ... ON</code></td>
    </tr>
    <tr>
      <td><b>√ó (Cross Product)</b></td>
      <td>All combinations of rows</td>
      <td><code>CROSS JOIN</code></td>
    </tr>
    <tr>
      <td><b>‚à™ (Union)</b></td>
      <td>Combine rows from two queries (no duplicates)</td>
      <td><code>UNION</code></td>
    </tr>
    <tr>
      <td><b>‚à© (Intersection)</b></td>
      <td>Common rows between queries</td>
      <td><code>INTERSECT</code> (not in MySQL, use <code>INNER JOIN</code> + condition)</td>
    </tr>
    <tr>
      <td><b>‚àí (Set Difference)</b></td>
      <td>Rows in one relation but not in another</td>
      <td><code>EXCEPT</code> (not in MySQL, use <code>LEFT JOIN ... WHERE NULL</code>)</td>
    </tr>
    <tr>
      <td><b>œÅ (Rho)</b></td>
      <td>Rename relation/attribute</td>
      <td><code>AS</code></td>
    </tr>
  </table>
  


</body>  
</html>