<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>ReactJS</title>
     <style>
          body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      line-height: 1.6;
      padding: 20px;
      color: #333;
    max-width: 100%;
    word-wrap: break-word;
}

pre, table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}


    h1, h2, h3 {
      margin-top: 30px;
      border-left: 5px solid #ff6347;
      padding-left: 12px;
      color: #333;
    }

    h1 {
      font-size: 32px;
      color: #e91e63;
    }

    h2 {
      font-size: 26px;
      color: #3f51b5;
    }

    h3 {
      font-size: 22px;
      color: #009688;
    }

    pre {
      background: #eee;
      padding: 10px 15px;
      border-left: 5px solid #607d8b;
      white-space: pre-wrap;
      font-family: 'Consolas', monospace;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin: 4px 0;
    }

    .section {
      margin-bottom: 40px;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 10px;
      border-left: 4px solid #ffc107;
    }
    code {
  background-color: #f0f0f0;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 0.95em;
  color: #c7254e;
}
a {
  color: #007acc;
  text-decoration: none;
}
a:hover {
  text-decoration: underline;
}
hr {
  border: none;
  border-top: 1px solid #ccc;
  margin: 40px 0;
}
table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

th, td {
  border: 1px solid #ccc;
  padding: 10px;
  text-align: left;
}

th {
  background-color: #f2f2f2;
}

.button {
  background-color: #4CAF50;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  display: inline-block;
}

.button:hover {
  background-color: #45a049;
}

     </style>
</head>
<body>
<section>
  <h2>React – Introduction & JSX</h2>

  <!-- Introduction to React -->
  <h3>1. Introduction to React</h3>
  <p>
    React is a JavaScript library for building user interfaces, primarily for <b>Single Page Applications (SPA)</b>. It was developed by Facebook.
  </p>

  <ul>
    <li><b>Component-based:</b> UI is built using reusable components.</li>
    <li><b>Declarative:</b> You describe what UI should look like for a given state.</li>
    <li><b>Virtual DOM:</b> React uses a lightweight copy of the DOM to improve performance by updating only changed elements.</li>
    <li><b>One-way data binding:</b> Data flows from parent to child components via props.</li>
    <li><b>JSX:</b> JavaScript XML syntax to write HTML in JS.</li>
  </ul>

  <h4>Example: Basic React App</h4>
  <pre><code class="language-js">
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';

const App = () => {
    return (
        &lt;div&gt;
            &lt;h1&gt;Hello, React!&lt;/h1&gt;
            &lt;p&gt;Welcome to React tutorials.&lt;/p&gt;
        &lt;/div&gt;
    );
};

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(&lt;App /&gt;);
  </code></pre>

  <p>
    Output: <b>Hello, React! Welcome to React tutorials.</b>
  </p>

  <!-- JSX -->
  <h3>2. JSX (JavaScript XML)</h3>
  <p>
    JSX allows writing HTML-like syntax inside JavaScript. It is transformed to JavaScript by Babel before rendering.
  </p>

  <h4>Rules of JSX:</h4>
  <ul>
    <li>JSX must have a single root element.</li>
    <li>Use <code>className</code> instead of <code>class</code> for CSS.</li>
    <li>Use curly braces <code>{}</code> to embed JS expressions.</li>
    <li>Self-closing tags must end with <code>/&gt;</code>.</li>
  </ul>

  <h4>Example: JSX Expressions</h4>
  <pre><code class="language-js">
const name = "Aathi";
const age = 22;

const App = () =&gt; {
    return (
        &lt;div&gt;
            &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
            &lt;p&gt;You are {age} years old.&lt;/p&gt;
        &lt;/div&gt;
    );
};
  </code></pre>

  <h4>Example: Conditional Rendering in JSX</h4>
  <pre><code class="language-js">
const isLoggedIn = true;

const App = () =&gt; {
    return (
        &lt;div&gt;
            {isLoggedIn ? &lt;h1&gt;Welcome Back!&lt;/h1&gt; : &lt;h1&gt;Please Login&lt;/h1&gt;}
        &lt;/div&gt;
    );
};
  </code></pre>

  <h4>Example: Embedding Arrays in JSX</h4>
  <pre><code class="language-js">
const students = ["Aathi", "Mary", "John"];

const App = () =&gt; {
    return (
        &lt;ul&gt;
            {students.map((s, index) =&gt; &lt;li key={index}&gt;{s}&lt;/li&gt;)}
        &lt;/ul&gt;
    );
};
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Always use <code>key</code> prop when rendering lists to avoid warnings.</li>
      <li>JSX allows mixing JS and HTML cleanly for dynamic UIs.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – Components</h2>

  <!-- Introduction to Components -->
  <h3>1. What are Components?</h3>
  <p>
    Components are reusable pieces of UI in React. Every React app is built using components.
  </p>
  <ul>
    <li><b>Functional Components:</b> JS functions that return JSX.</li>
    <li><b>Class Components:</b> ES6 classes that extend <code>React.Component</code> and have state & lifecycle methods.</li>
    <li><b>Props:</b> Data passed from parent to child component.</li>
    <li><b>State:</b> Local data managed inside the component.</li>
  </ul>

  <!-- Functional Component -->
  <h3>2. Functional Component</h3>
  <pre><code class="language-js">
const Greeting = (props) =&gt; {
    return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
};

// Usage
const App = () =&gt; {
    return &lt;Greeting name="Aathi" /&gt;;
};
  </code></pre>

  <!-- Class Component -->
  <h3>3. Class Component</h3>
  <pre><code class="language-js">
import React, { Component } from 'react';

class Greeting extends Component {
    render() {
        return &lt;h1&gt;Hello, {this.props.name}!&lt;/h1&gt;;
    }
}

// Usage
const App = () =&gt; &lt;Greeting name="Aathi" /&gt;;
  </code></pre>

  <!-- Props -->
  <h3>4. Props (Properties)</h3>
  <p>
    Props are read-only data passed from parent to child component.
  </p>
  <pre><code class="language-js">
const Student = (props) =&gt; {
    return &lt;div&gt;
        &lt;h2&gt;Name: {props.name}&lt;/h2&gt;
        &lt;p&gt;Age: {props.age}&lt;/p&gt;
    &lt;/div&gt;;
};

const App = () =&gt; &lt;Student name="Aathi" age={22} /&gt;;
  </code></pre>

  <!-- State -->
  <h3>5. State</h3>
  <p>
    State is local, mutable data inside a component. Changing state triggers a re-render.
  </p>

  <h4>Functional Component with useState Hook</h4>
  <pre><code class="language-js">
import React, { useState } from 'react';

const Counter = () =&gt; {
    const [count, setCount] = useState(0);

    return &lt;div&gt;
        &lt;h1&gt;Count: {count}&lt;/h1&gt;
        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;;
};
  </code></pre>

  <h4>Class Component with State</h4>
  <pre><code class="language-js">
import React, { Component } from 'react';

class Counter extends Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }

    increment = () =&gt; {
        this.setState({ count: this.state.count + 1 });
    };

    render() {
        return &lt;div&gt;
            &lt;h1&gt;Count: {this.state.count}&lt;/h1&gt;
            &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;
        &lt;/div&gt;;
    }
}
  </code></pre>

  <!-- Component Lifecycle -->
  <h3>6. Component Lifecycle (Class Components)</h3>
  <ul>
    <li><b>Mounting:</b> Constructor → render → componentDidMount</li>
    <li><b>Updating:</b> render → componentDidUpdate</li>
    <li><b>Unmounting:</b> componentWillUnmount</li>
  </ul>

  <h4>Example: Lifecycle</h4>
  <pre><code class="language-js">
class Timer extends Component {
    constructor(props) {
        super(props);
        this.state = { time: 0 };
    }

    componentDidMount() {
        this.interval = setInterval(() =&gt; {
            this.setState({ time: this.state.time + 1 });
        }, 1000);
    }

    componentWillUnmount() {
        clearInterval(this.interval);
    }

    render() {
        return &lt;h1&gt;Time: {this.state.time}&lt;/h1&gt;;
    }
}
  </code></pre>

  <!-- Hooks -->
  <h3>7. React Hooks (Functional Components)</h3>
  <ul>
    <li><b>useState:</b> Manage state in functional components</li>
    <li><b>useEffect:</b> Side effects (componentDidMount, componentDidUpdate, componentWillUnmount)</li>
    <li><b>useRef:</b> Reference DOM elements or mutable values</li>
    <li><b>useContext:</b> Access context API values</li>
  </ul>

  <h4>useEffect Example</h4>
  <pre><code class="language-js">
import React, { useState, useEffect } from 'react';

const Timer = () =&gt; {
    const [time, setTime] = useState(0);

    useEffect(() =&gt; {
        const interval = setInterval(() =&gt; setTime(t =&gt; t + 1), 1000);
        return () =&gt; clearInterval(interval); // cleanup
    }, []); // empty array means run once on mount

    return &lt;h1&gt;Time: {time}&lt;/h1&gt;;
};
  </code></pre>

</section>


<section>
  <h2>React – Events, Conditional Rendering & Lists</h2>

  <!-- Events in React -->
  <h3>1. Handling Events</h3>
  <p>
    React handles events similarly to HTML, but with some differences:
  </p>
  <ul>
    <li>Event names are in <b>camelCase</b> (`onClick`, `onChange`).</li>
    <li>Functions are passed as references, not strings.</li>
    <li>React uses <b>Synthetic Events</b> for cross-browser compatibility.</li>
  </ul>

  <h4>Functional Component Example</h4>
  <pre><code class="language-js">
const App = () =&gt; {
    const handleClick = () =&gt; {
        alert("Button clicked!");
    };

    return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
};
  </code></pre>

  <h4>Class Component Example</h4>
  <pre><code class="language-js">
import React, { Component } from 'react';

class App extends Component {
    handleClick = () =&gt; {
        alert("Button clicked!");
    };

    render() {
        return &lt;button onClick={this.handleClick}&gt;Click Me&lt;/button&gt;;
    }
}
  </code></pre>

  <h4>Event Binding in Class Components</h4>
  <pre><code class="language-js">
class App extends Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
        this.increment = this.increment.bind(this); // binding method
    }

    increment() {
        this.setState({ count: this.state.count + 1 });
    }

    render() {
        return &lt;div&gt;
            &lt;h1&gt;Count: {this.state.count}&lt;/h1&gt;
            &lt;button onClick={this.increment}&gt;Increment&lt;/button&gt;
        &lt;/div&gt;;
    }
}
  </code></pre>

  <!-- Conditional Rendering -->
  <h3>2. Conditional Rendering</h3>
  <p>
    Conditional rendering allows components to render different UI based on state or props.
  </p>

  <h4>If-Else Example</h4>
  <pre><code class="language-js">
const App = () =&gt; {
    const isLoggedIn = true;

    if(isLoggedIn) {
        return &lt;h1&gt;Welcome Back!&lt;/h1&gt;;
    } else {
        return &lt;h1&gt;Please Login&lt;/h1&gt;;
    }
};
  </code></pre>

  <h4>Ternary Operator Example</h4>
  <pre><code class="language-js">
const App = () =&gt; {
    const isLoggedIn = false;
    return &lt;div&gt;
        {isLoggedIn ? &lt;h1&gt;Welcome&lt;/h1&gt; : &lt;h1&gt;Login&lt;/h1&gt;}
    &lt;/div&gt;;
};
  </code></pre>

  <h4>Logical AND (&&) Operator Example</h4>
  <pre><code class="language-js">
const App = () =&gt; {
    const showMessage = true;
    return &lt;div&gt;
        {showMessage && &lt;p&gt;This message is visible!&lt;/p&gt;}
    &lt;/div&gt;;
};
  </code></pre>

  <!-- Lists in React -->
  <h3>3. Rendering Lists Dynamically</h3>
  <p>
    Lists can be rendered using the <code>map()</code> function. Always include a unique <code>key</code> prop.
  </p>

  <h4>Example: List of Students</h4>
  <pre><code class="language-js">
const students = ["Aathi", "Mary", "John"];

const App = () =&gt; {
    return &lt;ul&gt;
        {students.map((student, index) =&gt; 
            &lt;li key={index}&gt;{student}&lt;/li&gt;
        )}
    &lt;/ul&gt;;
};
  </code></pre>

  <h4>Example: List of Objects</h4>
  <pre><code class="language-js">
const users = [
    {id: 1, name: "Aathi"},
    {id: 2, name: "Mary"},
    {id: 3, name: "John"}
];

const App = () =&gt; {
    return &lt;ul&gt;
        {users.map(user =&gt; &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;)}
    &lt;/ul&gt;;
};
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Using <code>index</code> as key is okay for static lists, but not recommended if the list changes dynamically.</li>
      <li>Keys help React identify which items changed, improving performance.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – Forms</h2>

  <!-- Introduction -->
  <h3>1. Forms in React</h3>
  <p>
    Forms in React are used to collect user input. There are two main types:
  </p>
  <ul>
    <li><b>Controlled Components:</b> React state controls form elements.</li>
    <li><b>Uncontrolled Components:</b> Form data is handled by the DOM itself using refs.</li>
  </ul>

  <!-- Controlled Components -->
  <h3>2. Controlled Components</h3>
  <p>
    In controlled components, form inputs derive their value from React state. Any change in input updates the state.
  </p>

  <h4>Example: Controlled Input</h4>
  <pre><code class="language-js">
import React, { useState } from 'react';

const ControlledForm = () =&gt; {
    const [name, setName] = useState("");

    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        alert("Submitted Name: " + name);
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;label&gt;Name: &lt;/label&gt;
            &lt;input 
                type="text" 
                value={name} 
                onChange={e =&gt; setName(e.target.value)} 
            /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};
  </code></pre>

  <!-- Uncontrolled Components -->
  <h3>3. Uncontrolled Components</h3>
  <p>
    Uncontrolled components store their own state in the DOM. React uses <code>ref</code> to access values.
  </p>

  <h4>Example: Uncontrolled Input</h4>
  <pre><code class="language-js">
import React, { useRef } from 'react';

const UncontrolledForm = () =&gt; {
    const nameRef = useRef();

    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        alert("Submitted Name: " + nameRef.current.value);
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;label&gt;Name: &lt;/label&gt;
            &lt;input type="text" ref={nameRef} /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};
  </code></pre>

  <!-- Form Validation -->
  <h3>4. Form Submission & Validation</h3>
  <p>
    Forms can be validated before submission using React state and event handling.
  </p>

  <h4>Example: Basic Validation</h4>
  <pre><code class="language-js">
import React, { useState } from 'react';

const ValidatedForm = () =&gt; {
    const [email, setEmail] = useState("");
    const [error, setError] = useState("");

    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        if(!email.includes("@")) {
            setError("Invalid email!");
        } else {
            setError("");
            alert("Submitted Email: " + email);
        }
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;label&gt;Email: &lt;/label&gt;
            &lt;input 
                type="text" 
                value={email} 
                onChange={e =&gt; setEmail(e.target.value)} 
            /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
            &lt;p style={{color: 'red'}}&gt;{error}&lt;/p&gt;
        &lt;/form&gt;
    );
};
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Controlled components are recommended for dynamic forms and validation.</li>
      <li>Uncontrolled components are simpler for quick forms without React state management.</li>
      <li>Always prevent default form submission using <code>e.preventDefault()</code>.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – Routing</h2>

  <!-- Introduction -->
  <h3>1. Setting up Routing</h3>
  <p>
    React Router is a library for handling navigation in React applications. It allows building **Single Page Applications (SPA)** with multiple views without reloading the page.
  </p>

  <p>Install React Router:</p>
  <pre><code class="language-bash">
npm install react-router-dom
  </code></pre>

  <!-- BrowserRouter, Routes, Route -->
  <h3>2. BrowserRouter, Routes, and Route</h3>
  <p>
    - <b>BrowserRouter:</b> Wraps the app and enables routing. <br>
    - <b>Routes:</b> Container for <code>Route</code> elements. <br>
    - <b>Route:</b> Defines a path and the component to render.
  </p>

  <h4>Example: Basic Routing</h4>
  <pre><code class="language-js">
import React from 'react';
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';

const Home = () =&gt; &lt;h1&gt;Home Page&lt;/h1&gt;;
const About = () =&gt; &lt;h1&gt;About Page&lt;/h1&gt;;

const App = () =&gt; {
    return (
        &lt;BrowserRouter&gt;
            &lt;nav&gt;
                &lt;Link to="/"&gt;Home&lt;/Link&gt; | 
                &lt;Link to="/about"&gt;About&lt;/Link&gt;
            &lt;/nav&gt;

            &lt;Routes&gt;
                &lt;Route path="/" element=&lt;Home /&gt; /&gt;
                &lt;Route path="/about" element=&lt;About /&gt; /&gt;
            &lt;/Routes&gt;
        &lt;/BrowserRouter&gt;
    );
};

export default App;
  </code></pre>

  <!-- Nested Routes -->
  <h3>3. Nested Routes</h3>
  <p>
    Nested routes allow defining child routes inside a parent route.
  </p>

  <h4>Example: Nested Routes</h4>
  <pre><code class="language-js">
import React from 'react';
import { BrowserRouter, Routes, Route, Link, Outlet } from 'react-router-dom';

const Dashboard = () =&gt; (
    &lt;div&gt;
        &lt;h1&gt;Dashboard&lt;/h1&gt;
        &lt;nav&gt;
            &lt;Link to="profile"&gt;Profile&lt;/Link&gt; | 
            &lt;Link to="settings"&gt;Settings&lt;/Link&gt;
        &lt;/nav&gt;
        &lt;Outlet /&gt;  {/* renders nested routes */}
    &lt;/div&gt;
);

const Profile = () =&gt; &lt;h2&gt;User Profile&lt;/h2&gt;;
const Settings = () =&gt; &lt;h2&gt;Settings&lt;/h2&gt;;

const App = () =&gt; (
    &lt;BrowserRouter&gt;
        &lt;Routes&gt;
            &lt;Route path="/dashboard" element=&lt;Dashboard /&gt;&gt;
                &lt;Route path="profile" element=&lt;Profile /&gt; /&gt;
                &lt;Route path="settings" element=&lt;Settings /&gt; /&gt;
            &lt;/Route&gt;
        &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
);

export default App;
  </code></pre>

  <!-- Navigation -->
  <h3>4. Navigation Programmatically</h3>
  <pre><code class="language-js">
import { useNavigate } from 'react-router-dom';

const Home = () =&gt; {
    const navigate = useNavigate();

    return &lt;button onClick={() =&gt; navigate('/about')}&gt;Go to About&lt;/button&gt;;
};
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Use <code>Link</code> instead of `&lt;a&gt;` tags to prevent page reload.</li>
      <li><code>Outlet</code> is used to render nested child routes.</li>
      <li>Programmatic navigation can be done using <code>useNavigate</code> hook.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – State Management</h2>

  <!-- Introduction -->
  <h3>1. Introduction to State Management</h3>
  <p>
    State management is used to handle and share data between components. React provides built-in state for local component data, and for larger apps we can use Context API or Redux.
  </p>

  <!-- Lifting State Up -->
  <h3>2. Lifting State Up</h3>
  <p>
    Lifting state up is the process of moving state from child components to the nearest common parent, so multiple children can share and modify the same data.
  </p>

  <h4>Example: Lifting State Up</h4>
  <pre><code class="language-js">
import React, { useState } from 'react';

const ChildA = ({ count }) =&gt; &lt;h2&gt;Child A Count: {count}&lt;/h2&gt;;
const ChildB = ({ increment }) =&gt; &lt;button onClick={increment}&gt;Increment&lt;/button&gt;;

const App = () =&gt; {
    const [count, setCount] = useState(0);

    const increment = () =&gt; setCount(count + 1);

    return (
        &lt;div&gt;
            &lt;ChildA count={count} /&gt;
            &lt;ChildB increment={increment} /&gt;
        &lt;/div&gt;
    );
};
  </code></pre>

  <!-- Context API -->
  <h3>3. Context API</h3>
  <p>
    Context API allows sharing data globally across components without passing props manually at every level.
  </p>

  <h4>Example: Context API</h4>
  <pre><code class="language-js">
import React, { createContext, useContext } from 'react';

const UserContext = createContext();

const Child = () =&gt; {
    const user = useContext(UserContext);
    return &lt;h2&gt;Hello, {user.name}&lt;/h2&gt;;
};

const App = () =&gt; {
    const user = { name: "Aathi" };

    return (
        &lt;UserContext.Provider value={user}&gt;
            &lt;Child /&gt;
        &lt;/UserContext.Provider&gt;
    );
};
  </code></pre>

  <!-- Redux (Basic Overview) -->
  <h3>4. Redux (Basic Overview)</h3>
  <p>
    Redux is a state management library used for predictable and centralized state. Main concepts:
  </p>
  <ul>
    <li><b>Store:</b> Holds the application state.</li>
    <li><b>Action:</b> Object describing a change in state.</li>
    <li><b>Reducer:</b> Function that updates state based on action.</li>
    <li><b>Dispatch:</b> Sends action to reducer to update state.</li>
  </ul>

  <h4>Example: Redux (Basic Counter)</h4>
  <pre><code class="language-js">
// actions.js
export const increment = () =&gt; ({ type: "INCREMENT" });
export const decrement = () =&gt; ({ type: "DECREMENT" });

// reducer.js
export const counterReducer = (state = 0, action) =&gt; {
    switch(action.type) {
        case "INCREMENT": return state + 1;
        case "DECREMENT": return state - 1;
        default: return state;
    }
};

// store.js
import { createStore } from 'redux';
import { counterReducer } from './reducer';
export const store = createStore(counterReducer);

// App.js
import React from 'react';
import { Provider, useSelector, useDispatch } from 'react-redux';
import { store } from './store';
import { increment, decrement } from './actions';

const Counter = () =&gt; {
    const count = useSelector(state =&gt; state);
    const dispatch = useDispatch();

    return (
        &lt;div&gt;
            &lt;h1&gt;Count: {count}&lt;/h1&gt;
            &lt;button onClick={() =&gt; dispatch(increment())}&gt;+&lt;/button&gt;
            &lt;button onClick={() =&gt; dispatch(decrement())}&gt;-&lt;/button&gt;
        &lt;/div&gt;
    );
};

const App = () =&gt; &lt;Provider store={store}&gt;&lt;Counter /&gt;&lt;/Provider&gt;;
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Lifting state up is simple for small apps.</li>
      <li>Context API is suitable for medium apps needing global state.</li>
      <li>Redux is preferred for large-scale apps requiring centralized predictable state.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – API Integration</h2>

  <!-- Introduction -->
  <h3>1. Introduction to API Integration</h3>
  <p>
    React apps often need to communicate with external APIs to fetch or send data. We can use <b>Fetch API</b> or <b>Axios</b> for HTTP requests. API calls are usually asynchronous.
  </p>

  <!-- Fetch API -->
  <h3>2. Fetch API</h3>
  <p>
    The Fetch API is a built-in JavaScript function to make HTTP requests.
  </p>

  <h4>Example: Fetch API</h4>
  <pre><code class="language-js">
import React, { useEffect, useState } from 'react';

const App = () =&gt; {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() =&gt; {
        fetch('https://jsonplaceholder.typicode.com/posts')
            .then(response =&gt; response.json())
            .then(json =&gt; {
                setData(json);
                setLoading(false);
            })
            .catch(error =&gt; console.error("Error:", error));
    }, []);

    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;

    return (
        &lt;div&gt;
            &lt;h1&gt;Posts&lt;/h1&gt;
            &lt;ul&gt;
                {data.map(post =&gt; &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};

export default App;
  </code></pre>

  <!-- Axios -->
  <h3>3. Axios</h3>
  <p>
    Axios is a popular third-party library for making HTTP requests. It returns promises and supports features like interceptors.
  </p>

  <p>Install Axios:</p>
  <pre><code class="language-bash">
npm install axios
  </code></pre>

  <h4>Example: Axios</h4>
  <pre><code class="language-js">
import React, { useEffect, useState } from 'react';
import axios from 'axios';

const App = () =&gt; {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() =&gt; {
        axios.get('https://jsonplaceholder.typicode.com/posts')
            .then(response =&gt; {
                setData(response.data);
                setLoading(false);
            })
            .catch(error =&gt; console.error("Error:", error));
    }, []);

    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;

    return (
        &lt;div&gt;
            &lt;h1&gt;Posts&lt;/h1&gt;
            &lt;ul&gt;
                {data.map(post =&gt; &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};

export default App;
  </code></pre>

  <!-- Handling Asynchronous Calls -->
  <h3>4. Handling Asynchronous Calls</h3>
  <p>
    Async/await can be used to handle asynchronous API calls in a cleaner way.
  </p>

  <h4>Example: Async/Await with Fetch</h4>
  <pre><code class="language-js">
import React, { useEffect, useState } from 'react';

const App = () =&gt; {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() =&gt; {
        const fetchData = async () =&gt; {
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts');
                const json = await response.json();
                setData(json);
                setLoading(false);
            } catch (error) {
                console.error("Error:", error);
            }
        };
        fetchData();
    }, []);

    if (loading) return &lt;h2&gt;Loading...&lt;/h2&gt;;

    return (
        &lt;div&gt;
            &lt;h1&gt;Posts&lt;/h1&gt;
            &lt;ul&gt;
                {data.map(post =&gt; &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};

export default App;
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Always handle errors using <code>catch</code> or <code>try/catch</code>.</li>
      <li>Loading state helps show feedback while data is being fetched.</li>
      <li>Axios simplifies requests with JSON parsing and additional features.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – Styling</h2>

  <!-- Introduction -->
  <h3>1. Introduction to Styling</h3>
  <p>
    React supports multiple ways to style components: inline styles, CSS modules, and third-party libraries like styled-components. Each method has its use cases.
  </p>

  <!-- Inline Styling -->
  <h3>2. Inline Styling</h3>
  <p>
    Inline styles are defined as JavaScript objects. Property names use camelCase instead of CSS hyphens.
  </p>

  <h4>Example: Inline Styling</h4>
  <pre><code class="language-js">
const App = () =&gt; {
    const headingStyle = {
        color: 'blue',
        backgroundColor: 'lightgray',
        padding: '10px',
        textAlign: 'center'
    };

    return &lt;h1 style={headingStyle}&gt;Hello, Inline Styling!&lt;/h1&gt;;
};
  </code></pre>

  <!-- CSS Modules -->
  <h3>3. CSS Modules</h3>
  <p>
    CSS Modules allow writing CSS with scoped class names to prevent conflicts.
  </p>

  <h4>Example: CSS Modules</h4>
  <pre><code class="language-js">
// App.module.css
.heading {
    color: green;
    background-color: #f0f0f0;
    padding: 10px;
    text-align: center;
}

// App.js
import React from 'react';
import styles from './App.module.css';

const App = () =&gt; &lt;h1 className={styles.heading}&gt;Hello, CSS Modules!&lt;/h1&gt;;

export default App;
  </code></pre>

  <!-- Styled-Components (Optional) -->
  <h3>4. Styled-Components</h3>
  <p>
    Styled-components is a library for writing CSS in JS using tagged template literals. Styles are scoped to components automatically.
  </p>

  <p>Install styled-components:</p>
  <pre><code class="language-bash">
npm install styled-components
  </code></pre>

  <h4>Example: Styled-Components</h4>
  <pre><code class="language-js">
import React from 'react';
import styled from 'styled-components';

const Heading = styled.h1`
    color: purple;
    background-color: #e0e0e0;
    padding: 10px;
    text-align: center;
`;

const App = () =&gt; &lt;Heading&gt;Hello, Styled Components!&lt;/Heading&gt;;

export default App;
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Inline styles are simple but limited (no pseudo-classes, media queries).</li>
      <li>CSS Modules provide scoped styles and prevent naming collisions.</li>
      <li>Styled-components enable dynamic styling with JS, good for complex apps.</li>
    </ul>
  </p>

</section>

<hr>

<section>
  <h2>React – Best Practices & Performance Optimization</h2>

  <!-- Component Organization -->
  <h3>1. Component Organization</h3>
  <p>
    Organize components logically to improve maintainability:
  </p>
  <ul>
    <li>Use a separate folder for components: <code>components/</code>.</li>
    <li>Divide into <b>Presentational (UI)</b> and <b>Container (Logic)</b> components.</li>
    <li>Keep files small and focused on a single responsibility.</li>
  </ul>

  <h4>Example Folder Structure</h4>
  <pre><code>
src/
  components/
    Header.js
    Footer.js
    Button.js
  containers/
    Dashboard.js
    UserProfile.js
  App.js
  index.js
  </code></pre>

  <!-- Avoiding Unnecessary Re-renders -->
  <h3>2. Avoiding Unnecessary Re-renders</h3>
  <p>
    Re-renders can hurt performance. Use memoization and React features to prevent unnecessary updates.
  </p>

  <h4>Example: React.memo</h4>
  <pre><code class="language-js">
import React, { useState, memo } from 'react';

const Child = memo(({ count }) =&gt; {
    console.log("Child re-rendered");
    return &lt;h2&gt;Count: {count}&lt;/h2&gt;;
});

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const [name, setName] = useState("");

    return (
        &lt;div&gt;
            &lt;Child count={count} /&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
            &lt;input value={name} onChange={e =&gt; setName(e.target.value)} /&gt;
        &lt;/div&gt;
    );
};

export default App;
  </code></pre>

  <p>
    Notes: <code>Child</code> re-renders only when <code>count</code> changes, not when <code>name</code> changes.
  </p>

  <!-- Key Prop in Lists -->
  <h3>3. Key Prop in Lists</h3>
  <p>
    Always provide a unique <code>key</code> prop for list items to help React track element changes efficiently.
  </p>

  <h4>Example: Keys in Lists</h4>
  <pre><code class="language-js">
const users = [
    {id: 1, name: "Aathi"},
    {id: 2, name: "Mary"},
];

const App = () =&gt; (
    &lt;ul&gt;
        {users.map(user =&gt; &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;)}
    &lt;/ul&gt;
);
  </code></pre>

  <p>
    Avoid using array index as key for dynamic lists because it can cause unexpected behavior when the list changes.
  </p>

  <!-- Optimizing Performance -->
  <h3>4. Optimizing Performance</h3>
  <ul>
    <li>Use <code>React.memo</code> for functional components to prevent unnecessary re-renders.</li>
    <li>Use <code>useMemo</code> to memoize expensive calculations.</li>
    <li>Use <code>useCallback</code> to memoize callback functions passed to child components.</li>
    <li>Lazy load components using <code>React.lazy</code> and <code>Suspense</code> for code splitting.</li>
  </ul>

  <h4>Example: useMemo</h4>
  <pre><code class="language-js">
import React, { useState, useMemo } from 'react';

const App = () =&gt; {
    const [count, setCount] = useState(0);
    const [text, setText] = useState("");

    const expensiveCalculation = useMemo(() =&gt; {
        console.log("Calculating...");
        return count * 2;
    }, [count]);

    return (
        &lt;div&gt;
            &lt;h2&gt;Count: {count}, Double: {expensiveCalculation}&lt;/h2&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
            &lt;input value={text} onChange={e =&gt; setText(e.target.value)} /&gt;
        &lt;/div&gt;
    );
};

export default App;
  </code></pre>

</section>

<hr>

<section>
  <h2>React – Advanced Topics</h2>

  <!-- React Hooks Deep Dive -->
  <h3>1. React Hooks Deep Dive</h3>
  <p>
    Beyond <code>useState</code> and <code>useEffect</code>, React provides additional hooks for advanced use cases:
  </p>
  <ul>
    <li><b>useRef:</b> Access DOM elements or persist values across renders.</li>
    <li><b>useReducer:</b> Manage complex state logic similar to Redux.</li>
    <li><b>useContext:</b> Access context values globally.</li>
    <li><b>useMemo:</b> Memoize expensive computations.</li>
    <li><b>useCallback:</b> Memoize callback functions to prevent unnecessary renders.</li>
  </ul>

  <h4>Example: useRef</h4>
  <pre><code class="language-js">
import React, { useRef } from 'react';

const App = () =&gt; {
    const inputRef = useRef();

    const focusInput = () =&gt; inputRef.current.focus();

    return (
        &lt;div&gt;
            &lt;input ref={inputRef} placeholder="Focus me" /&gt;
            &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
        &lt;/div&gt;
    );
};
export default App;
  </code></pre>

  <!-- Custom Hooks -->
  <h3>2. Custom Hooks</h3>
  <p>
    Custom hooks allow reusing logic across components. They start with <code>use</code>.
  </p>

  <h4>Example: Custom Hook for Window Width</h4>
  <pre><code class="language-js">
// useWindowWidth.js
import { useState, useEffect } from 'react';

export const useWindowWidth = () =&gt; {
    const [width, setWidth] = useState(window.innerWidth);

    useEffect(() =&gt; {
        const handleResize = () =&gt; setWidth(window.innerWidth);
        window.addEventListener('resize', handleResize);
        return () =&gt; window.removeEventListener('resize', handleResize);
    }, []);

    return width;
};

// App.js
import React from 'react';
import { useWindowWidth } from './useWindowWidth';

const App = () =&gt; {
    const width = useWindowWidth();
    return &lt;h1&gt;Window width: {width}&lt;/h1&gt;;
};
export default App;
  </code></pre>

  <!-- Higher-Order Components (HOC) -->
  <h3>3. Higher-Order Components (HOC)</h3>
  <p>
    HOCs are functions that take a component and return a new component with added functionality.
  </p>

  <h4>Example: HOC for Logging Props</h4>
  <pre><code class="language-js">
// withLogger.js
import React from 'react';
export const withLogger = (WrappedComponent) =&gt; {
    return (props) =&gt; {
        console.log("Props:", props);
        return &lt;WrappedComponent {...props} /&gt;;
    };
};

// App.js
import React from 'react';
import { withLogger } from './withLogger';

const Button = ({ label }) =&gt; &lt;button&gt;{label}&lt;/button&gt;;

export default withLogger(Button);
  </code></pre>

  <!-- React Suspense & Lazy Loading -->
  <h3>4. React Suspense & Lazy Loading</h3>
  <p>
    Lazy loading helps split code into smaller bundles and load components on demand. <code>React.Suspense</code> provides a fallback while the component loads.
  </p>

  <h4>Example: Lazy Loading</h4>
  <pre><code class="language-js">
import React, { Suspense, lazy } from 'react';

const LazyComponent = lazy(() =&gt; import('./LazyComponent'));

const App = () =&gt; (
    &lt;Suspense fallback=&lt;div&gt;Loading...&lt;/div&gt;&gt;
        &lt;LazyComponent /&gt;
    &lt;/Suspense&gt;
);

export default App;
  </code></pre>

  <p>
    Notes:
    <ul>
      <li>Custom hooks help keep logic DRY.</li>
      <li>HOCs enhance components without modifying them directly.</li>
      <li>Lazy loading improves performance by reducing initial bundle size.</li>
    </ul>
  </p>

</section>

<hr>

</body>
</html>
