<!DOCTYPE html>
<html lang="en">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Document</title>
     <style>
          body {
      background: #f9f9f9;
      font-family: 'Segoe UI', sans-serif;
      line-height: 1.6;
      padding: 20px;
      color: #333;
      max-width: 100%;
    word-wrap: break-word;
    }
pre, table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}

    code {
  background-color: #f0f0f0;
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Consolas', monospace;
  font-size: 0.95em;
  color: #c7254e;
}
    h1, h2, h3 {
      margin-top: 30px;
      border-left: 5px solid #ff6347;
      padding-left: 12px;
      color: #333;
    }

    h1 {
      font-size: 32px;
      color: #e91e63;
    }

    h2 {
      font-size: 26px;
      color: #3f51b5;
    }

    h3 {
      font-size: 22px;
      color: #009688;
    }

    pre {
      background: #eee;
      padding: 10px 15px;
      border-left: 5px solid #607d8b;
      white-space: pre-wrap;
      font-family: 'Consolas', monospace;
    }

    ul {
      padding-left: 20px;
    }

    li {
      margin: 4px 0;
    }

table { 
    width: 100%; 
    border-collapse: collapse; 
    margin: 15px 0; 
}

th, td { 
    border: 1px solid #ccc; 
    padding: 8px; 
    text-align: left; 
}

th { 
    background: #34495e; 
    color: white; 
}
    .section {
      margin-bottom: 40px;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 10px;
      border-left: 4px solid #ffc107;
    }
     </style>
</head>
<body>
  <div class="topic">
  <h2>Data</h2>
  <p>
    <b>Data</b> are the rawfacts(value) which describes attributes(properties) of an entity. It is raw facts and figures which have no context or meaning by themselves. 
    Example: numbers, names, dates, etc.
  </p>
  <p><b>Example:</b> "100", "Aathi", "2025-08-20"</p>
</div>

<div class="topic">
  <h2>Database</h2>
  <p>
    A <b>Database</b> are the place or a medium where we are storing the data in a systematic and organized manner. It is an organized collection of data stored electronically, 
    which can be easily accessed, managed, and updated.
  </p>
  <p><b>Example:</b> Student Management Database stores student details, marks, courses, etc.</p>
</div>

<div class="topic">
  <h2>DBMS (Database Management System)</h2>
  <p>
    <li>A <b>DBMS</b> is software that is used to create, manage, and manipulate databases. 
    It provides an interface between the user and the database.</li>
    <li>DBMS store the data in file format.</li>
    <li>To communicate with the DBMS we are using Query Language.</li>
  </p>
  <p><b>Examples:</b> MySQL, Oracle, SQL Server, PostgreSQL, SQLite</p>
</div>

<div class="topic">
  <h2>Types of DBMS</h2>
  <ul>
    <li><b>Hierarchical DBMS</b> ‚Üí Data organized in tree-like structure.</li>
    <li><b>Network DBMS</b> ‚Üí Data represented as records connected with links (graph).</li>
    <li><b>Relational DBMS (RDBMS)</b> ‚Üí Data stored in tables (rows and columns). Most commonly used.</li>
    <li><b>Object-Oriented DBMS</b> ‚Üí Stores objects along with data (used in advanced applications).</li>
  </ul>
</div>

<div class="topic">
  <h2>RDBMS (Relational Database Management System)</h2>
  <p>
    <li><b>RDBMS</b> is a type of DBMS where data is stored in tables, and relationships exist between tables 
    using <b>Primary Key</b> and <b>Foreign Key</b>.</li>
    <li>RDBMS store the data in table format.</li>
    <li>To communicate with the RDBMS we are using Structured Query Language.</li>
  </p>
  <p><b>Examples:</b> MySQL, Oracle, PostgreSQL, SQL Server</p>
</div>

  <div class="topic">
  <h2>Table</h2>
  <p>
    A <b>Table</b> is a collection of related data organized in <b>rows</b> and <b>columns</b>. 
    In an RDBMS, all data is stored inside tables.
  </p>
  <p><b>Example:</b> Employees table with columns like emp_id, name, salary, dept.</p>
</div>

<div class="topic">
  <h2>Row (Tuple / Record)</h2>
  <p>
    A <b>Row</b> represents a single record in a table. 
    Each row contains data for all columns of that table.
  </p>
  <p><b>Example:</b> In Employees table, one row can be: (1, 'Aathi', 50000, 'IT')</p>
</div>

<div class="topic">
  <h2>Column (Attribute / Field)</h2>
  <p>
    A <b>Column</b> represents a property of the table. 
    Each column has a name and a specific <b>data type</b>.
  </p>
  <p><b>Example:</b> In Employees table ‚Üí emp_id, name, salary, dept are columns.</p>
</div>

<div class="topic">
  <h2>Cell</h2>
  <p>
    A <b>Cell</b> is the intersection of a row and a column in a table. 
    It contains a single piece of data.
  </p>
  <p><b>Example:</b> In row (1, 'Aathi', 50000, 'IT'), the value 'Aathi' is a cell under column <i>name</i>.</p>
</div>

<div class="topic">
  <h2>E.F. Codd's Rules (RDBMS Rules)</h2>
  <li>A data entered in a cell must be a single value data or atomic.</li>
  <li>In RDBMS we are storing in table format along with the meta data</li>
  <li>We can store the data in multiple tables with the helps of key attributes.</li>
  <li>We validate the data entired in a cell by two steps, By assigning datatype and By assigning Constraints</li>
  <li>Datatype is manditory but constraints are optional.</li>
  <p>
    Dr. Edgar F. Codd, the father of RDBMS, proposed 13 rules (numbered 0 to 12) 
    that define what a true Relational Database Management System (RDBMS) should follow.
  </p>
  <ol>
    <li><b>Rule 0 ‚Äì Foundation Rule:</b> A system must use the relational model to manage data.</li>
    <li><b>Rule 1 ‚Äì Information Rule:</b> All information must be stored in tables (rows & columns).</li>
    <li><b>Rule 2 ‚Äì Guaranteed Access:</b> Each value must be accessible using table name, column name, and primary key.</li>
    <li><b>Rule 3 ‚Äì Systematic Treatment of Nulls:</b> The system must support NULL values to represent missing/unknown data.</li>
    <li><b>Rule 4 ‚Äì Active Online Catalog:</b> Database schema (metadata) must be stored within tables and accessible using SQL.</li>
    <li><b>Rule 5 ‚Äì Comprehensive Data Sub-language:</b> The system must support a single language (like SQL) for data definition, manipulation, and control.</li>
    <li><b>Rule 6 ‚Äì View Updating Rule:</b> All views that are theoretically updatable must be updatable by the system.</li>
    <li><b>Rule 7 ‚Äì High-level Operations:</b> Insert, update, delete, and select must work on sets of data (not just single rows).</li>
    <li><b>Rule 8 ‚Äì Physical Data Independence:</b> Changes in storage or access methods must not affect the logical structure of queries.</li>
    <li><b>Rule 9 ‚Äì Logical Data Independence:</b> Changes in table structure (like adding/removing columns) must not affect applications.</li>
    <li><b>Rule 10 ‚Äì Integrity Independence:</b> Integrity constraints (PK, FK, etc.) must be stored in the database, not in applications.</li>
    <li><b>Rule 11 ‚Äì Distribution Independence:</b> The system must work properly even if the database is distributed across different locations.</li>
    <li><b>Rule 12 ‚Äì Nonsubversion Rule:</b> Low-level operations must not bypass integrity and security constraints.</li>
  </ol>
</div>


<div class="topic">
  <h2>Data Types</h2>
  <p>
    Data types define the type of values a column can store. 
    In MySQL, data types are divided into:
  </p>
  <ul>
    <li><b>Numeric</b>: INT, BIGINT, DECIMAL, FLOAT, DOUBLE</li>
    <li><b>String</b>: CHAR, VARCHAR, TEXT, ENUM</li>
    <li><b>Date/Time</b>: DATE, TIME, DATETIME, TIMESTAMP, YEAR</li>
    <li><b>Other</b>: BOOLEAN, JSON</li>
  </ul>
</div>

<div class="topic">
  <h2>Constraints</h2>
  <p>
    <b>Constraints</b> are rules applied on columns to ensure valid data is entered into the table.
  </p>
  <ul>
    <li><b>NOT NULL</b> ‚Üí Column cannot store NULL values.</li>
    <li><b>UNIQUE</b> ‚Üí No duplicate values allowed in the column.</li>
    <li><b>PRIMARY KEY</b> ‚Üí Combines NOT NULL + UNIQUE; uniquely identifies each row.</li>
    <li><b>FOREIGN KEY</b> ‚Üí Creates relationship between two tables.</li>
    <li><b>CHECK</b> ‚Üí Ensures a condition is satisfied.</li>
    <li><b>DEFAULT</b> ‚Üí Assigns a default value if no value is given.</li>
  </ul>
  <pre>
-- Example
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    salary DECIMAL(10,2) CHECK (salary > 0),
    dept VARCHAR(30) DEFAULT 'IT',
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(emp_id)
);
  </pre>
</div>

<hr>


     <div class="topic">
  <h2>Introduction to SQL</h2>
  <p>
    <b>SQL (Structured Query Language)</b> is a standard language used to interact with relational databases. 
    It allows us to create, modify, and manage data in a database.
  </p>
  <ul>
    <li>SQL is used to <b>create</b> and <b>manage</b> database objects like tables, views, indexes.</li>
    <li>SQL is used to <b>insert</b>, <b>update</b>, <b>delete</b>, and <b>retrieve</b> data.</li>
    <li>SQL is supported by most databases: <b>MySQL, Oracle, PostgreSQL, SQLite, SQL Server</b>.</li>
  </ul>
</div>

<div class="topic">
  <h2>Types of SQL Commands</h2>
  <p>SQL commands are classified into the following categories:</p>
  <ul>
    <li><b>DDL (Data Definition Language)</b> ‚Üí Defines database structure
      <br>Examples: <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>TRUNCATE</code>, <code>RENAME</code>
    </li>
    <li><b>DML (Data Manipulation Language)</b> ‚Üí Manipulates data inside tables
      <br>Examples: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>
    </li>
    <li><b>DQL (Data Query Language)</b> ‚Üí Queries data
      <br>Example: <code>SELECT</code>
    </li>
    <li><b>TCL (Transaction Control Language)</b> ‚Üí Manages transactions
      <br>Examples: <code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>
    </li>
    <li><b>DCL (Data Control Language)</b> ‚Üí Controls access
      <br>Examples: <code>GRANT</code>, <code>REVOKE</code>
    </li>
  </ul>
</div>

<div class="topic">
  <h2>SQL Commands Overview</h2>
  <p>
    SQL commands are grouped into different categories based on their functionality. 
    The main categories are:
  </p>
</div>

<div class="topic">
  <h3>1. DDL (Data Definition Language)</h3>
  <p>
    Defines and manages the structure of the database (tables, views, indexes, etc.).
  </p>
  <ul>
    <li><b>CREATE</b> ‚Üí Create database objects (tables, views, indexes)</li>
    <li><b>ALTER</b> ‚Üí Modify existing table structure</li>
    <li><b>DROP</b> ‚Üí Delete database objects</li>
    <li><b>TRUNCATE</b> ‚Üí Remove all rows from a table (faster than DELETE)</li>
    <li><b>RENAME</b> ‚Üí Rename a table or column</li>
  </ul>
  <pre>
-- Example
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    salary DECIMAL(10,2)
);
  </pre>
</div>

<div class="topic">
  <h3>2. DML (Data Manipulation Language)</h3>
  <p>
    Deals with manipulation of data stored in tables.
  </p>
  <ul>
    <li><b>INSERT</b> ‚Üí Add new records into a table</li>
    <li><b>UPDATE</b> ‚Üí Modify existing records</li>
    <li><b>DELETE</b> ‚Üí Remove records</li>
  </ul>
  <pre>
-- Example
INSERT INTO employees (name, salary) VALUES ('Aathi', 50000);

UPDATE employees SET salary = 60000 WHERE name = 'Aathi';

DELETE FROM employees WHERE name = 'Aathi';
  </pre>
</div>

<div class="topic">
  <h3>3. DQL (Data Query Language)</h3>
  <p>
    Used to query and retrieve data from tables.
    <br>Has only one main command ‚Üí <b>SELECT</b>.
  </p>
  <ul>
    <li><b>Projection</b> ‚Üí Selecting specific columns</li>
    <li><b>Selection</b> ‚Üí Filtering rows using <code>WHERE</code></li>
    <li><b>Joins</b> ‚Üí Combining rows from multiple tables</li>
  </ul>
  <pre>
-- Example
SELECT name, salary FROM employees WHERE salary > 40000;
  </pre>
</div>

<div class="topic">
  <h3>4. TCL (Transaction Control Language)</h3>
  <p>
    Manages transactions and ensures database consistency.
  </p>
  <ul>
    <li><b>COMMIT</b> ‚Üí Save changes permanently</li>
    <li><b>ROLLBACK</b> ‚Üí Undo changes</li>
    <li><b>SAVEPOINT</b> ‚Üí Create intermediate points for rollback</li>
  </ul>
  <pre>
-- Example
DELETE FROM employees WHERE emp_id = 2;
ROLLBACK; -- undo delete
  </pre>
</div>

<div class="topic">
  <h3>5. DCL (Data Control Language)</h3>
  <p>
    Controls access and permissions to the database.
  </p>
  <ul>
    <li><b>GRANT</b> ‚Üí Provide privileges to users</li>
    <li><b>REVOKE</b> ‚Üí Remove privileges from users</li>
  </ul>
  <pre>
-- Example
GRANT SELECT, INSERT ON employees TO 'user1'@'localhost';

REVOKE INSERT ON employees FROM 'user1'@'localhost';
  </pre>
</div>

<hr>

<table cellpadding="5" cellspacing="0">
    <tr>
      <th>Category</th>
      <th>Purpose</th>
      <th>Commands</th>
    </tr>
    <tr>
      <td>DDL</td>
      <td>Define structure</td>
      <td>CREATE, ALTER, DROP, TRUNCATE, RENAME</td>
    </tr>
    <tr>
      <td>DML</td>
      <td>Manipulate data</td>
      <td>INSERT, UPDATE, DELETE</td>
    </tr>
    <tr>
      <td>DQL</td>
      <td>Query data</td>
      <td>SELECT</td>
    </tr>
    <tr>
      <td>TCL</td>
      <td>Manage transactions</td>
      <td>COMMIT, ROLLBACK, SAVEPOINT</td>
    </tr>
    <tr>
      <td>DCL</td>
      <td>Control access</td>
      <td>GRANT, REVOKE</td>
    </tr>
  </table>

  <hr>

<div class="topic">
  <h2>Basic SQL Syntax</h2>
  <pre>
-- Creating a Database
CREATE DATABASE company;

-- Using a Database
USE company;

-- Creating a Table
CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50),
    salary DECIMAL(10,2),
    dept VARCHAR(30)
);

-- Inserting Data
INSERT INTO employees (name, salary, dept)
VALUES ('Aathi', 50000, 'IT');

-- Querying Data
SELECT name, salary FROM employees WHERE dept = 'IT';
  </pre>
</div>

<hr>


<div class="topic">
  <h2>MySQL Data Types</h2>
  <p>
    Data types define the kind of values that can be stored in a column. 
    Choosing the correct data type ensures <b>accuracy, performance, and storage optimization</b>.
  </p>

  <h3>1. Numeric Data Types</h3>
  <ul>
    <li><b>TINYINT</b> ‚Üí Very small integers (Range: -128 to 127).  
      <br>Example: <code>TINYINT age;</code> ‚Üí 120</li>

    <li><b>SMALLINT</b> ‚Üí Small integers (Range: -32,768 to 32,767).  
      <br>Example: <code>SMALLINT year;</code> ‚Üí 2025</li>

    <li><b>INT / INTEGER</b> ‚Üí Standard integer (Range: -2,147,483,648 to 2,147,483,647).  
      <br>Example: <code>INT id;</code> ‚Üí 101</li>

    <li><b>BIGINT</b> ‚Üí Very large integers (Range: -2^63 to 2^63-1).  
      <br>Example: <code>BIGINT population;</code> ‚Üí 1400000000</li>

    <li><b>DECIMAL(p,s)</b> / <b>NUMERIC</b> ‚Üí Fixed-point numbers.  
      <br><b>p</b> = precision (total digits), <b>s</b> = scale (digits after decimal).  
      <br>Example: <code>DECIMAL(7,2) salary;</code> ‚Üí 12345.67</li>

    <li><b>FLOAT</b> ‚Üí Approximate decimal with single precision.  
      <br>Example: <code>FLOAT marks;</code> ‚Üí 89.56</li>

    <li><b>DOUBLE / REAL</b> ‚Üí Approximate decimal with double precision.  
      <br>Example: <code>DOUBLE distance;</code> ‚Üí 123456.789</li>
  </ul>
  <pre>
-- Example
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    price DECIMAL(8,2),     -- 6 digits before decimal, 2 after
    stock INT
);
  </pre>

  <h3>2. String Data Types</h3>
  <ul>
    <li><b>CHAR(n)</b> ‚Üí Fixed length string (pads with spaces if shorter).  
      <br>Example: <code>CHAR(5) code;</code> ‚Üí 'SQL  '</li>

    <li><b>VARCHAR(n)</b> ‚Üí Variable length string (saves space).  
      <br>Example: <code>VARCHAR(20) name;</code> ‚Üí 'Aathi'</li>

    <li><b>TEXT</b> ‚Üí Large text values.  
      <br>Types: <b>TINYTEXT</b> (255 chars), <b>TEXT</b> (65,535 chars), 
      <b>MEDIUMTEXT</b> (16M chars), <b>LONGTEXT</b> (4GB).  
      <br>Example: <code>TEXT description;</code></li>

    <li><b>BLOB (Binary Large Object)</b> ‚Üí Stores binary data (images, audio, video, files).  
      <br>Types: <b>TINYBLOB</b>, <b>BLOB</b>, <b>MEDIUMBLOB</b>, <b>LONGBLOB</b>.  
      <br>Example: <code>BLOB profile_pic;</code></li>

    <li><b>ENUM</b> ‚Üí One value from predefined list.  
      <br>Example: <code>ENUM('Male','Female','Other') gender;</code></li>

    <li><b>SET</b> ‚Üí Multiple values from predefined list (0‚Äì64 items).  
      <br>Example: <code>SET('Java','Python','SQL') skills;</code> ‚Üí 'Java,SQL'</li>
  </ul>
  <pre>
-- Example
CREATE TABLE students (
    name VARCHAR(50),
    grade CHAR(1),
    description TEXT,
    gender ENUM('Male','Female','Other')
);
  </pre>

  <h3>3. Date & Time Data Types</h3>
  <ul>
    <li><b>DATE</b> ‚Üí Stores date (YYYY-MM-DD).  
      <br>Example: <code>DATE dob;</code> ‚Üí '2001-05-20'</li>

    <li><b>TIME</b> ‚Üí Stores time (HH:MM:SS).  
      <br>Example: <code>TIME login_time;</code> ‚Üí '09:30:45'</li>

    <li><b>DATETIME</b> ‚Üí Stores date & time (YYYY-MM-DD HH:MM:SS).  
      <br>Example: <code>DATETIME order_time;</code> ‚Üí '2025-08-20 14:25:00'</li>

    <li><b>TIMESTAMP</b> ‚Üí Date & time (auto-updates when record changes).  
      <br>Example: <code>TIMESTAMP last_updated;</code></li>

    <li><b>YEAR</b> ‚Üí Year in 4-digit format.  
      <br>Example: <code>YEAR admission_year;</code> ‚Üí 2025</li>
  </ul>
  <pre>
-- Example
CREATE TABLE attendance (
    student_id INT,
    check_in DATETIME,
    check_out TIME,
    year_of_join YEAR
);
  </pre>

  <h3>4. Boolean & JSON</h3>
  <ul>
    <li><b>BOOLEAN</b> ‚Üí Stores TRUE/FALSE (internally treated as TINYINT 1 or 0).</li>
    <li><b>JSON</b> ‚Üí Stores JSON (JavaScript Object Notation) formatted data.</li>
  </ul>
  <pre>
-- Example
CREATE TABLE settings (
    id INT PRIMARY KEY AUTO_INCREMENT,
    is_active BOOLEAN,
    config JSON
);
  </pre>

</div>

<hr>

<div class="topic">
  <h2>SQL Constraints</h2>
  <p>
    Constraints are rules applied on table columns to restrict the type of data that can be stored. 
    They ensure accuracy, consistency, and reliability of the data in a database.
  </p>

  <h3>Types of Constraints</h3>
  <ul>
    <li><b>NOT NULL:</b> Ensures a column cannot have NULL values.</li>
    <li><b>UNIQUE:</b> Ensures all values in a column are unique (no duplicates).</li>
    <li><b>PRIMARY KEY:</b> A combination of NOT NULL + UNIQUE. Each table can have only one primary key.</li>
    <li><b>FOREIGN KEY:</b> Creates a link between two tables. Ensures referential integrity.</li>
    <li><b>CHECK:</b> Ensures that values in a column satisfy a specific condition.</li>
    <li><b>DEFAULT:</b> Assigns a default value to a column if no value is provided.</li>
    <li><b>AUTO_INCREMENT:</b> Automatically generates a unique number for each new row (mostly used with PRIMARY KEY).</li>
  </ul>

  <h3>Examples</h3>
  <pre>
-- Create table with constraints
CREATE TABLE Students (
  StudentID INT PRIMARY KEY AUTO_INCREMENT,
  Name VARCHAR(50) NOT NULL,
  Age INT CHECK (Age >= 18),
  Email VARCHAR(100) UNIQUE,
  CourseID INT,
  FOREIGN KEY (CourseID) REFERENCES Courses(CourseID),
  AdmissionDate DATE DEFAULT (CURRENT_DATE)
);
  </pre>

  <h3>Explanation of Example:</h3>
  <ul>
    <li><b>StudentID:</b> Primary key with auto-increment.</li>
    <li><b>Name:</b> Cannot be NULL.</li>
    <li><b>Age:</b> Must be 18 or above.</li>
    <li><b>Email:</b> Each student must have a unique email.</li>
    <li><b>CourseID:</b> Linked to CourseID column in Courses table (Foreign Key).</li>
    <li><b>AdmissionDate:</b> By default stores the current date.</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>Keys in SQL</h2>
  <p>
    A <b>Key</b> in SQL is an attribute (or a set of attributes) that helps identify records uniquely 
    in a table or establishes a relationship between tables.
  </p>

  <h3>Types of Keys</h3>
  <ul>
    <li>
      <b>Primary Key:</b>  
      - Uniquely identifies each record in a table.  
      - A table can have only one primary key (can consist of single or multiple columns).  
      - It cannot have NULL values.  
      <pre>
CREATE TABLE Students (
  StudentID INT PRIMARY KEY,
  Name VARCHAR(50) NOT NULL
);
      </pre>
    </li>
<hr>
    <li>
      <b>Foreign Key:</b>  
      - A column (or group of columns) in one table that refers to the <b>Primary Key</b> in another table.  
      - Enforces <b>Referential Integrity</b> between the two tables.  
      <pre>
CREATE TABLE Courses (
  CourseID INT PRIMARY KEY,
  CourseName VARCHAR(50)
);

CREATE TABLE Enrollments (
  EnrollID INT PRIMARY KEY,
  StudentID INT,
  CourseID INT,
  FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)
);
      </pre>
    </li>
<hr>
    <li>
      <b>Candidate Key:</b>  
      - All attributes (columns) that can uniquely identify a row.  
      - Out of these, one is chosen as the <b>Primary Key</b>, and others are called <b>Alternate Keys</b>.  
    </li>
    <p>
    Suppose we have a <b>Students</b> table:
  </p>
  <pre>
CREATE TABLE Students (
  StudentID INT,
  RollNo VARCHAR(20),
  Email VARCHAR(50),
  Name VARCHAR(50),
  PRIMARY KEY (StudentID)
);
  </pre>
  <p>
    In this table:  
    - <b>StudentID</b>, <b>RollNo</b>, and <b>Email</b> can all uniquely identify a student.  
    - So, all three are <b>Candidate Keys</b>.  
    - From these, one key (say <b>StudentID</b>) is chosen as the <b>Primary Key</b>.
  </p>
<hr>
    <li>
      <b>Alternate Key:</b>  
      - Any candidate key that is not chosen as the primary key.  
      - Still has the ability to uniquely identify rows.  
    </li>
    <p>
    Continuing from the same example:  
    - <b>StudentID</b> is chosen as the Primary Key.  
    - The remaining unique attributes (<b>RollNo</b> and <b>Email</b>) become <b>Alternate Keys</b>.  
  </p>

    
<hr>
    <li>
      <b>Super Key:</b>  
      - A set of one or more attributes that can uniquely identify a row.  
      - Every Primary Key is a Super Key, but not every Super Key is a Primary Key.  
    </li>
    <p>
    A <b>Super Key</b> is any set of attributes that can uniquely identify a record.  
  </p>
    <p>
    In the same <b>Students</b> table:  
  </p>
  <ul>
    <li>{StudentID}</li>
    <li>{RollNo}</li>
    <li>{Email}</li>
    <li>{StudentID, Name}</li>
    <li>{RollNo, Name}</li>
  </ul>
  <p>
    All the above are <b>Super Keys</b>, but the minimal ones (without extra attributes) are Candidate Keys.  
  </p>
  <p>
    So:  
    - <b>Candidate Keys</b> = {StudentID}, {RollNo}, {Email}  
    - <b>Super Keys</b> = {StudentID}, {RollNo}, {Email}, {StudentID, Name}, {RollNo, Name}, etc.  
    - Out of Candidate Keys, one is chosen as the <b>Primary Key</b> and the rest become <b>Alternate Keys</b>.
  </p>
  </ul>
<hr>
  <li>
      <b>Composite Key:</b>  
      - A key made up of two or more columns together that uniquely identify a row.  
      <pre>
CREATE TABLE OrderDetails (
  OrderID INT,
  ProductID INT,
  Quantity INT,
  PRIMARY KEY (OrderID, ProductID)
);
      </pre>
    </li>

  <hr>

  <h3>Primary Key vs Foreign Key</h3>
  <table cellpadding="8" cellspacing="0">
    <tr>
      <th>Primary Key</th>
      <th>Foreign Key</th>
    </tr>
    <tr>
      <td>Uniquely identifies each record in a table.</td>
      <td>Creates a link between two tables by referring to the Primary Key of another table.</td>
    </tr>
    <tr>
      <td>Cannot contain NULL values.</td>
      <td>Can contain NULL values (unless specified as NOT NULL).</td>
    </tr>
    <tr>
      <td>Each table can have only one Primary Key.</td>
      <td>A table can have multiple Foreign Keys.</td>
    </tr>
    <tr>
      <td>Ensures <b>entity integrity</b>.</td>
      <td>Ensures <b>referential integrity</b>.</td>
    </tr>
    <tr>
      <td>Values in primary key must be unique.</td>
      <td>Values may be duplicated if referencing multiple rows in another table.</td>
    </tr>
  </table>

  <h3>Referential Integrity Constraint</h3>
  <p>
    - Referential Integrity ensures that the relationship between tables remains consistent.  
    - It means that a Foreign Key in one table must always refer to an existing Primary Key in the parent table.  
  </p>
  <pre>
-- Example of Referential Integrity
INSERT INTO Enrollments (EnrollID, StudentID, CourseID)
VALUES (1, 101, 999);
-- ‚ùå Error: Cannot add or update because CourseID=999 does not exist in Courses table.
  </pre>
</div>

<hr>

<section id="keys-in-relational-model">
  <h2>üîë <code>Keys in Relational Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    Keys are special fields or combinations of fields used to <b>uniquely identify</b> each record (row) in a table and to establish <b>relationships</b> between tables.
  </p>

  <h3>üß± Types of Keys</h3>

  <h4>1Ô∏è‚É£ Super Key</h4>
  <p>
    A <b>Super Key</b> is a set of one or more attributes that can uniquely identify a record in a table.  
    Every <b>Primary Key</b> is a <b>Super Key</b>, but not every Super Key is minimal.
  </p>
  <pre><code>Example: {Student_ID}, {Student_ID, Name}</code></pre>

  <h4>2Ô∏è‚É£ Candidate Key</h4>
  <p>
    A <b>Candidate Key</b> is a minimal super key ‚Äî it has no unnecessary attributes.  
    A table can have multiple candidate keys, and one of them is chosen as the <b>Primary Key</b>.
  </p>
  <pre><code>Example: {Aadhar_No}, {Student_ID}</code></pre>

  <h4>3Ô∏è‚É£ Primary Key</h4>
  <p>
    A <b>Primary Key</b> is the key chosen from the candidate keys to uniquely identify records in a table.  
    It cannot have <b>NULL</b> or <b>duplicate</b> values.
  </p>
  <pre><code>Example: Student_ID</code></pre>

  <h4>4Ô∏è‚É£ Alternate Key</h4>
  <p>
    An <b>Alternate Key</b> is any candidate key that is <b>not selected</b> as the primary key.
  </p>
  <pre><code>Example: If Student_ID is Primary Key ‚Üí Aadhar_No becomes Alternate Key</code></pre>

  <h4>5Ô∏è‚É£ Foreign Key</h4>
  <p>
    A <b>Foreign Key</b> is an attribute (or set of attributes) in one table that refers to the <b>Primary Key</b> of another table.  
    It is used to maintain <b>referential integrity</b> between tables.
  </p>
  <pre><code>Example: Course_ID in STUDENT table refers to Course_ID in COURSE table</code></pre>

  <h4>6Ô∏è‚É£ Composite Key</h4>
  <p>
    A <b>Composite Key</b> is a combination of two or more columns that together uniquely identify a record in a table.  
    It is used when no single column can uniquely identify the record.
  </p>
  <pre><code>Example: (Student_ID, Course_ID)</code></pre>

  <h4>7Ô∏è‚É£ Unique Key</h4>
  <p>
    A <b>Unique Key</b> ensures that all values in a column (or group of columns) are <b>unique</b> but allows <b>one NULL</b> value.  
    Unlike the Primary Key, it is not mandatory for the column to always have a value.
  </p>
  <pre><code>Example: Email_ID (each student has a unique email)</code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellspacing="0" cellpadding="5">
    <tr>
      <th>Key Type</th>
      <th>Definition</th>
      <th>NULL Allowed</th>
      <th>Duplicate Allowed</th>
    </tr>
    <tr>
      <td>Super Key</td>
      <td>Set of attributes that uniquely identify a record</td>
      <td>‚ùå</td>
      <td>‚ùå</td>
    </tr>
    <tr>
      <td>Candidate Key</td>
      <td>Minimal super key (no unnecessary attributes)</td>
      <td>‚ùå</td>
      <td>‚ùå</td>
    </tr>
    <tr>
      <td>Primary Key</td>
      <td>Chosen candidate key to uniquely identify records</td>
      <td>‚ùå</td>
      <td>‚ùå</td>
    </tr>
    <tr>
      <td>Alternate Key</td>
      <td>Candidate key not chosen as primary key</td>
      <td>‚ùå</td>
      <td>‚ùå</td>
    </tr>
    <tr>
      <td>Foreign Key</td>
      <td>Refers to primary key in another table</td>
      <td>‚úÖ</td>
      <td>‚úÖ</td>
    </tr>
    <tr>
      <td>Composite Key</td>
      <td>Two or more attributes combined to uniquely identify a record</td>
      <td>‚ùå</td>
      <td>‚ùå</td>
    </tr>
    <tr>
      <td>Unique Key</td>
      <td>Ensures unique values but allows one NULL</td>
      <td>‚úÖ (one)</td>
      <td>‚ùå</td>
    </tr>
  </table>
</section>

<hr>

<div class="topic">
  <h2>ER Model Basics</h2>

  <h3>1. Entity</h3>
  <p>
    An <b>Entity</b> is a real-world object or concept that can be uniquely identified.  
    It can be a physical object (like <i>Student</i>, <i>Teacher</i>, <i>Car</i>) or a conceptual object (like <i>Course</i>, <i>Department</i>).  
  </p>
  <p>
    Example: <b>Student</b> is an entity.
  </p>

  <h3>2. Attributes</h3>
  <p>
    Attributes are the <b>properties</b> that describe an entity.  
    For example, the entity <b>Student</b> can have attributes:
  </p>
  <ul>
    <li>StudentID</li>
    <li>Name</li>
    <li>Email</li>
    <li>Phone</li>
  </ul>
  <p>
    <b>Types of Attributes:</b>
    <ul>
      <li><b>Simple</b> ‚Äì cannot be divided further (e.g., Name, Age).</li>
      <li><b>Composite</b> ‚Äì can be divided into smaller parts (e.g., FullName ‚Üí FirstName + LastName).</li>
      <li><b>Derived</b> ‚Äì values derived from other attributes (e.g., Age from DateOfBirth).</li>
      <li><b>Multivalued</b> ‚Äì can have multiple values (e.g., PhoneNumbers for a person).</li>
    </ul>
  </p>

  <h3>3. Relationships</h3>
  <p>
    A <b>Relationship</b> defines how two entities are connected.  
    Example:  
    - <b>Student</b> <i>enrolls in</i> <b>Course</b>  
    - <b>Teacher</b> <i>teaches</i> <b>Course</b>
  </p>

  <h3>4. Cardinality</h3>
  <p>
    <b>Cardinality</b> specifies the number of instances of one entity that can/must be associated with the number of instances of another entity.
  </p>
  <p>
    Types of Cardinality:
    <ul>
      <li><b>One-to-One (1:1)</b> ‚Äì One person has one passport.</li>
      <li><b>One-to-Many (1:N)</b> ‚Äì One teacher teaches many students.</li>
      <li><b>Many-to-One (N:1)</b> ‚Äì Many students belong to one department.</li>
      <li><b>Many-to-Many (M:N)</b> ‚Äì Students enroll in many courses, and each course has many students.</li>
    </ul>
  </p>
</div>

<hr>

<div class="topic">
  <h2>Normalization in DBMS</h2>

  <p>
    <b>Normalization</b> is the process of organizing data in a database to remove redundancy 
    and improve data integrity.  
    It divides larger tables into smaller ones and defines relationships between them.
  </p>

  <h3>Why Normalization?</h3>
  <ul>
    <li>To eliminate duplicate data.</li>
    <li>To reduce data redundancy and inconsistency.</li>
    <li>To make data retrieval efficient.</li>
    <li>To maintain data integrity.</li>
  </ul>

  <h3>Normal Forms</h3>
  <p>Normalization is done in stages called <b>Normal Forms (NF)</b>:</p>
  
  <h4>1. First Normal Form (1NF)</h4>
  <ul>
    <li>Each column must contain atomic (indivisible) values.</li>
    <li>No repeating groups or arrays allowed.</li>
  </ul>
  <p>
    Example:<br>
    ‚ùå Wrong: Student(ID, Name, Phone1, Phone2)<br>
    ‚úî Correct: Student(ID, Name, Phone)
  </p>

  <h4>2. Second Normal Form (2NF)</h4>
  <ul>
    <li>Table must be in 1NF.</li>
    <li>Functional dependency - All non-Primary key is depending on primary key column.</li>
    <li>No partial dependency ‚Äì every non-Primary key attribute must depend on the whole primary key.</li>
  </ul>
  <p>
    Example: If (StudentID, CourseID) is PK, then StudentName should not depend only on StudentID.
  </p>

  <h4>3. Third Normal Form (3NF)</h4>
  <ul>
    <li>Table must be in 2NF.</li>
    <li>No transitive dependency ‚Äì non-Primary key attributes should not depend on other non- Primary key attributes.</li>
  </ul>
  <p>
    Example:<br>
    ‚ùå Wrong: Student(ID, Name, DeptID, DeptName)<br>
    (DeptName depends on DeptID, not directly on StudentID)<br>
    ‚úî Correct: Separate Department table.
  </p>

  <h4>4. Boyce-Codd Normal Form (BCNF)</h4>
  <ul>
    <li>Stronger version of 3NF.</li>
    <li>Every determinant must be a candidate key.</li>
  </ul>

  <h3>Advantages of Normalization</h3>
  <ul>
    <li>Removes redundancy.</li>
    <li>Ensures data consistency.</li>
    <li>Makes database flexible and efficient.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li>Requires more joins while querying.</li>
    <li>Too many small tables may reduce performance in complex queries.</li>
  </ul>
</div>

<hr>

<section class="card">

    <h2>Normalization: <strong>1NF ‚Äî First Normal Form</strong></h2>
    <p class="note">Goal: Ensure that each table column holds <em>atomic</em> (indivisible) values and that each row is unique. 1NF is the foundation for higher normal forms.</p>

    <h3>What 1NF requires</h3>
    <ul>
      <li>Every column must contain atomic (single) values ‚Äî no repeating groups or arrays inside a column.</li>
      <li>Each row must be unique (usually enforced by a primary key).</li>
      <li>The order of rows and columns does not matter.</li>
    </ul>

    <h3 class="example-title">Example ‚Äî a table that <em>violates</em> 1NF</h3>
    <p class="note">Consider a simple <code>Students</code> table where phone numbers are stored as a comma-separated list in the <code>phones</code> column:</p>

    <table>
      <thead>
        <tr><th>student_id</th><th>name</th><th>phones</th></tr>
      </thead>
      <tbody>
        <tr><td>101</td><td>Asha</td><td>+91-99999-11111, +91-99999-22222</td></tr>
        <tr><td>102</td><td>Vikram</td><td>+91-88888-33333</td></tr>
        <tr><td>103</td><td>Meera</td><td>+91-77777-44444, +91-77777-55555, +91-77777-66666</td></tr>
      </tbody>
    </table>

    <p class="note">Problem: the <code>phones</code> column contains multiple values (lists). This violates 1NF because values are not atomic. It makes querying and indexing phone numbers difficult.</p>

    <h3 class="example-title">Normalized to 1NF ‚Äî make values atomic</h3>
    <p class="note">Split phone numbers into a separate table so each cell holds a single phone number and each row represents one student-phone relationship.</p>

    <table>
      <caption style="text-align:left;font-weight:600;margin-bottom:6px">Students</caption>
      <thead><tr><th>student_id</th><th>name</th></tr></thead>
      <tbody>
        <tr><td>101</td><td>Asha</td></tr>
        <tr><td>102</td><td>Vikram</td></tr>
        <tr><td>103</td><td>Meera</td></tr>
      </tbody>
    </table>

    <table>
      <caption style="text-align:left;font-weight:600;margin-bottom:6px">StudentPhones</caption>
      <thead><tr><th>phone_id</th><th>student_id</th><th>phone</th></tr></thead>
      <tbody>
        <tr><td>1</td><td>101</td><td>+91-99999-11111</td></tr>
        <tr><td>2</td><td>101</td><td>+91-99999-22222</td></tr>
        <tr><td>3</td><td>102</td><td>+91-88888-33333</td></tr>
        <tr><td>4</td><td>103</td><td>+91-77777-44444</td></tr>
        <tr><td>5</td><td>103</td><td>+91-77777-55555</td></tr>
        <tr><td>6</td><td>103</td><td>+91-77777-66666</td></tr>
      </tbody>
    </table>

    <h3 class="example-title">SQL example (create + insert)</h3>
    <pre><code>-- Students table (student_id is primary key)
CREATE TABLE Students (
  student_id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL
);

-- StudentPhones table (each row stores one phone number)
CREATE TABLE StudentPhones (
  phone_id INT PRIMARY KEY AUTO_INCREMENT,
  student_id INT NOT NULL,
  phone VARCHAR(30) NOT NULL,
  FOREIGN KEY (student_id) REFERENCES Students(student_id)
);

-- Insert sample data
INSERT INTO Students (student_id, name) VALUES (101, 'Asha'), (102, 'Vikram'), (103, 'Meera');
INSERT INTO StudentPhones (student_id, phone) VALUES
  (101, '+91-99999-11111'),
  (101, '+91-99999-22222'),
  (102, '+91-88888-33333'),
  (103, '+91-77777-44444'),
  (103, '+91-77777-55555'),
  (103, '+91-77777-66666');
</code></pre>

    <h3 class="example-title">Why 1NF matters</h3>
    <ul>
      <li>Queries like <code>WHERE phone = '...'</code> are simple and efficient when phones are atomic.</li>
      <li>Data integrity and indexing are much easier (each phone can be indexed separately).</li>
      <li>Prepares the schema for higher normal forms (2NF, 3NF, etc.).</li>
    </ul>

    <h3 class="example-title">Quick checklist to confirm 1NF</h3>
    <ol>
      <li>Are all columns atomic (no lists or sets inside a cell)?</li>
      <li>Is there a clear primary key to identify each row?</li>
      <li>Can you query/filter each value directly without string parsing?</li>
    </ol>

    <p class="note" style="margin-top:10px">That's 1NF ‚Äî would you like me to generate the next HTML file for <strong>2NF (Second Normal Form)</strong> now?</p>
  </section>
<section id="1nf-repeating-groups">
  <h2>üìò Understanding "No Repeating Groups" in <code>1NF</code></h2>

  <h3>üîπ What Does ‚ÄúNo Repeating Groups‚Äù Mean?</h3>
  <p>
    It does <b>not</b> mean you cannot have repeated values.  
    It means that you should <b>not create multiple columns to store the same type of data</b>.
  </p>
  <p>
    Each column must store <b>atomic (single) values</b>, and there should be only <b>one column per data type</b>.
  </p>

  <h3>‚ùå Example: Not in 1NF (Repeating Groups)</h3>
  <p>This table uses multiple columns for the same kind of data (phone numbers):</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Student_ID</th>
      <th>Name</th>
      <th>Phone1</th>
      <th>Phone2</th>
      <th>Phone3</th>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>98765...</td>
      <td>97543...</td>
      <td>98452...</td>
    </tr>
  </table>

  <p>
    üî∏ This violates 1NF because:
  </p>
  <ul>
    <li>There are <b>repeating groups</b> (Phone1, Phone2, Phone3).</li>
    <li>Columns are <b>not atomic</b> ‚Äî they represent multiple values for the same attribute.</li>
    <li>It‚Äôs hard to add or remove phone numbers without changing the table structure.</li>
  </ul>

  <h3>‚úÖ Example: In 1NF (No Repeating Groups)</h3>
  <p>Store each phone number as a separate row instead of separate columns:</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Student_ID</th>
      <th>Name</th>
      <th>Phone</th>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>98765...</td>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>97543...</td>
    </tr>
    <tr>
      <td>101</td>
      <td>Aathi</td>
      <td>98452...</td>
    </tr>
  </table>

  <p>
    üîπ Now the table is in <b>First Normal Form (1NF)</b> because:
  </p>
  <ul>
    <li>Each column has only <b>one value</b> per row.</li>
    <li>No repeating columns for the same attribute.</li>
    <li>Table structure is <b>flexible</b> ‚Äî you can add more phones by inserting new rows.</li>
  </ul>

  <h3>üß† Quick Summary</h3>
  <ul>
    <li>‚ùå ‚ÄúRepeating groups‚Äù ‚Üí multiple columns for same kind of data (e.g., Phone1, Phone2...)</li>
    <li>‚úÖ ‚ÄúNo repeating groups‚Äù ‚Üí one column, multiple rows if needed</li>
    <li>‚ùå Does <b>not</b> mean no repeated values ‚Äî duplicates are allowed if they represent valid data.</li>
  </ul>
</section>

  <!-- 2NF ‚Äî Second Normal Form (copy this section only) -->
<section id="2nf">
  <h2>Normalization: <strong>2NF ‚Äî Second Normal Form</strong></h2>
  <p><em>Goal:</em> Remove <strong>partial dependencies</strong> ‚Äî every non-key column must depend on the <strong>whole</strong> primary key, not just part of it. (Applies only when the table has a composite primary key.)</p>

  <h3>What 2NF requires</h3>
  <ul>
    <li>Table must already be in <strong>1NF</strong>.</li>
    <li>If the primary key is composite (more than one column), no non-key attribute may depend on only part of that key.</li>
    <li>Solve partial dependencies by splitting into separate tables so each non-key attribute depends on the full key.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 2NF (has partial dependency)</h3>
  <p>Imagine an <code>OrderDetails</code> table where the primary key is (<code>order_id</code>, <code>product_id</code>), but product-related info repeats:</p>

  <table>
    <thead>
      <tr><th>order_id</th><th>product_id</th><th>product_name</th><th>price</th><th>quantity</th></tr>
    </thead>
    <tbody>
      <tr><td>5001</td><td>101</td><td>Pen</td><td>10</td><td>2</td></tr>
      <tr><td>5001</td><td>102</td><td>Notebook</td><td>40</td><td>1</td></tr>
      <tr><td>5002</td><td>101</td><td>Pen</td><td>10</td><td>5</td></tr>
    </tbody>
  </table>

  <p><strong>Problem:</strong> <code>product_name</code> and <code>price</code> depend only on <code>product_id</code> (part of the composite key), not on the full key (<code>order_id, product_id</code>). This is a partial dependency ‚Üí violates 2NF.</p>

  <h3>Normalize to 2NF ‚Äî split into tables</h3>
  <p>Separate product details into a <code>Products</code> table; keep order-specific columns in <code>OrderDetails</code> (or <code>OrderItems</code>).</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Orders (example)</caption>
    <thead><tr><th>order_id</th><th>order_date</th><th>customer_id</th></tr></thead>
    <tbody>
      <tr><td>5001</td><td>2025-11-01</td><td>200</td></tr>
      <tr><td>5002</td><td>2025-11-02</td><td>201</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Products</caption>
    <thead><tr><th>product_id</th><th>product_name</th><th>price</th></tr></thead>
    <tbody>
      <tr><td>101</td><td>Pen</td><td>10</td></tr>
      <tr><td>102</td><td>Notebook</td><td>40</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">OrderItems (composite PK: order_id, product_id)</caption>
    <thead><tr><th>order_id</th><th>product_id</th><th>quantity</th></tr></thead>
    <tbody>
      <tr><td>5001</td><td>101</td><td>2</td></tr>
      <tr><td>5001</td><td>102</td><td>1</td></tr>
      <tr><td>5002</td><td>101</td><td>5</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- Products: product_id is primary key
CREATE TABLE Products (
  product_id INT PRIMARY KEY,
  product_name VARCHAR(100) NOT NULL,
  price DECIMAL(10,2) NOT NULL
);

-- Orders: order header
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  order_date DATE,
  customer_id INT
);

-- OrderItems: composite primary key (order_id, product_id)
CREATE TABLE OrderItems (
  order_id INT NOT NULL,
  product_id INT NOT NULL,
  quantity INT NOT NULL,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (order_id) REFERENCES Orders(order_id),
  FOREIGN KEY (product_id) REFERENCES Products(product_id)
);

-- sample data
INSERT INTO Products VALUES (101, 'Pen', 10.00), (102, 'Notebook', 40.00);
INSERT INTO Orders VALUES (5001, '2025-11-01', 200), (5002, '2025-11-02', 201);
INSERT INTO OrderItems VALUES (5001, 101, 2), (5001, 102, 1), (5002, 101, 5);
</code></pre>

  <h3>Why this fixes 2NF</h3>
  <ul>
    <li>Product attributes (<code>product_name</code>, <code>price</code>) now depend solely on <code>Products.product_id</code>, not on (<code>order_id, product_id</code>).</li>
    <li>Order-specific attributes (like <code>quantity</code>) depend on the full composite key (<code>order_id, product_id</code>) in <code>OrderItems</code>.</li>
    <li>This removes redundancy (product info stored once) and prevents update anomalies.</li>
  </ul>

  <h3>Quick checklist to confirm 2NF</h3>
  <ol>
    <li>Is the table already in <strong>1NF</strong>?</li>
    <li>Does the table use a composite primary key? If yes, check each non-key column ‚Äî does it depend on the full key or just part of it?</li>
    <li>If partial dependencies exist, split the table so each non-key column depends on the whole key.</li>
  </ol>
</section>

<!-- 3NF ‚Äî Third Normal Form (copy this section only) -->
<section id="3nf">
  <h2>Normalization: <strong>3NF ‚Äî Third Normal Form</strong></h2>
  <p><em>Goal:</em> Remove <strong>transitive dependencies</strong> ‚Äî every non-key attribute must depend <strong>only on the primary key</strong> and not on another non-key attribute.</p>

  <h3>What 3NF requires</h3>
  <ul>
    <li>Table must already be in <strong>2NF</strong>.</li>
    <li>No non-key attribute should depend on another non-key attribute (transitive dependency).</li>
    <li>Each non-key column should depend directly on the key and nothing else.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 3NF (has transitive dependency)</h3>
  <p>Consider an <code>Orders</code> table where <code>customer_city</code> depends on <code>customer_id</code> instead of directly on the primary key (<code>order_id</code>):</p>

  <table>
    <thead>
      <tr><th>order_id</th><th>customer_id</th><th>customer_name</th><th>customer_city</th><th>order_date</th></tr>
    </thead>
    <tbody>
      <tr><td>5001</td><td>201</td><td>Asha</td><td>Chennai</td><td>2025-11-01</td></tr>
      <tr><td>5002</td><td>202</td><td>Vikram</td><td>Delhi</td><td>2025-11-02</td></tr>
      <tr><td>5003</td><td>201</td><td>Asha</td><td>Chennai</td><td>2025-11-03</td></tr>
    </tbody>
  </table>

  <p><strong>Problem:</strong> <code>customer_name</code> and <code>customer_city</code> depend on <code>customer_id</code> (a non-key), not directly on <code>order_id</code>. This creates redundancy ‚Äî if a customer‚Äôs city changes, it must be updated in multiple rows.</p>

  <h3>Normalize to 3NF ‚Äî remove transitive dependency</h3>
  <p>Separate customer details into their own <code>Customers</code> table. Keep only <code>customer_id</code> in the <code>Orders</code> table.</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Customers</caption>
    <thead><tr><th>customer_id</th><th>customer_name</th><th>customer_city</th></tr></thead>
    <tbody>
      <tr><td>201</td><td>Asha</td><td>Chennai</td></tr>
      <tr><td>202</td><td>Vikram</td><td>Delhi</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">Orders</caption>
    <thead><tr><th>order_id</th><th>order_date</th><th>customer_id</th></tr></thead>
    <tbody>
      <tr><td>5001</td><td>2025-11-01</td><td>201</td></tr>
      <tr><td>5002</td><td>2025-11-02</td><td>202</td></tr>
      <tr><td>5003</td><td>2025-11-03</td><td>201</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- Customers table
CREATE TABLE Customers (
  customer_id INT PRIMARY KEY,
  customer_name VARCHAR(100) NOT NULL,
  customer_city VARCHAR(100)
);

-- Orders table
CREATE TABLE Orders (
  order_id INT PRIMARY KEY,
  order_date DATE,
  customer_id INT,
  FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);

-- Insert sample data
INSERT INTO Customers VALUES
  (201, 'Asha', 'Chennai'),
  (202, 'Vikram', 'Delhi');

INSERT INTO Orders VALUES
  (5001, '2025-11-01', 201),
  (5002, '2025-11-02', 202),
  (5003, '2025-11-03', 201);
</code></pre>

  <h3>Why this fixes 3NF</h3>
  <ul>
    <li>All non-key attributes in <code>Orders</code> now depend directly on <code>order_id</code>.</li>
    <li>Customer data is stored once in <code>Customers</code>, removing redundancy.</li>
    <li>Changing a customer‚Äôs city now requires updating only one record.</li>
  </ul>

  <h3>Quick checklist to confirm 3NF</h3>
  <ol>
    <li>Is the table already in 2NF?</li>
    <li>Does any non-key attribute depend on another non-key attribute? (If yes, move it to a separate table.)</li>
    <li>Do all non-key attributes depend directly on the key?</li>
  </ol>
</section>

<section id="bcnf">
  <h2>üß© <code>BCNF</code> ‚Äî Boyce‚ÄìCodd Normal Form (3.5NF)</h2>

  <h3>üìò Description</h3>
  <p>
    BCNF (Boyce‚ÄìCodd Normal Form), also known as <b>3.5 Normal Form</b>, is an advanced version of the Third Normal Form (3NF).  
    It removes anomalies that 3NF cannot handle by ensuring <b>every determinant is a candidate key</b>.
  </p>

  <h3>üí° Rule</h3>
  <ul>
    <li>The table must already satisfy 3NF.</li>
    <li>For every functional dependency <code>X ‚Üí Y</code>, <b>X must be a super key</b>.</li>
    <li>No dependency should exist where a non-prime attribute determines part of a candidate key.</li>
  </ul>

  <h3>üìä Example (Before BCNF)</h3>
  <p>Consider a table of university courses and professors:</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Professor</th>
      <th>Subject</th>
      <th>Textbook</th>
    </tr>
    <tr>
      <td>Dr. Smith</td>
      <td>Database</td>
      <td>DBMS by Korth</td>
    </tr>
    <tr>
      <td>Dr. Smith</td>
      <td>SQL</td>
      <td>DBMS by Korth</td>
    </tr>
  </table>

  <p>
    Functional dependencies:  
    <code>Professor ‚Üí Textbook</code> and <code>Subject ‚Üí Professor</code>.
  </p>

  <p>
    The key here is <code>{Subject, Professor}</code>.  
    But since <code>Professor ‚Üí Textbook</code> and Professor is not a super key, this violates BCNF.
  </p>

  <h3>‚úÖ After Applying BCNF</h3>
  <p>We decompose the table into two BCNF tables:</p>

  <h4>üìÑ Professor_Textbook</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Professor</th>
      <th>Textbook</th>
    </tr>
    <tr>
      <td>Dr. Smith</td>
      <td>DBMS by Korth</td>
    </tr>
  </table>

  <h4>üìÑ Subject_Professor</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Subject</th>
      <th>Professor</th>
    </tr>
    <tr>
      <td>Database</td>
      <td>Dr. Smith</td>
    </tr>
    <tr>
      <td>SQL</td>
      <td>Dr. Smith</td>
    </tr>
  </table>

  <h3>üìà SQL Example</h3>
  <pre><code class="language-sql">
CREATE TABLE Professor_Textbook (
  Professor VARCHAR(50) PRIMARY KEY,
  Textbook VARCHAR(100)
);

CREATE TABLE Subject_Professor (
  Subject VARCHAR(50) PRIMARY KEY,
  Professor VARCHAR(50)
);
  </code></pre>

  <h3>üß† Summary</h3>
  <ul>
    <li>BCNF fixes anomalies not handled by 3NF.</li>
    <li>Every determinant must be a candidate key.</li>
    <li>Stronger form of 3NF; ensures better data integrity.</li>
  </ul>
</section>

<!-- 4NF ‚Äî Fourth Normal Form (copy this section only) -->
<section id="4nf">
  <h2>Normalization: <strong>4NF ‚Äî Fourth Normal Form</strong></h2>
  <p><em>Goal:</em> Remove <strong>multi-valued dependencies</strong>. Each table should represent one type of independent relationship between entities. A record should not contain two or more independent multi-valued facts about the same key.</p>

  <h3>What 4NF requires</h3>
  <ul>
    <li>Table must already be in <strong>Boyce‚ÄìCodd Normal Form (BCNF)</strong>.</li>
    <li>There should be no <strong>multi-valued dependencies</strong> ‚Äî where one key determines multiple independent sets of values.</li>
    <li>Each fact in a table must describe one and only one relationship.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 4NF</h3>
  <p>Consider a <code>Teacher</code> table where each teacher can teach multiple <code>Subjects</code> and also handle multiple <code>Classes</code>. Both are independent relationships.</p>

  <table>
    <thead>
      <tr><th>teacher_id</th><th>teacher_name</th><th>subject</th><th>class</th></tr>
    </thead>
    <tbody>
      <tr><td>1</td><td>Ravi</td><td>Maths</td><td>10A</td></tr>
      <tr><td>1</td><td>Ravi</td><td>Maths</td><td>10B</td></tr>
      <tr><td>1</td><td>Ravi</td><td>Science</td><td>10A</td></tr>
      <tr><td>1</td><td>Ravi</td><td>Science</td><td>10B</td></tr>
    </tbody>
  </table>

  <p><strong>Problem:</strong> The table mixes two independent many-to-many relationships:</p>
  <ul>
    <li>Teacher ‚Üí Subject (Ravi teaches Maths, Science)</li>
    <li>Teacher ‚Üí Class (Ravi handles 10A, 10B)</li>
  </ul>
  <p>This causes redundancy ‚Äî each combination of subject and class creates extra rows (cross-product effect).</p>

  <h3>Normalize to 4NF ‚Äî separate independent relationships</h3>
  <p>We split into two tables: one for which subjects a teacher teaches, and another for which classes they handle.</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">TeacherSubjects</caption>
    <thead><tr><th>teacher_id</th><th>subject</th></tr></thead>
    <tbody>
      <tr><td>1</td><td>Maths</td></tr>
      <tr><td>1</td><td>Science</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">TeacherClasses</caption>
    <thead><tr><th>teacher_id</th><th>class</th></tr></thead>
    <tbody>
      <tr><td>1</td><td>10A</td></tr>
      <tr><td>1</td><td>10B</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- Teachers table
CREATE TABLE Teachers (
  teacher_id INT PRIMARY KEY,
  teacher_name VARCHAR(100)
);

-- TeacherSubjects (teacher_id + subject form composite key)
CREATE TABLE TeacherSubjects (
  teacher_id INT,
  subject VARCHAR(50),
  PRIMARY KEY (teacher_id, subject),
  FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id)
);

-- TeacherClasses (teacher_id + class form composite key)
CREATE TABLE TeacherClasses (
  teacher_id INT,
  class VARCHAR(50),
  PRIMARY KEY (teacher_id, class),
  FOREIGN KEY (teacher_id) REFERENCES Teachers(teacher_id)
);

-- Sample data
INSERT INTO Teachers VALUES (1, 'Ravi');

INSERT INTO TeacherSubjects VALUES
  (1, 'Maths'),
  (1, 'Science');

INSERT INTO TeacherClasses VALUES
  (1, '10A'),
  (1, '10B');
</code></pre>

  <h3>Why this fixes 4NF</h3>
  <ul>
    <li>Each table now represents one independent relationship.</li>
    <li>No multi-valued dependencies remain (subjects and classes are separate).</li>
    <li>Redundancy and unnecessary combinations are eliminated.</li>
  </ul>

  <h3>Quick checklist to confirm 4NF</h3>
  <ol>
    <li>Is the table already in BCNF?</li>
    <li>Does any key determine multiple independent multi-valued attributes? (If yes, separate them.)</li>
    <li>Does each table represent a single relationship type?</li>
  </ol>
</section>

<!-- 5NF ‚Äî Fifth Normal Form (copy this section only) -->
<section id="5nf">
  <h2>Normalization: <strong>5NF ‚Äî Fifth Normal Form</strong></h2>
  <p><em>Goal:</em> Eliminate <strong>join dependencies</strong> ‚Äî a table should not be decomposable into smaller tables that can be joined back together without data loss, unless necessary. Also known as <strong>Project-Join Normal Form (PJNF)</strong>.</p>

  <h3>What 5NF requires</h3>
  <ul>
    <li>Table must already be in <strong>4NF</strong>.</li>
    <li>All join dependencies must be implied by candidate keys.</li>
    <li>Each table should store facts that cannot be reconstructed by joining smaller tables without introducing redundancy.</li>
  </ul>

  <h3>Example ‚Äî table that <em>violates</em> 5NF</h3>
  <p>Consider a table showing which <strong>Suppliers</strong> supply which <strong>Products</strong> to which <strong>Projects</strong>.</p>

  <table>
    <thead>
      <tr><th>supplier</th><th>product</th><th>project</th></tr>
    </thead>
    <tbody>
      <tr><td>S1</td><td>P1</td><td>J1</td></tr>
      <tr><td>S1</td><td>P2</td><td>J1</td></tr>
      <tr><td>S1</td><td>P1</td><td>J2</td></tr>
      <tr><td>S2</td><td>P1</td><td>J1</td></tr>
    </tbody>
  </table>

  <p><strong>Observation:</strong> Supplier <code>S1</code> supplies products <code>P1</code> and <code>P2</code> for projects <code>J1</code> and <code>J2</code>. The relationships between supplier‚Äìproduct, supplier‚Äìproject, and product‚Äìproject can be independent but overlap redundantly here.</p>

  <p><strong>Problem:</strong> The table combines three independent relationships ‚Äî if we try to infer new combinations, it can cause spurious tuples when joining decomposed tables improperly.</p>

  <h3>Normalize to 5NF ‚Äî split by independent relationships</h3>
  <p>We decompose into three separate tables representing independent binary relationships:</p>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">SupplierProduct</caption>
    <thead><tr><th>supplier</th><th>product</th></tr></thead>
    <tbody>
      <tr><td>S1</td><td>P1</td></tr>
      <tr><td>S1</td><td>P2</td></tr>
      <tr><td>S2</td><td>P1</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">SupplierProject</caption>
    <thead><tr><th>supplier</th><th>project</th></tr></thead>
    <tbody>
      <tr><td>S1</td><td>J1</td></tr>
      <tr><td>S1</td><td>J2</td></tr>
      <tr><td>S2</td><td>J1</td></tr>
    </tbody>
  </table>

  <table>
    <caption style="text-align:left;font-weight:600;margin-bottom:6px">ProductProject</caption>
    <thead><tr><th>product</th><th>project</th></tr></thead>
    <tbody>
      <tr><td>P1</td><td>J1</td></tr>
      <tr><td>P1</td><td>J2</td></tr>
      <tr><td>P2</td><td>J1</td></tr>
    </tbody>
  </table>

  <h3>SQL (create + sample inserts)</h3>
  <pre><code>-- SupplierProduct table
CREATE TABLE SupplierProduct (
  supplier VARCHAR(10),
  product VARCHAR(10),
  PRIMARY KEY (supplier, product)
);

-- SupplierProject table
CREATE TABLE SupplierProject (
  supplier VARCHAR(10),
  project VARCHAR(10),
  PRIMARY KEY (supplier, project)
);

-- ProductProject table
CREATE TABLE ProductProject (
  product VARCHAR(10),
  project VARCHAR(10),
  PRIMARY KEY (product, project)
);

-- sample data
INSERT INTO SupplierProduct VALUES
  ('S1', 'P1'), ('S1', 'P2'), ('S2', 'P1');

INSERT INTO SupplierProject VALUES
  ('S1', 'J1'), ('S1', 'J2'), ('S2', 'J1');

INSERT INTO ProductProject VALUES
  ('P1', 'J1'), ('P1', 'J2'), ('P2', 'J1');
</code></pre>

  <h3>Why this fixes 5NF</h3>
  <ul>
    <li>Each table now represents one independent relationship.</li>
    <li>No redundancy ‚Äî every combination can be reconstructed by proper joins if valid.</li>
    <li>Prevents insertion and deletion anomalies caused by overlapping relationships.</li>
  </ul>

  <h3>Quick checklist to confirm 5NF</h3>
  <ol>
    <li>Is the table already in 4NF?</li>
    <li>Can it be decomposed into smaller tables without losing information? (If yes, decompose.)</li>
    <li>Do all join dependencies come from candidate keys?</li>
  </ol>
</section>

<section id="6nf">
  <h2>üß© <code>6NF</code> ‚Äî Sixth Normal Form</h2>

  <h3>üìò Description</h3>
  <p>
    Sixth Normal Form (6NF) is the highest level of normalization used in databases.  
    It deals with <b>temporal data (time-variant data)</b> ‚Äî data that changes over time.  
    A table is in 6NF if it is in 5NF and <b>cannot be decomposed any further</b> without losing information, 
    especially when time-based attributes are involved.
  </p>

  <h3>üí° Rule</h3>
  <ul>
    <li>The table must already satisfy 5NF.</li>
    <li>Every non-trivial join dependency must be a consequence of candidate keys.</li>
    <li>Used to handle changes in attribute values over time efficiently.</li>
  </ul>

  <h3>üìä Example (Before 6NF)</h3>
  <p>Consider a table tracking employee department history:</p>

  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Emp_ID</th>
      <th>Dept_ID</th>
      <th>Start_Date</th>
      <th>End_Date</th>
      <th>Salary</th>
    </tr>
    <tr>
      <td>101</td>
      <td>D01</td>
      <td>2020-01-01</td>
      <td>2021-12-31</td>
      <td>45000</td>
    </tr>
    <tr>
      <td>101</td>
      <td>D02</td>
      <td>2022-01-01</td>
      <td>NULL</td>
      <td>50000</td>
    </tr>
  </table>

  <p>
    Here, both department and salary can change independently over time.
    The table mixes two time-dependent facts (department history and salary history),
    so it violates 6NF.
  </p>

  <h3>‚úÖ After Applying 6NF</h3>
  <p>We split the table into two separate time-dependent tables:</p>

  <h4>üìÑ Employee_Department</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Emp_ID</th>
      <th>Dept_ID</th>
      <th>Start_Date</th>
      <th>End_Date</th>
    </tr>
    <tr>
      <td>101</td>
      <td>D01</td>
      <td>2020-01-01</td>
      <td>2021-12-31</td>
    </tr>
    <tr>
      <td>101</td>
      <td>D02</td>
      <td>2022-01-01</td>
      <td>NULL</td>
    </tr>
  </table>

  <h4>üìÑ Employee_Salary</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Emp_ID</th>
      <th>Salary</th>
      <th>Start_Date</th>
      <th>End_Date</th>
    </tr>
    <tr>
      <td>101</td>
      <td>45000</td>
      <td>2020-01-01</td>
      <td>2021-12-31</td>
    </tr>
    <tr>
      <td>101</td>
      <td>50000</td>
      <td>2022-01-01</td>
      <td>NULL</td>
    </tr>
  </table>

  <h3>üìà SQL Example</h3>
  <pre><code class="language-sql">
CREATE TABLE Employee_Department (
  Emp_ID INT,
  Dept_ID VARCHAR(10),
  Start_Date DATE,
  End_Date DATE
);

CREATE TABLE Employee_Salary (
  Emp_ID INT,
  Salary DECIMAL(10,2),
  Start_Date DATE,
  End_Date DATE
);
  </code></pre>

  <h3>üß† Summary</h3>
  <ul>
    <li>6NF is rarely used in practical systems.</li>
    <li>Mainly applies to temporal databases.</li>
    <li>It ensures each fact is stored in its smallest, indivisible form.</li>
  </ul>
</section>

<section id="normalization-summary">
  <h2>üßæ <code>Normalization Summary Table (1NF ‚Üí 6NF + BCNF)</code></h2>

  <table  cellspacing="0" cellpadding="8">
    <tr style="background:#f0f0f0;">
      <th>Normal Form</th>
      <th>Main Rule / Condition</th>
      <th>Removes</th>
      <th>Example Idea</th>
    </tr>

    <tr>
      <td><b>1NF</b> (First Normal Form)</td>
      <td>Each cell must contain only atomic (single) values.</td>
      <td>Repeating groups, multi-valued attributes.</td>
      <td>Splitting comma-separated phone numbers into rows.</td>
    </tr>

    <tr>
      <td><b>2NF</b> (Second Normal Form)</td>
      <td>Be in 1NF and remove partial dependencies.</td>
      <td>Partial dependency (non-key depends on part of composite key).</td>
      <td>Split student-course table so course details are stored separately.</td>
    </tr>

    <tr>
      <td><b>3NF</b> (Third Normal Form)</td>
      <td>Be in 2NF and remove transitive dependencies.</td>
      <td>Non-key depending on another non-key attribute.</td>
      <td>Move city & state info to a separate city table.</td>
    </tr>

    <tr>
      <td><b>BCNF</b> (Boyce‚ÄìCodd Normal Form / 3.5NF)</td>
      <td>Every determinant must be a candidate key.</td>
      <td>Dependency anomalies that 3NF can‚Äôt handle.</td>
      <td>Separate Professor ‚Üí Textbook and Subject ‚Üí Professor.</td>
    </tr>

    <tr>
      <td><b>4NF</b> (Fourth Normal Form)</td>
      <td>No multi-valued dependencies except candidate keys.</td>
      <td>Multi-valued dependency anomalies.</td>
      <td>Split student‚Äôs multiple skills and hobbies into different tables.</td>
    </tr>

    <tr>
      <td><b>5NF</b> (Fifth Normal Form)</td>
      <td>No join dependency ‚Äî data cannot be reconstructed incorrectly via joins.</td>
      <td>Join anomalies.</td>
      <td>Break down complex supplier‚Äìpart‚Äìproject relations.</td>
    </tr>

    <tr>
      <td><b>6NF</b> (Sixth Normal Form)</td>
      <td>Handle temporal (time-based) data; every fact is indivisible.</td>
      <td>Redundancy in time-variant data.</td>
      <td>Split employee‚Äôs department and salary history tables by time periods.</td>
    </tr>
  </table>

  <h3>üß† Quick Notes</h3>
  <ul>
    <li>1NF ‚Üí 3NF are most commonly used in real-world databases.</li>
    <li>BCNF fixes deeper dependency problems that 3NF misses.</li>
    <li>4NF‚Äì6NF are rare, used in specialized or temporal systems.</li>
  </ul>
</section>

<hr>
<section id="data-model">
  <h2>üß© <code>Data Model</code> ‚Äî In RDBMS</h2>

  <h3>üìò Description</h3>
  <p>
    A <b>Data Model</b> is a logical structure that defines how data is stored, organized, and related within a database.  
    It provides a blueprint for designing and implementing databases effectively.
  </p>
  <p>
    Simply put, a data model tells <b>how data is connected, stored, and accessed</b>.
  </p>

  <h3>üí° Purpose of Data Models</h3>
  <ul>
    <li>Defines structure and relationships between data.</li>
    <li>Improves consistency and data integrity.</li>
    <li>Acts as a communication bridge between developers, designers, and users.</li>
  </ul>

  <h3>üìä Types of Data Models</h3>

  <h4>1Ô∏è‚É£ Conceptual Data Model</h4>
  <p>
    - High-level model used for understanding data at the business level.  
    - Focuses on entities, relationships, and rules ‚Äî not technical details.  
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Concept</th><th>Description</th><th>Example</th></tr>
    <tr>
      <td>Entity</td>
      <td>Objects in the system</td>
      <td>Student, Course</td>
    </tr>
    <tr>
      <td>Relationship</td>
      <td>Association between entities</td>
      <td>Student <b>enrolls in</b> Course</td>
    </tr>
  </table>

  <h4>2Ô∏è‚É£ Logical Data Model</h4>
  <p>
    - Describes <b>how data is structured logically</b> ‚Äî includes tables, columns, and relationships.  
    - Independent of physical storage details.  
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Table</th><th>Columns</th></tr>
    <tr>
      <td>Student</td>
      <td>Student_ID, Name, Email</td>
    </tr>
    <tr>
      <td>Course</td>
      <td>Course_ID, Course_Name</td>
    </tr>
    <tr>
      <td>Enrollment</td>
      <td>Student_ID, Course_ID</td>
    </tr>
  </table>

  <h4>3Ô∏è‚É£ Physical Data Model</h4>
  <p>
    - Shows how data is physically stored in the database.  
    - Includes indexes, data types, constraints, and keys.  
  </p>

  <pre><code class="language-sql">
CREATE TABLE Student (
  Student_ID INT PRIMARY KEY,
  Name VARCHAR(50),
  Email VARCHAR(100)
);

CREATE TABLE Course (
  Course_ID INT PRIMARY KEY,
  Course_Name VARCHAR(50)
);

CREATE TABLE Enrollment (
  Student_ID INT,
  Course_ID INT,
  FOREIGN KEY (Student_ID) REFERENCES Student(Student_ID),
  FOREIGN KEY (Course_ID) REFERENCES Course(Course_ID)
);
  </code></pre>

  <h3>üß† Summary</h3>
  <ul>
    <li><b>Conceptual Model</b> ‚Äî High-level view (entities + relationships).</li>
    <li><b>Logical Model</b> ‚Äî Detailed structure (tables + columns).</li>
    <li><b>Physical Model</b> ‚Äî Implementation in the database (SQL schema).</li>
  </ul>
</section>

<hr>

<section id="er-model">
  <h2>üß© <code>E‚ÄìR Model</code> ‚Äî Entity Relationship Model</h2>

  <h3>üìò Description</h3>
  <p>
    The <b>Entity‚ÄìRelationship (E‚ÄìR) Model</b> is a high-level conceptual data model used to describe the structure of a database in terms of entities, attributes, and relationships.  
    It was proposed by <b>Peter Chen in 1976</b>.
  </p>

  <p>
    The E‚ÄìR model is often represented using an <b>ER diagram</b>, which visually shows how data is connected.
  </p>

  <h3>üí° Components of E‚ÄìR Model</h3>

  <h4>1Ô∏è‚É£ Entity</h4>
  <p>
    - An <b>entity</b> represents a real-world object or concept that can be distinctly identified.  
    - Each entity has a set of attributes.
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Entity Type</th><th>Description</th><th>Example</th></tr>
    <tr><td>Strong Entity</td><td>Has a primary key that uniquely identifies it.</td><td>Student, Course</td></tr>
    <tr><td>Weak Entity</td><td>Cannot be identified uniquely without a related strong entity.</td><td>Dependent of Employee</td></tr>
  </table>

  <h4>2Ô∏è‚É£ Attribute</h4>
  <p>
    - Attributes describe the properties or characteristics of an entity.
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Attribute Type</th><th>Description</th><th>Example</th></tr>
    <tr><td>Simple</td><td>Cannot be divided further</td><td>Name, Age</td></tr>
    <tr><td>Composite</td><td>Can be divided into smaller parts</td><td>Full_Name ‚Üí (First_Name, Last_Name)</td></tr>
    <tr><td>Derived</td><td>Can be derived from another attribute</td><td>Age (from DOB)</td></tr>
    <tr><td>Multivalued</td><td>Can have multiple values</td><td>Phone Numbers</td></tr>
  </table>

  <h4>3Ô∏è‚É£ Relationship</h4>
  <p>
    - A <b>relationship</b> represents the association between two or more entities.
  </p>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Description</th><th>Example</th></tr>
    <tr><td>One-to-One (1:1)</td><td>One entity is related to exactly one other entity.</td><td>Student ‚Üí ID Card</td></tr>
    <tr><td>One-to-Many (1:N)</td><td>One entity is related to many others.</td><td>Teacher ‚Üí Students</td></tr>
    <tr><td>Many-to-Many (M:N)</td><td>Many entities are related to many others.</td><td>Student ‚Üî Course</td></tr>
  </table>

  <h3>üß© Example</h3>
  <p><b>Entities:</b> Student, Course</p>
  <p><b>Relationship:</b> Student <code>enrolls in</code> Course</p>

  <pre><code class="language-text">
  [STUDENT] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ enrolls in ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [COURSE]
  </code></pre>

  <h4>üóÇÔ∏è Tables After Conversion</h4>
  <table  cellspacing="0" cellpadding="6">
    <tr><th>Student</th><th>Attributes</th></tr>
    <tr><td>Student_ID (PK)</td><td>Name, Email</td></tr>
  </table>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Course</th><th>Attributes</th></tr>
    <tr><td>Course_ID (PK)</td><td>Course_Name</td></tr>
  </table>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Enrollment (Relation)</th><th>Attributes</th></tr>
    <tr><td>Student_ID (FK)</td><td>Course_ID (FK)</td></tr>
  </table>

  <h3>üß† Summary</h3>
  <ul>
    <li>üìç Entity ‚Üí Real-world object (e.g., Student, Course)</li>
    <li>üè∑Ô∏è Attribute ‚Üí Properties of entities (e.g., Name, Email)</li>
    <li>üîó Relationship ‚Üí Links entities together (e.g., Enrolls In)</li>
    <li>üí° ER Model helps in designing a clear database structure before implementation.</li>
  </ul>
</section>

<section id="er-model">
  <h2>üß© <code>E‚ÄìR Model</code> ‚Äî Entity Relationship Model (ER Model)</h2>

  <h3>üìò Description</h3>
  <p>
    The <b>Entity‚ÄìRelationship (E‚ÄìR) Model</b> is a high-level data model used to design the logical structure of a database.
    It visually represents <b>entities</b> (objects), their <b>attributes</b> (properties), and <b>relationships</b> (associations).
    It was introduced by <b>Peter Chen in 1976</b>.
  </p>

  <h3>üéØ Purpose</h3>
  <p>
    ‚û§ To create a simple and clear diagram of how data is stored and connected in a database before actual implementation.
  </p>

  <h3>üß© Components of ER Model</h3>

  <h4>1Ô∏è‚É£ Entity (Rectangle)</h4>
  <p>
    - An <b>Entity</b> represents a real-world object such as <code>Student</code>, <code>Course</code>, <code>Employee</code>, etc.  
    - Each entity has a set of <b>attributes</b> describing it.
  </p>
  <ul>
    <li>üü© <b>Rectangle:</b> Used to represent an Entity.</li>
    <li>üüß <b>Double Rectangle:</b> Used for a <b>Weak Entity</b> (depends on another entity).</li>
  </ul>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Symbol</th><th>Description</th><th>Example</th></tr>
    <tr><td>Strong Entity</td><td>‚¨ú Rectangle</td><td>Can exist independently</td><td>Student, Course</td></tr>
    <tr><td>Weak Entity</td><td>‚¨ú Double Rectangle</td><td>Depends on a strong entity</td><td>Dependent (of Employee)</td></tr>
  </table>

  <h4>2Ô∏è‚É£ Attributes (Oval)</h4>
  <p>
    - <b>Attributes</b> describe properties of entities or relationships.
  </p>
  <ul>
    <li>‚ö™ <b>Oval:</b> Represents an Attribute.</li>
    <li>‚ö™ <b>Double Oval:</b> Represents a <b>Multivalued Attribute</b>.</li>
    <li>‚ö™ <b>Dashed Oval:</b> Represents a <b>Derived Attribute</b>.</li>
    <li>‚ö™ <b>Oval with underline:</b> Represents a <b>Key Attribute</b>.</li>
  </ul>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Attribute Type</th><th>Symbol</th><th>Description</th><th>Example</th></tr>
    <tr><td>Simple</td><td>Oval</td><td>Cannot be divided further</td><td>Name, Age</td></tr>
    <tr><td>Composite</td><td>Linked Ovals</td><td>Can be divided into sub-parts</td><td>Full_Name ‚Üí (First, Last)</td></tr>
    <tr><td>Derived</td><td>Dashed Oval</td><td>Derived from another value</td><td>Age (from DOB)</td></tr>
    <tr><td>Multivalued</td><td>Double Oval</td><td>Can have multiple values</td><td>Phone Numbers</td></tr>
    <tr><td>Key Attribute</td><td>Underlined Oval</td><td>Uniquely identifies entity</td><td>Roll_No, Emp_ID</td></tr>
  </table>

  <h4>3Ô∏è‚É£ Relationship (Diamond)</h4>
  <p>
    - A <b>Relationship</b> connects two or more entities.
  </p>
  <ul>
    <li>üî∑ <b>Diamond:</b> Represents a Relationship.</li>
    <li>üî∑ <b>Double Diamond:</b> Represents a <b>Weak Relationship</b>.</li>
  </ul>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Symbol</th><th>Description</th><th>Example</th></tr>
    <tr><td>Regular Relationship</td><td>Diamond</td><td>Normal connection</td><td>Student ‚îÄ Enrolls ‚îÄ Course</td></tr>
    <tr><td>Weak Relationship</td><td>Double Diamond</td><td>Connects Weak Entity to Strong Entity</td><td>Dependent ‚îÄ Related_To ‚îÄ Employee</td></tr>
  </table>

  <h3>üîó Types of Relationships (Cardinality Ratios)</h3>

  <table  cellspacing="0" cellpadding="6">
    <tr><th>Type</th><th>Notation</th><th>Description</th><th>Example</th></tr>
    <tr>
      <td>One-to-One</td>
      <td>1 : 1</td>
      <td>One entity of A is related to one entity of B</td>
      <td>Person ‚Üî Passport</td>
    </tr>
    <tr>
      <td>One-to-Many</td>
      <td>1 : N</td>
      <td>One entity of A is related to many entities of B</td>
      <td>Teacher ‚Üí Students</td>
    </tr>
    <tr>
      <td>Many-to-One</td>
      <td>N : 1</td>
      <td>Many entities of A are related to one entity of B</td>
      <td>Students ‚Üí Department</td>
    </tr>
    <tr>
      <td>Many-to-Many</td>
      <td>M : N</td>
      <td>Many entities of A are related to many entities of B</td>
      <td>Student ‚Üî Course</td>
    </tr>
  </table>

  <h3>üß± Participation Types</h3>
  <ul>
    <li>üî∏ <b>Total Participation:</b> All entities are involved in the relationship (represented by <b>double line</b>).</li>
    <li>üî∏ <b>Partial Participation:</b> Only some entities are involved (represented by <b>single line</b>).</li>
  </ul>

  <h3>üè∑Ô∏è Example ER Diagram Description</h3>
  <pre><code class="language-text">
  [STUDENT] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Enrolls ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [COURSE]
        |                         |
     (Roll_No)                (Course_ID)
        |                         |
      (Name)                   (Course_Name)
  </code></pre>

  <h3>üß© Conversion to Tables</h3>
  <table  cellspacing="0" cellpadding="6">
    <tr><th>Entity</th><th>Attributes</th></tr>
    <tr><td>STUDENT</td><td>Roll_No (PK), Name, Age</td></tr>
    <tr><td>COURSE</td><td>Course_ID (PK), Course_Name</td></tr>
    <tr><td>ENROLLMENT</td><td>Roll_No (FK), Course_ID (FK)</td></tr>
  </table>

  <h3>üß† Summary</h3>
  <ul>
    <li>üü© Rectangle ‚Üí Entity</li>
    <li>‚¨ú Double Rectangle ‚Üí Weak Entity</li>
    <li>üî∑ Diamond ‚Üí Relationship</li>
    <li>üî∑ Double Diamond ‚Üí Weak Relationship</li>
    <li>‚ö™ Oval ‚Üí Attribute</li>
    <li>‚ö™ Double Oval ‚Üí Multivalued Attribute</li>
    <li>‚ö™ Dashed Oval ‚Üí Derived Attribute</li>
    <li>‚ö™ Underlined ‚Üí Key Attribute</li>
    <li>‚ûï Lines ‚Üí Connect entities and attributes</li>
    <li>‚ûï Double Line ‚Üí Total Participation</li>
    <li>‚ûï Single Line ‚Üí Partial Participation</li>
    <li>üî¢ Cardinalities ‚Üí 1:1, 1:N, N:1, M:N</li>
  </ul>

  <h3>üìò Advantages of ER Model</h3>
  <ul>
    <li>Easy to understand and visualize database structure.</li>
    <li>Helps in identifying entities, relationships, and attributes clearly.</li>
    <li>Used as a blueprint before creating physical database tables.</li>
  </ul>

  <h3>üß© Example Real-World Case</h3>
  <p>
    <b>Example:</b> In a school database ‚Äî  
    <code>Student</code> enrolls in <code>Course</code>, and each <code>Course</code> is taught by a <code>Teacher</code>.
  </p>

  <pre><code class="language-text">
  STUDENT (Roll_No, Name)
        |
        | Enrolls
        |
  COURSE (Course_ID, Course_Name)
        |
        | Taught_By
        |
  TEACHER (T_ID, T_Name)
  </code></pre>

</section>

<section id="er-attributes">
  <h2>üß© <code>Types of Attributes</code> ‚Äî in ER Model</h2>

  <h3>üìò Description</h3>
  <p>
    In an <b>Entity‚ÄìRelationship (ER) Model</b>, <b>Attributes</b> describe properties or characteristics of an <b>Entity</b> or <b>Relationship</b>.  
    Each attribute represents a <b>data field</b> that stores information about the entity.
  </p>
  <p>
    Example: For an entity <code>STUDENT</code>, attributes can be <code>Roll_No, Name, Age, Email</code>, etc.
  </p>

  <h3>üè∑Ô∏è Attribute Types</h3>

  <h4>1Ô∏è‚É£ Simple Attribute</h4>
  <p>
    ‚û§ Cannot be divided further.  
    ‚û§ Represented by a <b>single oval</b>.
  </p>
  <p><b>Example:</b> Name, Age, Gender</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îú‚îÄ‚îÄ (Name)
     ‚îú‚îÄ‚îÄ (Age)
     ‚îî‚îÄ‚îÄ (Gender)
  </code></pre>

  <h4>2Ô∏è‚É£ Composite Attribute</h4>
  <p>
    ‚û§ Can be divided into smaller sub-parts.  
    ‚û§ Represented by <b>oval connected to sub-ovals</b>.
  </p>
  <p><b>Example:</b> Full_Name ‚Üí (First_Name, Last_Name)</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îî‚îÄ‚îÄ (Full_Name)
             ‚îú‚îÄ‚îÄ (First_Name)
             ‚îî‚îÄ‚îÄ (Last_Name)
  </code></pre>

  <h4>3Ô∏è‚É£ Derived Attribute</h4>
  <p>
    ‚û§ Value can be derived from another attribute.  
    ‚û§ Represented by a <b>dashed oval</b>.
  </p>
  <p><b>Example:</b> Age derived from Date_of_Birth</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îú‚îÄ‚îÄ (DOB)
     ‚îî‚îÄ‚îÄ (---Age---)
  </code></pre>

  <h4>4Ô∏è‚É£ Multivalued Attribute</h4>
  <p>
    ‚û§ Can have multiple values for the same entity.  
    ‚û§ Represented by a <b>double oval</b>.
  </p>
  <p><b>Example:</b> Phone_Number can have more than one value for a student.</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îî‚ïê‚ïê (Phone_Number)
  </code></pre>

  <h4>5Ô∏è‚É£ Key Attribute</h4>
  <p>
    ‚û§ Uniquely identifies each entity in a set.  
    ‚û§ Represented by an <b>underlined oval</b>.
  </p>
  <p><b>Example:</b> Roll_No uniquely identifies each student.</p>
  <pre><code class="language-text">
  STUDENT
     |
     ‚îú‚îÄ‚îÄ <u>Roll_No</u>
     ‚îú‚îÄ‚îÄ (Name)
     ‚îî‚îÄ‚îÄ (Email)
  </code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Type</th>
      <th>Symbol</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Simple Attribute</td>
      <td>Oval</td>
      <td>Cannot be divided further</td>
      <td>Name, Gender</td>
    </tr>
    <tr>
      <td>Composite Attribute</td>
      <td>Oval connected to sub-ovals</td>
      <td>Can be divided into sub-parts</td>
      <td>Full_Name ‚Üí First, Last</td>
    </tr>
    <tr>
      <td>Derived Attribute</td>
      <td>Dashed Oval</td>
      <td>Derived from other attributes</td>
      <td>Age (from DOB)</td>
    </tr>
    <tr>
      <td>Multivalued Attribute</td>
      <td>Double Oval</td>
      <td>Can have multiple values</td>
      <td>Phone_Number, Email_IDs</td>
    </tr>
    <tr>
      <td>Key Attribute</td>
      <td>Underlined Oval</td>
      <td>Uniquely identifies entity</td>
      <td>Roll_No, Emp_ID</td>
    </tr>
  </table>

  <h3>üß† Quick Summary</h3>
  <ul>
    <li>‚ö™ <b>Simple:</b> Single, indivisible value.</li>
    <li>‚ö™ <b>Composite:</b> Can be divided into smaller attributes.</li>
    <li>‚ö™ <b>Derived:</b> Calculated or derived from another attribute.</li>
    <li>‚ö™ <b>Multivalued:</b> Can have multiple values per entity.</li>
    <li>‚ö™ <b>Key:</b> Unique identifier of entity instances.</li>
  </ul>
</section>

<section id="er-entities">
  <h2>üß© <code>Types of Entities</code> ‚Äî in ER Model</h2>

  <h3>üìò Description</h3>
  <p>
    In the <b>Entity‚ÄìRelationship (ER) Model</b>, an <b>Entity</b> represents any real-world object, concept, or thing
    that can have data stored about it in a database.
  </p>
  <p>
    Example: <code>Student</code>, <code>Teacher</code>, <code>Course</code>, <code>Employee</code>.
  </p>

  <h3>üß© Classification of Entities</h3>

  <h4>1Ô∏è‚É£ Strong Entity (Independent Entity)</h4>
  <p>
    ‚û§ Exists independently and has its own <b>primary key</b>.  
    ‚û§ Represented by a <b>single rectangle</b> in ER diagram.
  </p>
  <p><b>Example:</b> STUDENT (Roll_No, Name, Email)</p>
  <pre><code class="language-text">
  [STUDENT]
     ‚îú‚îÄ‚îÄ Roll_No (PK)
     ‚îú‚îÄ‚îÄ Name
     ‚îî‚îÄ‚îÄ Email
  </code></pre>

  <h4>2Ô∏è‚É£ Weak Entity (Dependent Entity)</h4>
  <p>
    ‚û§ Cannot exist without being linked to a <b>Strong Entity</b>.  
    ‚û§ Does not have a unique key of its own ‚Äî identified by a <b>Partial Key</b>.  
    ‚û§ Represented by a <b>Double Rectangle</b>.  
    ‚û§ Linked with a <b>Double Diamond</b> to its owner (Strong Entity).
  </p>
  <p><b>Example:</b> DEPENDENT (Dependent_Name, Age) depends on EMPLOYEE (Emp_ID)</p>
  <pre><code class="language-text">
  [EMPLOYEE] ‚îÄ‚îÄ<‚©∏>‚îÄ‚îÄ [DEPENDENT]
     |                  |
   (Emp_ID)           (Dependent_Name, Age)
  </code></pre>

  <h4>3Ô∏è‚É£ Associative Entity (Bridge Entity)</h4>
  <p>
    ‚û§ Used to convert <b>many-to-many (M:N)</b> relationships into <b>two one-to-many (1:N)</b> relationships.  
    ‚û§ Has attributes of its own that describe the relationship.  
    ‚û§ Represented as a <b>rectangle inside a diamond</b>.
  </p>
  <p><b>Example:</b> ENROLLMENT connects STUDENT and COURSE.</p>
  <pre><code class="language-text">
  [STUDENT] ‚îÄ‚îÄ‚îÄ Enrolls ‚îÄ‚îÄ‚îÄ [COURSE]
         ‚Üò                ‚Üô
           [ENROLLMENT]
              ‚îú‚îÄ‚îÄ Roll_No (FK)
              ‚îú‚îÄ‚îÄ Course_ID (FK)
              ‚îî‚îÄ‚îÄ Date_of_Join
  </code></pre>

  <h4>4Ô∏è‚É£ Super Entity and Sub Entity (Generalization / Specialization)</h4>
  <p>
    ‚û§ Used when entities share common attributes but also have unique ones.  
    ‚û§ <b>Super Entity</b> (general) contains common attributes.  
    ‚û§ <b>Sub Entities</b> (specialized) contain unique attributes.  
    ‚û§ Represented using a <b>triangle</b> symbol for specialization/generalization.
  </p>
  <p><b>Example:</b> EMPLOYEE can be a TEACHER or an ADMIN.</p>
  <pre><code class="language-text">
        [EMPLOYEE]
          /     \
 [TEACHER]     [ADMIN]
  </code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellspacing="0" cellpadding="6">
    <tr>
      <th>Entity Type</th>
      <th>Symbol</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Strong Entity</td>
      <td>Single Rectangle</td>
      <td>Can exist independently</td>
      <td>Student, Employee</td>
    </tr>
    <tr>
      <td>Weak Entity</td>
      <td>Double Rectangle</td>
      <td>Depends on Strong Entity</td>
      <td>Dependent (of Employee)</td>
    </tr>
    <tr>
      <td>Associative Entity</td>
      <td>Rectangle inside Diamond</td>
      <td>Used in M:N relationships</td>
      <td>Enrollment between Student & Course</td>
    </tr>
    <tr>
      <td>Super Entity</td>
      <td>Rectangle connected to Triangle</td>
      <td>General (common) entity</td>
      <td>Employee</td>
    </tr>
    <tr>
      <td>Sub Entity</td>
      <td>Triangle to Rectangle</td>
      <td>Specialized version of super entity</td>
      <td>Teacher, Admin</td>
    </tr>
  </table>

  <h3>üß† Quick Summary</h3>
  <ul>
    <li>üü© <b>Strong Entity:</b> Exists independently (Single Rectangle).</li>
    <li>‚¨ú <b>Weak Entity:</b> Needs a strong entity to exist (Double Rectangle).</li>
    <li>üî∑ <b>Associative Entity:</b> Resolves M:N relationships.</li>
    <li>üî∫ <b>Super/Sub Entity:</b> Shows inheritance (Generalization/Specialization).</li>
  </ul>

  <h3>üìò Example Case</h3>
  <pre><code class="language-text">
  STUDENT (Roll_No, Name)
  COURSE (Course_ID, Title)
  ENROLLMENT (Roll_No, Course_ID, Grade)
  TEACHER (Emp_ID, Subject)
  ADMIN (Emp_ID, Department)
  </code></pre>

</section>
<section id="types-of-relationships">
  <h2>üîó <code>Types of Relationships in ER Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    In an <b>Entity Relationship (ER) Model</b>, a relationship defines how two or more entities are connected to each other.
    Relationships help represent <b>real-world associations</b> such as ‚ÄúStudent enrolls in Course‚Äù or ‚ÄúEmployee works in Department‚Äù.
  </p>

  <h3>üí† Relationship Symbols</h3>
  <ul>
    <li>üî∏ <b>Diamond (‚óä)</b> ‚Äî Represents a <b>relationship</b> between entities.</li>
    <li>üî∏ <b>Double Diamond (‚ß´‚ß´)</b> ‚Äî Used for <b>weak relationships</b> (when a weak entity depends on a strong entity).</li>
    <li>üî∏ <b>Rectangle ‚ñ≠</b> ‚Äî Represents an <b>entity</b>.</li>
    <li>üî∏ <b>Double Rectangle ‚ñ≠‚ñ≠</b> ‚Äî Represents a <b>weak entity</b>.</li>
    <li>üî∏ <b>Line</b> ‚Äî Connects entities and relationships.</li>
    <li>üî∏ <b>Oval (‚óØ)</b> ‚Äî Represents an <b>attribute</b>.</li>
    <li>üî∏ <b>Double Oval</b> ‚Äî Represents a <b>multivalued attribute</b>.</li>
    <li>üî∏ <b>Dashed Oval</b> ‚Äî Represents a <b>derived attribute</b>.</li>
  </ul>

  <h3>üß© Types of Relationships</h3>

  <h4>1Ô∏è‚É£ One-to-One (1:1)</h4>
  <p>
    In this type, <b>one entity</b> in set A is associated with <b>only one entity</b> in set B.
  </p>
  <pre><code>Example: Each person has one passport.</code></pre>
  <p><b>Diagram:</b> PERSON ‚ñ≠ ‚Äî‚Äî‚óä‚Äî‚Äî ‚ñ≠ PASSPORT</p>

  <h4>2Ô∏è‚É£ One-to-Many (1:N)</h4>
  <p>
    One entity from set A can be related to <b>many entities</b> in set B, but each entity in B is related to <b>only one</b> entity in A.
  </p>
  <pre><code>Example: One department has many employees.</code></pre>
  <p><b>Diagram:</b> DEPARTMENT ‚ñ≠ ‚Äî‚Äî‚óä‚Äî‚Äî<sub>(N)</sub> ‚ñ≠ EMPLOYEE</p>

  <h4>3Ô∏è‚É£ Many-to-One (N:1)</h4>
  <p>
    Many entities from set A are related to <b>one entity</b> in set B.
  </p>
  <pre><code>Example: Many employees work in one department.</code></pre>
  <p><b>Diagram:</b> EMPLOYEE ‚ñ≠<sub>(N)</sub> ‚Äî‚Äî‚óä‚Äî‚Äî ‚ñ≠ DEPARTMENT</p>

  <h4>4Ô∏è‚É£ Many-to-Many (M:N)</h4>
  <p>
    Entities from both sides can be related to multiple entities from the other side.
  </p>
  <pre><code>Example: A student can enroll in many courses, and each course can have many students.</code></pre>
  <p><b>Diagram:</b> STUDENT ‚ñ≠<sub>(M)</sub> ‚Äî‚Äî‚óä‚Äî‚Äî<sub>(N)</sub> ‚ñ≠ COURSE</p>

  <h4>5Ô∏è‚É£ Recursive (Unary) Relationship</h4>
  <p>
    A relationship between <b>the same entity set</b>. An entity is related to itself.
  </p>
  <pre><code>Example: An employee supervises another employee.</code></pre>
  <p><b>Diagram:</b> EMPLOYEE ‚ñ≠ ‚Äî‚Äî‚óä‚Äî‚Äî (supervises) ‚Äî‚Äî back to EMPLOYEE ‚ñ≠</p>

  <h4>6Ô∏è‚É£ Ternary Relationship</h4>
  <p>
    A relationship that involves <b>three entities</b> simultaneously.
  </p>
  <pre><code>Example: A Doctor prescribes a Drug to a Patient.</code></pre>
  <p><b>Diagram:</b> DOCTOR ‚ñ≠ ‚Äî‚Äî‚óä (prescribes) ‚óä‚Äî‚Äî ‚ñ≠ DRUG ‚Äî‚Äî‚óä‚Äî‚Äî ‚ñ≠ PATIENT</p>

  <h3>üìä Summary Table</h3>
  <table  cellpadding="5">
    <tr><th>Type</th><th>Meaning</th><th>Example</th></tr>
    <tr><td>1:1</td><td>One entity linked to exactly one other</td><td>Person ‚Üî Passport</td></tr>
    <tr><td>1:N</td><td>One entity linked to many others</td><td>Department ‚Üí Employees</td></tr>
    <tr><td>N:1</td><td>Many entities linked to one</td><td>Employees ‚Üí Department</td></tr>
    <tr><td>M:N</td><td>Many entities linked both ways</td><td>Student ‚Üî Course</td></tr>
    <tr><td>Unary</td><td>Entity linked to itself</td><td>Employee supervises Employee</td></tr>
    <tr><td>Ternary</td><td>Three entities linked</td><td>Doctor, Patient, Drug</td></tr>
  </table>

  <h3>üß† Quick Tip</h3>
  <p>
    üëâ If you see <b>double diamonds</b> or <b>double rectangles</b>, it means <b>weak entities or weak relationships</b> ‚Äî they depend on a strong entity for identification.
  </p>

</section>

<section id="participation-cardinality">
  <h2>üìè <code>Participation & Cardinality in ER Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    In an <b>Entity Relationship (ER) Model</b>, <b>cardinality</b> and <b>participation</b> describe how entities are related in a relationship set.
    They define <b>how many instances</b> of one entity can be associated with instances of another entity and whether participation is <b>mandatory or optional</b>.
  </p>

  <h3>üîπ Cardinality (Multiplicity)</h3>
  <p>
    Cardinality defines the <b>number of occurrences</b> of one entity that can be associated with another entity.
  </p>

  <h4>üí† Common Types</h4>
  <ul>
    <li><b>1:1 (One-to-One)</b> ‚Äî One entity of A is related to one entity of B.</li>
    <li><b>1:N (One-to-Many)</b> ‚Äî One entity of A can relate to many entities of B.</li>
    <li><b>N:1 (Many-to-One)</b> ‚Äî Many entities of A relate to one entity of B.</li>
    <li><b>M:N (Many-to-Many)</b> ‚Äî Many entities of A relate to many entities of B.</li>
  </ul>

  <h4>üìä Example</h4>
  <pre><code>Entity A: DEPARTMENT
Entity B: EMPLOYEE
Relationship: WORKS_IN
Cardinality: 1:N (One department has many employees)</code></pre>

  <table  cellpadding="5">
    <tr><th>Cardinality</th><th>Meaning</th><th>Example</th></tr>
    <tr><td>1:1</td><td>One entity of A ‚Üí one entity of B</td><td>Person ‚Üî Passport</td></tr>
    <tr><td>1:N</td><td>One entity of A ‚Üí many entities of B</td><td>Department ‚Üí Employees</td></tr>
    <tr><td>N:1</td><td>Many entities of A ‚Üí one entity of B</td><td>Employees ‚Üí Department</td></tr>
    <tr><td>M:N</td><td>Many entities of A ‚Üî many entities of B</td><td>Student ‚Üî Course</td></tr>
  </table>

  <h3>üî∏ Participation</h3>
  <p>
    Participation indicates whether <b>all entities</b> in a set take part in the relationship or only <b>some</b> of them do.
  </p>

  <h4>Types of Participation</h4>
  <ul>
    <li><b>Total Participation</b> ‚Äî Every entity in the set must participate in the relationship.<br>
      <i>Notation:</i> Double line between entity and relationship.<br>
      <i>Example:</i> Every employee must belong to a department.
    </li>
    <li><b>Partial Participation</b> ‚Äî Only some entities participate in the relationship.<br>
      <i>Notation:</i> Single line between entity and relationship.<br>
      <i>Example:</i> Some employees may not have a manager.
    </li>
  </ul>

  <h3>üìâ Min‚ÄìMax Notation</h3>
  <p>
    Another way to represent cardinality is the <b>(min, max)</b> notation, which defines the minimum and maximum number of relationships an entity can participate in.
  </p>

  <pre><code>Example:
STUDENT ‚îÄ‚îÄ (0, N) ENROLLS (1, 1) ‚îÄ‚îÄ COURSE

Meaning:
A student can enroll in zero or many courses.
A course must have at least one student.</code></pre>

  <table  cellpadding="5">
    <tr><th>Symbol</th><th>Meaning</th><th>Example</th></tr>
    <tr><td>(0,1)</td><td>Optional, at most one</td><td>Employee may manage at most one project</td></tr>
    <tr><td>(1,1)</td><td>Mandatory, exactly one</td><td>Each person must have one passport</td></tr>
    <tr><td>(0,N)</td><td>Optional, many</td><td>Student may enroll in many courses or none</td></tr>
    <tr><td>(1,N)</td><td>Mandatory, many</td><td>Department must have at least one employee</td></tr>
  </table>

  <h3>üß† Quick Tip</h3>
  <ul>
    <li>üí° <b>Total Participation</b> = double line connection.</li>
    <li>üí° <b>Partial Participation</b> = single line connection.</li>
    <li>üí° <b>Min‚ÄìMax notation</b> gives exact participation counts.</li>
  </ul>

</section>

<section id="generalization-specialization">
  <h2>üß≠ <code>Generalization, Specialization & Aggregation in ER Model</code></h2>

  <h3>üìò Description</h3>
  <p>
    These are advanced concepts in the <b>Entity Relationship (ER) Model</b> that help simplify and organize complex data relationships.
    They are mainly used to represent <b>hierarchies and real-world inheritance</b> among entities.
  </p>

  <h3>üå≥ 1Ô∏è‚É£ Generalization</h3>
  <p>
    <b>Generalization</b> is the process of combining two or more entities with similar attributes into a <b>single, generalized (superclass) entity</b>.
  </p>
  <pre><code>Example:
Entities: Car, Bike
Common attributes ‚Üí Vehicle

Generalized Entity: Vehicle
Sub-entities: Car, Bike</code></pre>

  <h4>üí† Symbol</h4>
  <ul>
    <li>Shown using a <b>triangle (Œî)</b> pointing <b>upwards</b>.</li>
    <li>Superclass (generalized entity) at the <b>top</b>.</li>
    <li>Subclasses (specific entities) at the <b>bottom</b>.</li>
  </ul>

  <p><b>Diagram Representation:</b></p>
  <pre><code>     Vehicle
        ‚ñ≥
       / \
     Car  Bike</code></pre>

  <h3>üß© 2Ô∏è‚É£ Specialization</h3>
  <p>
    <b>Specialization</b> is the reverse of generalization. It creates <b>subclasses</b> from an existing <b>superclass</b> based on specific attributes.
  </p>
  <pre><code>Example:
Entity: Employee
Specialized entities:
  - Manager (has team)
  - Developer (has programming language)</code></pre>

  <h4>üí† Symbol</h4>
  <ul>
    <li>Shown using a <b>triangle (Œî)</b> pointing <b>downwards</b>.</li>
    <li>Superclass (general entity) at the <b>top</b>.</li>
    <li>Subclasses (special entities) at the <b>bottom</b>.</li>
  </ul>

  <p><b>Diagram Representation:</b></p>
  <pre><code>     Employee
        ‚ñΩ
       / \
  Manager  Developer</code></pre>

  <h3>üßÆ 3Ô∏è‚É£ Aggregation</h3>
  <p>
    <b>Aggregation</b> is an abstraction where a <b>relationship itself acts as an entity</b> and participates in another relationship.
    It is used when a relationship involves another relationship.
  </p>
  <pre><code>Example:
  A project is assigned to a department, and employees work on that project.
  The "Works_On" relationship between Employee and Project can be aggregated with Department.
  </code></pre>

  <h4>üí† Symbol</h4>
  <ul>
    <li>Represented by a <b>rectangle around a diamond</b>.</li>
    <li>Shows that a relationship is treated as a <b>higher-level entity</b>.</li>
  </ul>

  <p><b>Diagram Representation:</b></p>
  <pre><code>EMPLOYEE ‚îÄ‚îÄ‚óä Works_On ‚óä‚îÄ‚îÄ PROJECT
       ‚¨ö
        \
        DEPARTMENT</code></pre>

  <h3>üß± 4Ô∏è‚É£ Difference Summary</h3>
  <table  cellpadding="5">
    <tr>
      <th>Concept</th>
      <th>Direction</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Generalization</td>
      <td>Bottom ‚Üí Top</td>
      <td>Combine similar entities</td>
      <td>Car + Bike ‚Üí Vehicle</td>
    </tr>
    <tr>
      <td>Specialization</td>
      <td>Top ‚Üí Bottom</td>
      <td>Divide entity into sub-entities</td>
      <td>Employee ‚Üí Manager, Developer</td>
    </tr>
    <tr>
      <td>Aggregation</td>
      <td>Relationship ‚Üí Entity</td>
      <td>Represent relationship between relationships</td>
      <td>Works_On (Employee‚ÄìProject) linked with Department</td>
    </tr>
  </table>

  <h3>üß† Quick Tips</h3>
  <ul>
    <li>üîº <b>Generalization</b> ‚Äî Triangle points upward (merge entities).</li>
    <li>üîΩ <b>Specialization</b> ‚Äî Triangle points downward (split entity).</li>
    <li>‚¨ö <b>Aggregation</b> ‚Äî Rectangle around diamond (relationship as entity).</li>
  </ul>
</section>

<section id="mapping-er-to-relational">
  <h2>üó∫Ô∏è <code>Mapping ER Diagram to Relational Model (Conversion Rules)</code></h2>

  <h3>üìò Description</h3>
  <p>
    The process of <b>converting an ER (Entity‚ÄìRelationship) Diagram</b> into a <b>Relational Model</b> is known as 
    <b>ER-to-Relational Mapping</b>.  
    This step helps to transform a conceptual design (ERD) into a logical schema (tables in RDBMS).
  </p>

  <h3>‚öôÔ∏è Steps / Conversion Rules</h3>

  <h4>1Ô∏è‚É£ Mapping of Strong Entities</h4>
  <p>
    For every <b>strong entity</b> in the ER diagram, create a <b>table</b>.  
    Each <b>attribute</b> of the entity becomes a <b>column</b> of the table, and the <b>primary key</b> remains the same.
  </p>
  <pre><code>Entity: STUDENT (Student_ID, Name, Age)
‚Üí Table: STUDENT(Student_ID PRIMARY KEY, Name, Age)</code></pre>

  <h4>2Ô∏è‚É£ Mapping of Weak Entities</h4>
  <p>
    A <b>weak entity</b> cannot be identified by its own attributes, so it depends on a <b>strong entity</b>.
    Create a table for the weak entity and include the <b>primary key of the strong entity</b> as a <b>foreign key</b>.
  </p>
  <pre><code>Entity: DEPENDENT (Dep_Name, Age) depends on EMPLOYEE(Emp_ID)
‚Üí Table: DEPENDENT(Emp_ID, Dep_Name, Age, PRIMARY KEY(Emp_ID, Dep_Name),
   FOREIGN KEY(Emp_ID) REFERENCES EMPLOYEE(Emp_ID))</code></pre>

  <h4>3Ô∏è‚É£ Mapping 1:1 Relationships</h4>
  <p>
    For a <b>one-to-one relationship</b>, choose one side (preferably the side with total participation)
    and include the <b>primary key of the other entity</b> as a <b>foreign key</b>.
  </p>
  <pre><code>Entities: PERSON(Person_ID, Name), PASSPORT(Passport_No)
Relationship: Each person has one passport
‚Üí Add Person_ID as foreign key in PASSPORT table</code></pre>

  <h4>4Ô∏è‚É£ Mapping 1:N Relationships</h4>
  <p>
    For a <b>one-to-many relationship</b>, add the <b>primary key of the ‚Äúone‚Äù side</b> as a <b>foreign key</b> in the table of the ‚Äúmany‚Äù side.
  </p>
  <pre><code>Entities: DEPARTMENT(Dept_ID, Name), EMPLOYEE(Emp_ID, Name)
Relationship: One department has many employees
‚Üí Add Dept_ID as foreign key in EMPLOYEE table</code></pre>

  <h4>5Ô∏è‚É£ Mapping M:N Relationships</h4>
  <p>
    For a <b>many-to-many relationship</b>, create a <b>new table</b> that stores the primary keys of both entities as <b>foreign keys</b>.
    These two foreign keys together form the <b>composite primary key</b> of the new table.
  </p>
  <pre><code>Entities: STUDENT(Student_ID), COURSE(Course_ID)
Relationship: Enrolls
‚Üí Create table: ENROLLS(Student_ID, Course_ID, PRIMARY KEY(Student_ID, Course_ID),
   FOREIGN KEY(Student_ID) REFERENCES STUDENT(Student_ID),
   FOREIGN KEY(Course_ID) REFERENCES COURSE(Course_ID))</code></pre>

  <h4>6Ô∏è‚É£ Mapping Multivalued Attributes</h4>
  <p>
    For each <b>multivalued attribute</b>, create a <b>new table</b> containing:
    <ul>
      <li>The <b>attribute name</b> itself</li>
      <li>The <b>primary key</b> of the original entity</li>
    </ul>
    Both together form the <b>composite primary key</b>.
  </p>
  <pre><code>Entity: STUDENT(Student_ID, Phone_Number)
‚Üí Create new table: STUDENT_PHONE(Student_ID, Phone_Number,
   PRIMARY KEY(Student_ID, Phone_Number))</code></pre>

  <h4>7Ô∏è‚É£ Mapping Derived Attributes</h4>
  <p>
    Derived attributes (calculated values) are <b>not stored</b> in the relational model;
    they can be <b>computed using queries</b> when needed.
  </p>
  <pre><code>Example: Age (derived from DOB) ‚Üí Not stored in table.</code></pre>

  <h4>8Ô∏è‚É£ Mapping Ternary (or Higher-Order) Relationships</h4>
  <p>
    For relationships involving <b>three or more entities</b>, create a <b>separate table</b>
    containing the <b>primary keys of all participating entities</b> as foreign keys.
  </p>
  <pre><code>Example: DOCTOR prescribes DRUG to PATIENT
‚Üí Table: PRESCRIPTION(Doctor_ID, Drug_ID, Patient_ID, Date, Dose)</code></pre>

  <h3>üìä Summary Table</h3>
  <table  cellpadding="5">
    <tr><th>ER Component</th><th>Relational Model Representation</th><th>Example</th></tr>
    <tr><td>Strong Entity</td><td>One table</td><td>STUDENT(Student_ID, Name)</td></tr>
    <tr><td>Weak Entity</td><td>Table + foreign key of owner</td><td>DEPENDENT(Emp_ID, Dep_Name)</td></tr>
    <tr><td>1:1 Relationship</td><td>Foreign key in one table</td><td>PASSPORT(Person_ID)</td></tr>
    <tr><td>1:N Relationship</td><td>Foreign key in "many" side</td><td>EMPLOYEE(Dept_ID)</td></tr>
    <tr><td>M:N Relationship</td><td>New relationship table</td><td>ENROLLS(Student_ID, Course_ID)</td></tr>
    <tr><td>Multivalued Attribute</td><td>New table with key + attribute</td><td>STUDENT_PHONE</td></tr>
    <tr><td>Derived Attribute</td><td>Not stored, computed via query</td><td>Age from DOB</td></tr>
    <tr><td>Ternary Relationship</td><td>New table with all keys</td><td>PRESCRIPTION</td></tr>
  </table>

  <h3>üß† Quick Tips</h3>
  <ul>
    <li>üí° Each <b>entity ‚Üí table</b>.</li>
    <li>üí° Each <b>relationship ‚Üí foreign key</b> or <b>new table</b>.</li>
    <li>üí° <b>Multivalued attributes</b> become separate tables.</li>
    <li>üí° <b>Derived attributes</b> are <b>not stored</b>.</li>
  </ul>

 
</section>

<hr>

<section id="relational-model">
  <h2>üßÆ <code>Relational Model in DBMS</code></h2>

  <h3>üìò Description</h3>
  <p>
    The <b>Relational Model</b> is the most widely used model in <b>Relational Database Management Systems (RDBMS)</b>.
    It represents data in the form of <b>tables (relations)</b>, where each table consists of <b>rows (tuples)</b> and <b>columns (attributes)</b>.
  </p>

  <h3>üß± Components of the Relational Model</h3>

  <h4>1Ô∏è‚É£ Relation (Table)</h4>
  <p>
    A <b>relation</b> is a <b>table</b> that stores data.  
    Each <b>row</b> in the table is called a <b>tuple</b> and represents a single record.
    Each <b>column</b> represents an <b>attribute</b>.
  </p>
  <pre><code>Example Table: STUDENT
+------------+----------+--------+
| Student_ID | Name     | Age    |
+------------+----------+--------+
| S1         | Arjun    | 21     |
| S2         | Priya    | 22     |
+------------+----------+--------+</code></pre>

  <h4>2Ô∏è‚É£ Tuple (Row)</h4>
  <p>
    A <b>tuple</b> is a single row in a relation that represents one record.
  </p>
  <pre><code>Example: (S1, Arjun, 21)</code></pre>

  <h4>3Ô∏è‚É£ Attribute (Column)</h4>
  <p>
    An <b>attribute</b> is a column that defines a property of the entity.
  </p>
  <pre><code>Example: Student_ID, Name, Age</code></pre>

  <h4>4Ô∏è‚É£ Domain</h4>
  <p>
    A <b>domain</b> is the set of all possible values that an attribute can take.
  </p>
  <pre><code>Example:
Attribute: Age
Domain: {18, 19, 20, 21, 22, 23, ...}</code></pre>

  <h4>5Ô∏è‚É£ Degree and Cardinality</h4>
  <ul>
    <li><b>Degree</b> ‚Üí Number of attributes (columns) in a relation.</li>
    <li><b>Cardinality</b> ‚Üí Number of tuples (rows) in a relation.</li>
  </ul>
  <pre><code>Example:
STUDENT(Student_ID, Name, Age)
‚Üí Degree = 3, Cardinality = 2</code></pre>

  <h4>6Ô∏è‚É£ Schema and Instance</h4>
  <ul>
    <li><b>Schema</b> ‚Äî Structure of the relation (table definition).</li>
    <li><b>Instance</b> ‚Äî Actual content or data present at a specific time.</li>
  </ul>
  <pre><code>Schema: STUDENT(Student_ID, Name, Age)
Instance:
+------------+----------+--------+
| Student_ID | Name     | Age    |
+------------+----------+--------+
| S1         | Arjun    | 21     |
| S2         | Priya    | 22     |
+------------+----------+--------+</code></pre>

  <h4>7Ô∏è‚É£ Keys</h4>
  <p>
    Keys are used to <b>uniquely identify</b> tuples in a relation and establish <b>relationships</b> between tables.
  </p>
  <ul>
    <li><b>Primary Key</b> ‚Äî Uniquely identifies each tuple.</li>
    <li><b>Foreign Key</b> ‚Äî Links one table to another.</li>
    <li><b>Candidate Key</b> ‚Äî Attributes that can act as primary keys.</li>
    <li><b>Alternate Key</b> ‚Äî Remaining candidate keys after choosing the primary key.</li>
    <li><b>Composite Key</b> ‚Äî Key made of two or more attributes.</li>
    <li><b>Super Key</b> ‚Äî Any key that can uniquely identify a tuple.</li>
  </ul>

  <h3>üß© Example</h3>
  <p><b>Entities:</b> STUDENT and COURSE</p>
  <pre><code>STUDENT(Student_ID, Name, Age, Course_ID)
COURSE(Course_ID, Course_Name)

Primary Key: Student_ID
Foreign Key: Course_ID (references COURSE table)</code></pre>

  <h3>üìä Relational Model Diagram</h3>
  <pre><code>+------------+-------------+
|  STUDENT   |  COURSE     |
+------------+-------------+
| Student_ID | Course_ID   |
| Name       | Course_Name |
| Age        |             |
+------------+-------------+
        ‚îÇ
        ‚îÇ (Foreign Key)
        ‚ñº
   COURSE.Course_ID</code></pre>

  <h3>üß† Characteristics of Relational Model</h3>
  <ul>
    <li>‚úÖ Data is stored in <b>tables (relations)</b>.</li>
    <li>‚úÖ Each table has a unique <b>primary key</b>.</li>
    <li>‚úÖ Data integrity is maintained using <b>keys</b> and <b>constraints</b>.</li>
    <li>‚úÖ Operations like <b>SELECT, INSERT, UPDATE, DELETE</b> are used to manipulate data.</li>
    <li>‚úÖ Relationships are established using <b>foreign keys</b>.</li>
  </ul>

  <h3>üß† Advantages</h3>
  <ul>
    <li>‚úîÔ∏è Simple and easy to understand (table-based).</li>
    <li>‚úîÔ∏è Ensures <b>data consistency</b> and <b>integrity</b>.</li>
    <li>‚úîÔ∏è Supports powerful <b>SQL operations</b>.</li>
    <li>‚úîÔ∏è Allows <b>relationships</b> between data.</li>
  </ul>

  <h3>‚ö†Ô∏è Disadvantages</h3>
  <ul>
    <li>‚ùå May be slower for very large or complex data (compared to NoSQL).</li>
    <li>‚ùå Requires <b>normalization</b> to reduce redundancy.</li>
    <li>‚ùå Not ideal for <b>hierarchical</b> or <b>graph-based</b> data.</li>
  </ul>
</section>

<hr>
<section id="buffer-management">
  <h2>üíæ <code>Buffer Management in DBMS</code></h2>

  <h3>üìò Description</h3>
  <p>
    <b>Buffer Management</b> is a crucial part of the <b>DBMS storage management system</b>.
    It is responsible for efficiently handling <b>data transfer between disk and main memory (RAM)</b> using a temporary storage area called the <b>Buffer Pool</b> or <b>Buffer Cache</b>.
  </p>

  <h3>üéØ Purpose</h3>
  <ul>
    <li>Reduce the number of <b>disk I/O operations</b>.</li>
    <li>Provide faster data access by keeping frequently used data in main memory.</li>
    <li>Improve overall <b>DBMS performance</b> and query speed.</li>
  </ul>

  <h3>‚öôÔ∏è How It Works</h3>
  <ol>
    <li>When a query requests data, DBMS checks if that data (page) exists in the <b>Buffer Pool</b>.</li>
    <li>If the page is found ‚Üí Data is fetched directly from memory (fast access).</li>
    <li>If not found ‚Üí DBMS loads it from the disk into an available buffer frame (slow access).</li>
    <li>If the buffer is full ‚Üí DBMS uses a <b>replacement policy</b> to decide which page to remove.</li>
    <li>Modified pages (called <b>dirty pages</b>) are written back to the disk before being replaced.</li>
  </ol>

  <h3>üß± Components of Buffer Management</h3>
  <table  cellspacing="0" cellpadding="5">
    <tr>
      <th>Component</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><b>Buffer Pool</b></td>
      <td>Reserved area in main memory where database pages are temporarily stored.</td>
    </tr>
    <tr>
      <td><b>Frame</b></td>
      <td>A single slot in the buffer pool that holds one page of data.</td>
    </tr>
    <tr>
      <td><b>Page Table</b></td>
      <td>Data structure that keeps track of which database pages are currently in the buffer.</td>
    </tr>
    <tr>
      <td><b>Dirty Page</b></td>
      <td>A page that has been modified in the buffer but not yet written to disk.</td>
    </tr>
  </table>

  <h3>üîÑ Buffer Replacement Policies</h3>
  <p>When the buffer pool is full, one of the following algorithms decides which page to remove:</p>
  <table  cellspacing="0" cellpadding="5">
    <tr>
      <th>Policy</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><b>LRU (Least Recently Used)</b></td>
      <td>Replaces the page that has not been used for the longest time.</td>
    </tr>
    <tr>
      <td><b>MRU (Most Recently Used)</b></td>
      <td>Replaces the page that was most recently accessed.</td>
    </tr>
    <tr>
      <td><b>FIFO (First In First Out)</b></td>
      <td>Replaces the page that entered the buffer first.</td>
    </tr>
    <tr>
      <td><b>LFU (Least Frequently Used)</b></td>
      <td>Removes the page that is used the least often.</td>
    </tr>
    <tr>
      <td><b>Clock Algorithm</b></td>
      <td>A circular list-based efficient version of LRU that uses reference bits to track usage.</td>
    </tr>
  </table>

  <h3>üßÆ Example</h3>
  <pre><code>Suppose the STUDENT table is stored on disk.
1Ô∏è‚É£ When a query requests data for a student record, DBMS checks if it‚Äôs in buffer.
2Ô∏è‚É£ If not, it loads the page from disk into a buffer frame.
3Ô∏è‚É£ After update, the page becomes ‚Äúdirty‚Äù.
4Ô∏è‚É£ When buffer is full, LRU policy may remove the least used page and write dirty pages back to disk.</code></pre>

  <h3>üöÄ Advantages</h3>
  <ul>
    <li>Reduces disk I/O operations (faster query execution).</li>
    <li>Improves CPU‚ÄìI/O overlap efficiency.</li>
    <li>Maintains data consistency through controlled write-back (dirty page handling).</li>
    <li>Enhances DBMS performance for large databases.</li>
  </ul>

  <h3>‚ö†Ô∏è Disadvantages</h3>
  <ul>
    <li>Requires careful tuning of buffer size for best performance.</li>
    <li>Dirty page handling adds complexity to transaction management.</li>
    <li>Poor replacement policy may cause frequent page faults.</li>
  </ul>

</section>

<hr>

<div class="topic">
  <h2>DDL in MySQL</h2>
  <p>DDL (Data Definition Language) defines and changes database objects like <b>databases</b>, <b>tables</b>, and <b>indexes</b>. DDL auto-commits (cannot be rolled back).</p>
</div>

<!-- 1) CREATE DATABASE + USE -->
<div class="topic">
  <h3>1) CREATE DATABASE & USE</h3>
  <p><b>Purpose:</b> Create a new database and switch to it.</p>
  <pre>
-- Syntax
CREATE DATABASE [IF NOT EXISTS] db_name
  [DEFAULT CHARACTER SET utf8mb4]
  [DEFAULT COLLATE utf8mb4_0900_ai_ci];

USE db_name;

-- Example
CREATE DATABASE IF NOT EXISTS company_db
  DEFAULT CHARACTER SET utf8mb4
  DEFAULT COLLATE utf8mb4_0900_ai_ci;

USE company_db;
  </pre>
  <p><b>Notes:</b> Always prefer <code>utf8mb4</code> for full Unicode (includes emoji).</p>
</div>

<!-- 2) CREATE TABLE -->
<div class="topic">
  <h3>2) CREATE TABLE</h3>
  <p><b>Purpose:</b> Define a table‚Äôs columns, data types, and constraints.</p>

  <pre>
-- Syntax (column-level + table-level constraints)
CREATE TABLE table_name (
  col_name data_type [NOT NULL] [UNIQUE] [DEFAULT expr] [CHECK (condition)]
  [AUTO_INCREMENT] [COMMENT '...'],
  -- more columns...
  [PRIMARY KEY (col_list)],
  [UNIQUE (col_list)],
  [CONSTRAINT fk_name FOREIGN KEY (child_cols)
     REFERENCES parent_table(parent_cols)
     ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION}
     ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION}]
) ENGINE=InnoDB;
  </pre>

  <pre>
-- Example: Parent table
CREATE TABLE departments (
  dept_id   INT PRIMARY KEY AUTO_INCREMENT,
  dept_name VARCHAR(60) NOT NULL UNIQUE,
  location  VARCHAR(60) DEFAULT 'HQ',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- Example: Child table with FK
CREATE TABLE employees (
  emp_id     INT PRIMARY KEY AUTO_INCREMENT,
  full_name  VARCHAR(80) NOT NULL,
  email      VARCHAR(120) UNIQUE,
  salary     DECIMAL(10,2) CHECK (salary >= 0),
  hire_date  DATE NOT NULL,
  dept_id    INT,
  CONSTRAINT fk_emp_dept
    FOREIGN KEY (dept_id)
    REFERENCES departments(dept_id)
    ON DELETE SET NULL
    ON UPDATE CASCADE
) ENGINE=InnoDB;
  </pre>

  <p><b>Notes:</b>
    <ul>
      <li><b>CHECK</b> is enforced in MySQL 8.0.16+.</li>
      <li><b>AUTO_INCREMENT</b> works on a key column (typically PK).</li>
      <li>Use <b>ENGINE=InnoDB</b> for transactions + FK support.</li>
    </ul>
  </p>
</div>

<!-- 3) ALTER TABLE -->
<div class="topic">
  <h3>3) ALTER TABLE</h3>
  <p><b>Purpose:</b> Change a table after creation ‚Äî add/modify/drop columns, rename columns/tables, add/drop constraints or indexes.</p>

  <h4>Common Syntax</h4>
  <pre>
-- Add a column
ALTER TABLE table_name
  ADD COLUMN col_name data_type [constraints] [AFTER other_col];

-- Modify definition (type / nullability / default) without renaming
ALTER TABLE table_name
  MODIFY COLUMN col_name new_data_type [NOT NULL] [DEFAULT expr];

-- Rename a column (MySQL 8+)
ALTER TABLE table_name
  RENAME COLUMN old_name TO new_name;

-- Drop a column
ALTER TABLE table_name
  DROP COLUMN col_name;

-- Rename table
ALTER TABLE old_table_name
  RENAME TO new_table_name;

-- Add / Drop Primary Key
ALTER TABLE table_name
  ADD PRIMARY KEY (col_list);
ALTER TABLE table_name
  DROP PRIMARY KEY;

-- Add / Drop Foreign Key
ALTER TABLE child_table
  ADD CONSTRAINT fk_name FOREIGN KEY (child_cols)
    REFERENCES parent_table(parent_cols)
    ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE child_table
  DROP FOREIGN KEY fk_name;

-- Defaults (alternative)
ALTER TABLE table_name
  ALTER COLUMN col_name SET DEFAULT expr;
ALTER TABLE table_name
  ALTER COLUMN col_name DROP DEFAULT;

-- Indexes
ALTER TABLE table_name ADD INDEX idx_name (col_list);
ALTER TABLE table_name ADD UNIQUE uniq_name (col_list);
  </pre>

  <h4>Worked Examples</h4>
  <pre>
-- 3.1 Add a column
ALTER TABLE employees
  ADD COLUMN phone VARCHAR(20) AFTER email;

-- 3.2 Change data type / NOT NULL / DEFAULT
ALTER TABLE employees
  MODIFY COLUMN phone VARCHAR(25) DEFAULT 'N/A';

-- 3.3 Rename a column
ALTER TABLE employees
  RENAME COLUMN full_name TO name;

-- 3.4 Drop a column
ALTER TABLE employees
  DROP COLUMN phone;

-- 3.5 Add a new FK with cascade delete
ALTER TABLE employees
  ADD CONSTRAINT fk_emp_dept2 FOREIGN KEY (dept_id)
  REFERENCES departments(dept_id)
  ON DELETE CASCADE ON UPDATE CASCADE;

-- 3.6 Add a composite unique key (name + hire_date must be unique)
ALTER TABLE employees
  ADD UNIQUE uniq_emp_name_date (name, hire_date);

-- 3.7 Add a secondary index for faster lookup by salary
ALTER TABLE employees
  ADD INDEX idx_emp_salary (salary);

-- 3.8 Change default
ALTER TABLE departments
  ALTER COLUMN location SET DEFAULT 'Main-Campus';
  </pre>

  <p><b>Tips:</b> Prefer <code>RENAME COLUMN</code> on MySQL 8+. On older MySQL, use <code>CHANGE old new new_type</code>.</p>
</div>

<!-- 4) RENAME TABLE -->
<div class="topic">
  <h3>4) RENAME TABLE</h3>
  <p><b>Purpose:</b> Rename a table (atomic and fast).</p>
  <pre>
-- Syntax
RENAME TABLE old_name TO new_name;

-- Example
RENAME TABLE employees TO staff;
RENAME TABLE staff TO employees; -- (rename back)
  </pre>
</div>

<!-- 5) TRUNCATE TABLE -->
<div class="topic">
  <h3>5) TRUNCATE TABLE</h3>
  <p><b>Purpose:</b> Delete <i>all</i> rows quickly and reset AUTO_INCREMENT. Structure stays.</p>
  <pre>
-- Syntax
TRUNCATE TABLE table_name;

-- Example
TRUNCATE TABLE employees;
  </pre>
  <p><b>Important:</b> <code>TRUNCATE</code> is DDL ‚Üí implicit commit before & after; cannot be rolled back. Resets AUTO_INCREMENT to start.</p>
</div>

<!-- 6) DROP (TABLE / DATABASE / INDEX) -->
<div class="topic">
  <h3>6) DROP (Table / Database / Index)</h3>
  <p><b>Purpose:</b> Permanently remove objects(table).</p>
  <pre>
-- Drop table
DROP TABLE [IF EXISTS] employees;

-- Drop database
DROP DATABASE [IF EXISTS] company_db;

-- Drop index (MySQL syntax requires ON table)
DROP INDEX idx_emp_salary ON employees;
  </pre>
  <p><b>Warning:</b> Irreversible. Use <code>IF EXISTS</code> to avoid errors.</p>
</div>

<!-- 7) CREATE INDEX (bonus) -->
<div class="topic">
  <h3>7) CREATE INDEX (Bonus)</h3>
  <p><b>Purpose:</b> Speed up searches/joins on columns (reads faster; writes slightly slower).</p>
  <pre>
-- Syntax
CREATE [UNIQUE] INDEX index_name ON table_name (col1[, col2 ...]);

-- Example
CREATE INDEX idx_dept_name ON departments (dept_name);
CREATE UNIQUE INDEX uniq_emp_email ON employees (email);
  </pre>
  <p><b>Notes:</b> Index columns you filter/join/sort on frequently. Avoid indexing low-selectivity columns (e.g., boolean flags).</p>
</div>

<!-- Mini walkthrough -->
<div class="topic">
  <h3>Mini Walkthrough (from zero)</h3>
  <pre>
CREATE DATABASE IF NOT EXISTS company_db;
USE company_db;

CREATE TABLE departments (
  dept_id   INT PRIMARY KEY AUTO_INCREMENT,
  dept_name VARCHAR(60) NOT NULL UNIQUE,
  location  VARCHAR(60) DEFAULT 'HQ'
) ENGINE=InnoDB;

CREATE TABLE employees (
  emp_id    INT PRIMARY KEY AUTO_INCREMENT,
  name      VARCHAR(80) NOT NULL,
  email     VARCHAR(120) UNIQUE,
  salary    DECIMAL(10,2) CHECK (salary >= 0),
  hire_date DATE NOT NULL,
  dept_id   INT,
  CONSTRAINT fk_emp_dept
    FOREIGN KEY (dept_id)
    REFERENCES departments(dept_id)
    ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB;

-- tweak structure later
ALTER TABLE employees ADD INDEX idx_salary (salary);
ALTER TABLE employees RENAME COLUMN name TO full_name;

-- cleanup options
-- TRUNCATE TABLE employees;  -- clears all rows, keeps table
-- DROP TABLE employees;      -- removes table
-- DROP DATABASE company_db;  -- removes db and all its tables
  </pre>
</div>

<hr>

<div class="topic">
  <h2>DDL - Data Definition Language</h2>
  <p>
    DDL commands are used to define and manage the structure of database objects 
    such as <b>tables, views, indexes, schemas</b>.  
    These commands affect the database schema and are auto-committed 
    (changes cannot be rolled back).
  </p>
</div>

<div class="subtopic">
  <h3>1. CREATE</h3>
  <p>Used to create a new database or table.</p>

  <h4>Syntax:</h4>
  <pre>
  CREATE DATABASE dbname;
  CREATE TABLE table_name (
      column1 datatype constraint,
      column2 datatype constraint,
      ...
  );
  </pre>

  <h4>Example:</h4>
  <pre>
  CREATE DATABASE SchoolDB;

  USE SchoolDB;

  CREATE TABLE Students (
      student_id INT PRIMARY KEY,
      name VARCHAR(50) NOT NULL,
      age INT,
      grade CHAR(2)
  );
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 1 row affected (0.02 sec)
  </pre>
</div>

<div class="subtopic">
  <h3>2. ALTER</h3>
  <p>Used to modify an existing table (add, modify, or delete columns).</p>

  <h4>Syntax:</h4>
  <pre>
  ALTER TABLE table_name ADD column_name datatype;
  ALTER TABLE table_name MODIFY column_name new_datatype;
  ALTER TABLE table_name DROP column_name;
  </pre>

  <h4>Example:</h4>
  <pre>
  ALTER TABLE Students ADD email VARCHAR(100);
  ALTER TABLE Students MODIFY grade VARCHAR(5);
  ALTER TABLE Students DROP age;
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 0 rows affected (0.04 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  </pre>
</div>

<div class="subtopic">
  <h3>3. RENAME</h3>
  <p>Used to rename a table.</p>

  <h4>Syntax:</h4>
  <pre>
  RENAME TABLE old_table_name TO new_table_name;
  </pre>

  <h4>Example:</h4>
  <pre>
  RENAME TABLE Students TO Student_Info;
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 0 rows affected (0.01 sec)
  </pre>
</div>

<div class="subtopic">
  <h3>4. TRUNCATE</h3>
  <p>
    Used to remove all rows from a table, but the table structure remains.  
    Unlike DELETE, TRUNCATE cannot be rolled back.
  </p>

  <h4>Syntax:</h4>
  <pre>
  TRUNCATE TABLE table_name;
  </pre>

  <h4>Example:</h4>
  <pre>
  TRUNCATE TABLE Student_Info;
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 0 rows affected (0.02 sec)
  </pre>
</div>

<div class="subtopic">
  <h3>5. DROP</h3>
  <p>
    Used to delete a table or database permanently (structure + data).  
    Cannot be rolled back.
  </p>

  <h4>Syntax:</h4>
  <pre>
  DROP TABLE table_name;
  DROP DATABASE dbname;
  </pre>

  <h4>Example:</h4>
  <pre>
  DROP TABLE Student_Info;
  DROP DATABASE SchoolDB;
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 0 rows affected (0.01 sec)
  </pre>
</div>

<hr>

<!-- ======================= -->
<!-- DML -->
<!-- ======================= -->
<div class="topic">
  <h2>DML in MySQL</h2>
  <p>DML (Data Manipulation Language) is used to manage data inside tables. 
  <b>Important:</b> Unlike DDL, DML changes <i>can be rolled back</i> if executed inside a transaction.</p>
</div>

<!-- 1) INSERT -->
<div class="topic">
  <h3>1) INSERT</h3>
  <p><b>Purpose:</b> Add new rows into a table.</p>
  <pre>
-- Insert single row
INSERT INTO employees (name, email, salary, hire_date, dept_id)
VALUES ('Alice', 'alice@example.com', 50000, '2025-01-15', 1);

-- Insert multiple rows
INSERT INTO employees (name, email, salary, hire_date, dept_id)
VALUES 
  ('Bob', 'bob@example.com', 60000, '2025-01-20', 1),
  ('Charlie', 'charlie@example.com', 55000, '2025-02-01', 2);

-- Insert from another table
INSERT INTO employees_backup (name, email, salary)
SELECT name, email, salary FROM employees WHERE dept_id = 1;
  </pre>
</div>

<!-- 2) UPDATE -->
<div class="topic">
  <h3>2) UPDATE</h3>
  <p><b>Purpose:</b> Modify existing rows in a table.</p>
  <pre>
-- Increase salary for dept 1 employees
UPDATE employees
SET salary = salary + 5000
WHERE dept_id = 1;

-- Update multiple columns
UPDATE employees
SET salary = 65000, hire_date = '2025-03-01'
WHERE name = 'Charlie';
  </pre>
  <p><b>Note:</b> Always include a <code>WHERE</code> clause to avoid updating all rows accidentally.</p>
</div>

<!-- 3) DELETE -->
<div class="topic">
  <h3>3) DELETE</h3>
  <p><b>Purpose:</b> Remove rows from a table.</p>
  <pre>
-- Delete one employee
DELETE FROM employees WHERE name = 'Charlie';

-- Delete by condition
DELETE FROM employees WHERE salary < 40000;

-- Delete all rows (rollback possible)
DELETE FROM employees;
  </pre>
  <p><b>Tip:</b> Use <code>TRUNCATE</code> if you want faster full-table deletion (DDL, cannot rollback).</p>
</div>

<!-- Mini Walkthrough -->
<div class="topic">
  <h3>Mini Walkthrough</h3>
  <pre>
-- Add data
INSERT INTO employees (name, email, salary, hire_date, dept_id)
VALUES ('David', 'david@example.com', 70000, '2025-02-10', 2);

-- Update
UPDATE employees SET salary = salary + 2000 WHERE name = 'David';

-- Delete
DELETE FROM employees WHERE name = 'David';
  </pre>
</div>

<hr>

<div class="topic">
  <h2>DML - Data Manipulation Language</h2>
  <p>
    DML commands are used to manage data inside database tables.  
    These operations can be rolled back (because they affect only data, not structure).  
    Common commands: <b>INSERT, UPDATE, DELETE</b>.
  </p>
</div>

<div class="subtopic">
  <h3>1. INSERT</h3>
  <p>Used to add new records into a table.</p>

  <h4>Syntax:</h4>
  <pre>
  INSERT INTO table_name (col1, col2, col3, ...)
  VALUES (val1, val2, val3, ...);

  -- OR (if inserting into all columns)
  INSERT INTO table_name VALUES (val1, val2, val3, ...);
  </pre>

  <h4>Example:</h4>
  <pre>
  CREATE TABLE Employees (
      emp_id INT PRIMARY KEY,
      name VARCHAR(50),
      salary DECIMAL(10,2),
      dept VARCHAR(20)
  );

  INSERT INTO Employees (emp_id, name, salary, dept)
  VALUES (101, 'Aathi', 50000.00, 'IT');

  INSERT INTO Employees VALUES (102, 'Siva', 60000.00, 'HR');
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 1 row affected (0.01 sec)
  </pre>
</div>

<div class="subtopic">
  <h3>2. UPDATE</h3>
  <p>Used to modify existing records in a table.</p>

  <h4>Syntax:</h4>
  <pre>
  UPDATE table_name
  SET col1 = val1, col2 = val2, ...
  WHERE condition;
  </pre>

  <h4>Example:</h4>
  <pre>
  UPDATE Employees
  SET salary = 65000.00
  WHERE emp_id = 102;
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 1 row affected (0.01 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  </pre>
</div>

<div class="subtopic">
  <h3>3. DELETE</h3>
  <p>Used to remove records from a table.</p>

  <h4>Syntax:</h4>
  <pre>
  DELETE FROM table_name WHERE condition;

  -- Delete all rows
  DELETE FROM table_name;
  </pre>

  <h4>Example:</h4>
  <pre>
  DELETE FROM Employees WHERE emp_id = 101;
  </pre>

  <h4>Output:</h4>
  <pre>
  Query OK, 1 row affected (0.00 sec)
  </pre>
</div>

<div class="subtopic note">
  <h3>Note:</h3>
  <ul>
    <li><b>DELETE</b> ‚Üí removes rows (can be rolled back if inside transaction).</li>
    <li><b>TRUNCATE</b> ‚Üí removes all rows (cannot be rolled back).</li>
  </ul>
</div>

<hr>

<!-- ======================= -->
<!-- DQL -->
<!-- ======================= -->
<div class="topic">
  <h2>DQL in MySQL</h2>
  <p>DQL (Data Query Language) is mainly about fetching and viewing data from the database. 
  In MySQL, the primary command is <code>SELECT</code>.</p>
</div>

<!-- 1) Basic SELECT -->
<div class="topic">
  <h3>1) Basic SELECT</h3>
  <pre>
-- Select all columns
SELECT * FROM employees;

-- Select specific columns
SELECT name, salary FROM employees;

-- Rename columns with alias
SELECT name AS employee_name, salary AS monthly_salary FROM employees;
  </pre>
</div>

<!-- 2) WHERE Clause -->
<div class="topic">
  <h3>2) Filtering with WHERE</h3>
  <pre>
-- Employees with salary greater than 50000
SELECT * FROM employees WHERE salary > 50000;

-- Multiple conditions
SELECT * FROM employees 
WHERE dept_id = 1 AND salary > 60000;
  </pre>
</div>

<!-- 3) ORDER BY -->
<div class="topic">
  <h3>3) Sorting Results</h3>
  <pre>
-- Sort employees by salary ascending
SELECT name, salary FROM employees ORDER BY salary ASC;

-- Sort by salary descending
SELECT name, salary FROM employees ORDER BY salary DESC;
  </pre>
</div>

<!-- 4) LIMIT -->
<div class="topic">
  <h3>4) LIMIT Results</h3>
  <pre>
-- First 5 employees
SELECT * FROM employees LIMIT 5;

-- Skip 3 rows and fetch next 5
SELECT * FROM employees LIMIT 3, 5;
  </pre>
</div>

<!-- 5) Aggregate Functions -->
<div class="topic">
  <h3>5) Aggregate Functions</h3>
  <pre>
-- Count employees
SELECT COUNT(*) FROM employees;

-- Average salary
SELECT AVG(salary) FROM employees;

-- Maximum and Minimum salary
SELECT MAX(salary), MIN(salary) FROM employees;
  </pre>
</div>

<!-- 6) GROUP BY -->
<div class="topic">
  <h3>6) Grouping Results</h3>
  <pre>
-- Total employees per department
SELECT dept_id, COUNT(*) 
FROM employees 
GROUP BY dept_id;

-- Average salary per department
SELECT dept_id, AVG(salary) 
FROM employees 
GROUP BY dept_id;
  </pre>
</div>

<!-- 7) HAVING -->
<div class="topic">
  <h3>7) HAVING (filter groups)</h3>
  <pre>
-- Departments with average salary > 60000
SELECT dept_id, AVG(salary) 
FROM employees 
GROUP BY dept_id 
HAVING AVG(salary) > 60000;
  </pre>
</div>

<!-- 8) DISTINCT -->
<div class="topic">
  <h3>8) DISTINCT</h3>
  <pre>
-- Get unique department IDs
SELECT DISTINCT dept_id FROM employees;
  </pre>
</div>

<!-- 9) Joins (Intro) -->
<div class="topic">
  <h3>9) Joins (Intro)</h3>
  <pre>
-- Employees with their department name
SELECT e.name, e.salary, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;
  </pre>
</div>

<hr>

<div class="topic">
  <h2>DQL ‚Äî SELECT (MySQL)</h2>
  <p><b>DQL</b> has one command: <code>SELECT</code>. With its clauses it does projection (columns), selection (rows), sorting, grouping, joins, subqueries, etc.</p>
</div>

<div class="topic">
  <h3>Sample Data (so all outputs make sense)</h3>
  <pre>
CREATE TABLE departments (
  dept_id INT PRIMARY KEY,
  dept_name VARCHAR(40) UNIQUE,
  location VARCHAR(40)
);

CREATE TABLE employees (
  emp_id INT PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  email VARCHAR(120),
  salary DECIMAL(10,2),
  hire_date DATE,
  dept_id INT NULL,
  FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
);

INSERT INTO departments VALUES
(1,'IT','HQ'),
(2,'HR','Chennai'),
(3,'Sales','Mumbai'),
(4,'Finance','Bengaluru'); -- no employees yet

INSERT INTO employees VALUES
(101,'Aathi','aathi@example.com',50000.00,'2023-01-10',1),
(102,'Siva','siva@example.com',65000.00,'2022-11-05',2),
(103,'Meera',NULL,72000.00,'2024-03-15',1),
(104,'John','john@example.com',45000.00,'2021-07-20',NULL),
(105,'Priya','priya@example.com',65000.00,'2023-09-01',3),
(106,'Aathi','aathi2@example.com',80000.00,'2025-02-10',1);
  </pre>
</div>

<div class="topic">
  <h3>1) Basic SELECT (Projection)</h3>
  <pre>
-- Syntax
SELECT [DISTINCT] col_list
FROM table_name;

-- Example: pick columns
SELECT name, salary FROM employees;
  </pre>
  <h4>Output:</h4>
  <table  cellpadding="6" cellspacing="0">
    <tr><th>name</th><th>salary</th></tr>
    <tr><td>Aathi</td><td>50000.00</td></tr>
    <tr><td>Siva</td><td>65000.00</td></tr>
    <tr><td>Meera</td><td>72000.00</td></tr>
    <tr><td>John</td><td>45000.00</td></tr>
    <tr><td>Priya</td><td>65000.00</td></tr>
    <tr><td>Aathi</td><td>80000.00</td></tr>
  </table>
  <p><b>Aliases:</b> <code>AS</code> renames columns in the result.</p>
  <pre>
SELECT name AS employee, salary AS ctc FROM employees;
  </pre>
</div>

<div class="topic">
  <h3>2) DISTINCT, LIMIT, OFFSET</h3>
  <pre>
-- Only different names
SELECT DISTINCT name FROM employees;

-- Top N rows (pagination)
SELECT name, salary FROM employees
ORDER BY salary DESC
LIMIT 3 OFFSET 0; -- top 3
  </pre>
  <h4>Output (DISTINCT name):</h4>
  <table  cellpadding="6"><tr><th>name</th></tr>
    <tr><td>Aathi</td></tr><tr><td>Siva</td></tr><tr><td>Meera</td></tr><tr><td>John</td></tr><tr><td>Priya</td></tr>
  </table>
  <h4>Output (Top 3 salaries):</h4>
  <table  cellpadding="6">
    <tr><th>name</th><th>salary</th></tr>
    <tr><td>Aathi</td><td>80000.00</td></tr>
    <tr><td>Meera</td><td>72000.00</td></tr>
    <tr><td>Siva</td><td>65000.00</td></tr>
  </table>
</div>

<div class="topic">
  <h3>3) WHERE ‚Äî Filtering Rows (Selection)</h3>
  <pre>
-- Syntax
SELECT col_list FROM table
WHERE condition;

-- Operators: =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, AND, OR, NOT, BETWEEN, IN, LIKE, IS NULL

-- Example: salary and department filter
SELECT emp_id, name, salary FROM employees
WHERE salary &gt;= 60000 AND dept_id IN (1,3);

-- Pattern: names starting with 'A'
SELECT name FROM employees
WHERE name LIKE 'A%';

-- Date range
SELECT name, hire_date FROM employees
WHERE hire_date BETWEEN '2023-01-01' AND '2024-12-31';

-- NULL check
SELECT emp_id, name FROM employees
WHERE dept_id IS NULL;
  </pre>
  <h4>Output (salary ‚â• 60000 AND dept_id IN 1,3):</h4>
  <table  cellpadding="6">
    <tr><th>emp_id</th><th>name</th><th>salary</th></tr>
    <tr><td>103</td><td>Meera</td><td>72000.00</td></tr>
    <tr><td>105</td><td>Priya</td><td>65000.00</td></tr>
    <tr><td>106</td><td>Aathi</td><td>80000.00</td></tr>
  </table>
</div>

<div class="topic">
  <h3>4) ORDER BY ‚Äî Sorting</h3>
  <pre>
-- Syntax
SELECT col_list FROM table
ORDER BY col1 [ASC|DESC], col2 [ASC|DESC];

-- Example: highest salary first, then name A‚ÜíZ
SELECT name, salary FROM employees
ORDER BY salary DESC, name ASC;

-- Place NULLs last (trick)
SELECT name, dept_id FROM employees
ORDER BY (dept_id IS NULL), dept_id;
  </pre>
  <h4>Output (salary DESC, name ASC):</h4>
  <table  cellpadding="6">
    <tr><th>name</th><th>salary</th></tr>
    <tr><td>Aathi</td><td>80000.00</td></tr>
    <tr><td>Meera</td><td>72000.00</td></tr>
    <tr><td>Priya</td><td>65000.00</td></tr>
    <tr><td>Siva</td><td>65000.00</td></tr>
    <tr><td>Aathi</td><td>50000.00</td></tr>
    <tr><td>John</td><td>45000.00</td></tr>
  </table>
</div>

<div class="topic">
  <h3>5) Aggregates + GROUP BY + HAVING</h3>
  <p><b>Aggregates:</b> <code>COUNT, SUM, AVG, MIN, MAX</code></p>
  <pre>
-- Per-department stats
SELECT dept_id,
       COUNT(*) AS total_emp,
       AVG(salary) AS avg_salary
FROM employees
GROUP BY dept_id;

-- Use HAVING to filter grouped results (NOT WHERE)
SELECT dept_id, COUNT(*) AS total_emp
FROM employees
GROUP BY dept_id
HAVING COUNT(*) &gt;= 2;

-- Friendly names with join
SELECT d.dept_name,
       COUNT(*) AS total_emp,
       ROUND(AVG(e.salary), 2) AS avg_salary
FROM departments d
JOIN employees e ON e.dept_id = d.dept_id
GROUP BY d.dept_name;
  </pre>
  <h4>Output (dept_id, count, avg):</h4>
  <table  cellpadding="6">
    <tr><th>dept_id</th><th>total_emp</th><th>avg_salary</th></tr>
    <tr><td>NULL</td><td>1</td><td>45000.00</td></tr>
    <tr><td>1</td><td>3</td><td>67333.33</td></tr>
    <tr><td>2</td><td>1</td><td>65000.00</td></tr>
    <tr><td>3</td><td>1</td><td>65000.00</td></tr>
  </table>
  <h4>Output (HAVING COUNT(*) ‚â• 2):</h4>
  <table  cellpadding="6">
    <tr><th>dept_id</th><th>total_emp</th></tr>
    <tr><td>1</td><td>3</td></tr>
  </table>
</div>

<div class="topic">
  <h3>6) JOINS ‚Äî Combining Tables</h3>
  <p><b>INNER JOIN:</b> only matching rows in both tables.</p>
  <pre>
SELECT e.name, d.dept_name
FROM employees e
INNER JOIN departments d ON d.dept_id = e.dept_id;
  </pre>
  <h4>Output (INNER):</h4>
  <table  cellpadding="6">
    <tr><th>name</th><th>dept_name</th></tr>
    <tr><td>Aathi</td><td>IT</td></tr>
    <tr><td>Siva</td><td>HR</td></tr>
    <tr><td>Meera</td><td>IT</td></tr>
    <tr><td>Priya</td><td>Sales</td></tr>
    <tr><td>Aathi</td><td>IT</td></tr>
  </table>

  <p><b>LEFT JOIN:</b> all rows from left (employees) + matches from right; unmatched ‚Üí NULL.</p>
  <pre>
SELECT e.name, d.dept_name
FROM employees e
LEFT JOIN departments d ON d.dept_id = e.dept_id;
  </pre>
  <h4>Output (LEFT):</h4>
  <table  cellpadding="6">
    <tr><th>name</th><th>dept_name</th></tr>
    <tr><td>Aathi</td><td>IT</td></tr>
    <tr><td>Siva</td><td>HR</td></tr>
    <tr><td>Meera</td><td>IT</td></tr>
    <tr><td>John</td><td>NULL</td></tr>
    <tr><td>Priya</td><td>Sales</td></tr>
    <tr><td>Aathi</td><td>IT</td></tr>
  </table>

  <p><b>RIGHT JOIN:</b> all rows from right (departments) + matches from left; unmatched ‚Üí NULL.</p>
  <pre>
SELECT d.dept_name, e.name
FROM departments d
RIGHT JOIN employees e ON d.dept_id = e.dept_id; -- (same rows as INNER in this data)
  </pre>

  <p><b>RIGHT JOIN (dept focus):</b></p>
  <pre>
SELECT d.dept_name, e.name
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id; -- dept-led view
  </pre>
  <h4>Output (dept-led LEFT, shows Finance with no employees):</h4>
  <table  cellpadding="6">
    <tr><th>dept_name</th><th>name</th></tr>
    <tr><td>IT</td><td>Aathi</td></tr>
    <tr><td>IT</td><td>Meera</td></tr>
    <tr><td>IT</td><td>Aathi</td></tr>
    <tr><td>HR</td><td>Siva</td></tr>
    <tr><td>Sales</td><td>Priya</td></tr>
    <tr><td>Finance</td><td>NULL</td></tr>
  </table>

  <p><b>FULL OUTER JOIN (MySQL trick):</b> simulate with UNION of left and right joins.</p>
  <pre>
SELECT e.name, d.dept_name
FROM employees e LEFT JOIN departments d ON d.dept_id = e.dept_id
UNION
SELECT e.name, d.dept_name
FROM employees e RIGHT JOIN departments d ON d.dept_id = e.dept_id;
  </pre>

  <p><b>CROSS JOIN:</b> Cartesian product (be careful!).</p>
  <pre>
SELECT d.dept_name, e.name
FROM departments d CROSS JOIN employees e;
  </pre>

  <p><b>NATURAL JOIN:</b> Uses same-named columns automatically (e.g., <code>dept_id</code>). Use carefully.</p>
  <pre>
SELECT e.name, d.location
FROM employees e NATURAL JOIN departments d; -- joins on dept_id implicitly
  </pre>
</div>

<div class="topic">
  <h3>7) Subqueries (Scalar, IN, EXISTS, Correlated)</h3>
  <p><b>Scalar Subquery:</b> returns one value.</p>
  <pre>
SELECT name, salary FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);
  </pre>
  <h4>Output:</h4>
  <table  cellpadding="6">
    <tr><th>name</th><th>salary</th></tr>
    <tr><td>Aathi</td><td>80000.00</td></tr>
  </table>

  <p><b>IN Subquery:</b></p>
  <pre>
-- Employees in departments located at 'HQ'
SELECT name FROM employees
WHERE dept_id IN (SELECT dept_id FROM departments WHERE location = 'HQ');
  </pre>
  <h4>Output:</h4>
  <table  cellpadding="6">
    <tr><th>name</th></tr>
    <tr><td>Aathi</td></tr>
    <tr><td>Meera</td></tr>
    <tr><td>Aathi</td></tr>
  </table>

  <p><b>EXISTS:</b> tests whether subquery returns any row.</p>
  <pre>
SELECT d.dept_name
FROM departments d
WHERE EXISTS (SELECT 1 FROM employees e WHERE e.dept_id = d.dept_id);
  </pre>
  <h4>Output:</h4>
  <table  cellpadding="6">
    <tr><th>dept_name</th></tr>
    <tr><td>IT</td></tr>
    <tr><td>HR</td></tr>
    <tr><td>Sales</td></tr>
  </table>

  <p><b>Correlated Subquery:</b> compares each row to a per-group aggregate.</p>
  <pre>
SELECT e.emp_id, e.name, e.salary
FROM employees e
WHERE e.salary &gt; (
  SELECT AVG(e2.salary)
  FROM employees e2
  WHERE e2.dept_id = e.dept_id
);
  </pre>
  <h4>Output:</h4>
  <table  cellpadding="6">
    <tr><th>emp_id</th><th>name</th><th>salary</th></tr>
    <tr><td>103</td><td>Meera</td><td>72000.00</td></tr>
    <tr><td>106</td><td>Aathi</td><td>80000.00</td></tr>
  </table>
</div>

<div class="topic">
  <h3>8) CASE Expression (Derived Columns)</h3>
  <pre>
SELECT name,
       salary,
       CASE
         WHEN salary &gt;= 70000 THEN 'High'
         WHEN salary BETWEEN 50000 AND 69999 THEN 'Medium'
         ELSE 'Low'
       END AS salary_band
FROM employees
ORDER BY salary DESC;
  </pre>
  <h4>Output:</h4>
  <table  cellpadding="6">
    <tr><th>name</th><th>salary</th><th>salary_band</th></tr>
    <tr><td>Aathi</td><td>80000.00</td><td>High</td></tr>
    <tr><td>Meera</td><td>72000.00</td><td>High</td></tr>
    <tr><td>Siva</td><td>65000.00</td><td>Medium</td></tr>
    <tr><td>Priya</td><td>65000.00</td><td>Medium</td></tr>
    <tr><td>Aathi</td><td>50000.00</td><td>Medium</td></tr>
    <tr><td>John</td><td>45000.00</td><td>Low</td></tr>
  </table>
</div>

<div class="topic">
  <h3>9) Set Operations (UNION vs UNION ALL)</h3>
  <pre>
-- UNION removes duplicates
SELECT name FROM employees WHERE dept_id = 1
UNION
SELECT name FROM employees WHERE salary &gt;= 70000;

-- UNION ALL keeps duplicates
SELECT name FROM employees WHERE dept_id = 1
UNION ALL
SELECT name FROM employees WHERE salary &gt;= 70000;
  </pre>
</div>

<div class="topic">
  <h3>10) Quick Reference ‚Äî SELECT Order</h3>
  <pre>
SELECT
  [DISTINCT] col_list
FROM
  table_or_joins
WHERE
  row_filter
GROUP BY
  group_cols
HAVING
  group_filter
ORDER BY
  sort_cols
LIMIT
  [offset,] row_count;
  </pre>
</div>

<hr>

<!-- ======================= -->
<!-- CROSS JOIN -->
<!-- ======================= -->
<div class="topic">
  <h2>CROSS JOIN in MySQL</h2>
  <p>
    <b>CROSS JOIN</b> returns the <i>Cartesian product</i> of two tables ‚Äî every row from the first table is combined with every row from the second table.
    No <code>ON</code> condition is used.
  </p>
</div>

<!-- Syntax -->
<div class="topic">
  <h3>Syntax</h3>
  <pre>
SELECT d.dept_name, e.name
FROM departments d CROSS JOIN employees e;
-- Equivalent:
-- SELECT d.dept_name, e.name FROM departments d, employees e;
  </pre>
</div>

<!-- Example Data -->
<div class="topic">
  <h3>Example Data</h3>
  <pre>
-- departments
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
| 10      | HR        |
| 20      | IT        |
+---------+-----------+

-- employees
+----+-------+---------+
| id | name  | dept_id |
+----+-------+---------+
| 1  | Alice | 10      |
| 2  | Bob   | 20      |
| 3  | Carol | NULL    |
+----+-------+---------+
  </pre>
</div>

<!-- Result -->
<div class="topic">
  <h3>Result (Cartesian Product)</h3>
  <pre>
SELECT d.dept_name, e.name
FROM departments d CROSS JOIN employees e;

-- Output (2 departments √ó 3 employees = 6 rows)
+-----------+-------+
| dept_name | name  |
+-----------+-------+
| HR        | Alice |
| HR        | Bob   |
| HR        | Carol |
| IT        | Alice |
| IT        | Bob   |
| IT        | Carol |
+-----------+-------+
  </pre>
</div>

<!-- Notes -->
<div class="topic">
  <h3>Notes & Tips</h3>
  <ul>
    <li>Row count = <b>M √ó N</b> (M rows in first table, N rows in second table).</li>
    <li>Use <code>CROSS JOIN</code> carefully on large tables ‚Äî results can explode in size.</li>
    <li>If you want only matching pairs (e.g., employee ‚Üî their department), use an <b>INNER JOIN</b> with an <code>ON</code> condition.</li>
  </ul>
</div>

<!-- Comparison -->
<div class="topic">
  <h3>Compare with INNER JOIN</h3>
  <pre>
-- Meaningful pairs (only matching dept_id)
SELECT d.dept_name, e.name
FROM departments d
INNER JOIN employees e ON d.dept_id = e.dept_id;
  </pre>
</div>

<hr>

<!-- ======================= -->
<!-- FULL OUTER JOIN -->
<!-- ======================= -->
<div class="topic">
  <h2>FULL OUTER JOIN in MySQL</h2>
  <p>
    MySQL does not directly support <b>FULL OUTER JOIN</b>.  
    Instead, you simulate it by combining a <code>LEFT JOIN</code> and a <code>RIGHT JOIN</code> using <code>UNION</code>.
  </p>
</div>

<!-- Syntax -->
<div class="topic">
  <h3>Syntax (MySQL Simulation)</h3>
  <pre>
SELECT e.name, d.dept_name
FROM employees e LEFT JOIN departments d ON e.dept_id = d.dept_id
UNION
SELECT e.name, d.dept_name
FROM employees e RIGHT JOIN departments d ON e.dept_id = d.dept_id;
  </pre>
</div>

<!-- Example Data -->
<div class="topic">
  <h3>Example Data</h3>
  <pre>
-- departments
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
| 10      | HR        |
| 20      | IT        |
| 30      | Sales     |
+---------+-----------+

-- employees
+----+-------+---------+
| id | name  | dept_id |
+----+-------+---------+
| 1  | Alice | 10      |
| 2  | Bob   | 20      |
| 3  | Carol | NULL    |
+----+-------+---------+
  </pre>
</div>

<!-- Result -->
<div class="topic">
  <h3>Result (Full Outer Join)</h3>
  <pre>
+-------+-----------+
| name  | dept_name |
+-------+-----------+
| Alice | HR        |
| Bob   | IT        |
| Carol | NULL      |  -- Employee without department
| NULL  | Sales     |  -- Department without employee
+-------+-----------+
  </pre>
</div>

<!-- Notes -->
<div class="topic">
  <h3>Notes & Tips</h3>
  <ul>
    <li><b>LEFT JOIN</b> ‚Üí keeps all employees, even if no department.</li>
    <li><b>RIGHT JOIN</b> ‚Üí keeps all departments, even if no employees.</li>
    <li><b>UNION</b> ‚Üí merges both sets, producing a <b>FULL OUTER JOIN</b>.</li>
  </ul>
</div>

<!-- Comparison -->
<div class="topic">
  <h3>Compare with Other Joins</h3>
  <pre>
-- INNER JOIN (only matching)
SELECT e.name, d.dept_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- LEFT JOIN (all employees)
SELECT e.name, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

-- RIGHT JOIN (all departments)
SELECT e.name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id;
  </pre>
</div>

<hr>

<!-- ======================= -->
<!-- NATURAL JOIN -->
<!-- ======================= -->
<div class="topic">
  <h2>NATURAL JOIN in MySQL</h2>
  <p>
    A <b>NATURAL JOIN</b> automatically joins two tables based on all columns 
    with the same name and compatible data types.  
    In this example, both <code>employees</code> and <code>departments</code> share <code>dept_id</code>, 
    so the join happens implicitly on that column.
  </p>
</div>

<!-- Syntax -->
<div class="topic">
  <h3>Syntax</h3>
  <pre>
SELECT e.name, d.location
FROM employees e NATURAL JOIN departments d;
  </pre>
</div>

<!-- Example Data -->
<div class="topic">
  <h3>Example Data</h3>
  <pre>
-- employees
+----+-------+---------+
| id | name  | dept_id |
+----+-------+---------+
| 1  | Alice | 10      |
| 2  | Bob   | 20      |
| 3  | Carol | 30      |
+----+-------+---------+

-- departments
+---------+-----------+-----------+
| dept_id | dept_name | location  |
+---------+-----------+-----------+
| 10      | HR        | New York  |
| 20      | IT        | London    |
| 30      | Sales     | Sydney    |
+---------+-----------+-----------+
  </pre>
</div>

<!-- Result -->
<div class="topic">
  <h3>Result (Natural Join)</h3>
  <pre>
+-------+-----------+
| name  | location  |
+-------+-----------+
| Alice | New York  |
| Bob   | London    |
| Carol | Sydney    |
+-------+-----------+
  </pre>
</div>

<!-- Notes -->
<div class="topic">
  <h3>Notes & Tips</h3>
  <ul>
    <li><b>No need</b> to specify the join condition explicitly.</li>
    <li>MySQL automatically finds the common column(s) ‚Äî here it is <code>dept_id</code>.</li>
    <li>Be careful: if tables share multiple columns with the same name, 
        <b>NATURAL JOIN will use all of them</b>, which may give unexpected results.</li>
    <li>If you need more control, use <code>JOIN ... ON</code> instead.</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>SQL Constraints</h2>

  <p>
    <b>Definition:</b> Constraints are rules applied to table columns to ensure 
    the accuracy, reliability, and integrity of the data.
  </p>

  <h3>Types of Constraints</h3>
  <ul>
    <li><b>NOT NULL</b> ‚Üí Ensures a column cannot have NULL values.</li>
    <li><b>UNIQUE</b> ‚Üí Ensures all values in a column are unique.</li>
    <li><b>PRIMARY KEY</b> ‚Üí Combination of NOT NULL + UNIQUE, uniquely identifies each row.</li>
    <li><b>FOREIGN KEY</b> ‚Üí Ensures referential integrity between two tables.</li>
    <li><b>CHECK</b> ‚Üí Ensures values meet a specific condition.</li>
    <li><b>DEFAULT</b> ‚Üí Provides a default value for a column if no value is specified.</li>
  </ul>

  <hr>

  <h3>1. Creating Constraints (with CREATE TABLE)</h3>
  <pre>
CREATE TABLE Students (
    student_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(50) UNIQUE,
    age INT CHECK (age >= 18),
    grade VARCHAR(2) DEFAULT 'NA'
);
  </pre>

  ‚úÖ What happens:
  - `student_id` ‚Üí Primary Key (unique + not null)  
  - `name` ‚Üí Cannot be NULL  
  - `email` ‚Üí Must be unique  
  - `age` ‚Üí Must be ‚â• 18  
  - `grade` ‚Üí Default value = 'NA' if not given  

  <hr>

  <h3>2. Adding Constraints (ALTER TABLE)</h3>
  <pre>
-- Add Primary Key
ALTER TABLE Students
ADD CONSTRAINT pk_student PRIMARY KEY (student_id);

-- Add Unique
ALTER TABLE Students
ADD CONSTRAINT uq_email UNIQUE (email);

-- Add Check
ALTER TABLE Students
ADD CONSTRAINT chk_age CHECK (age >= 18);

-- Add Foreign Key
ALTER TABLE Students
ADD CONSTRAINT fk_dept FOREIGN KEY (dept_id)
REFERENCES Departments(dept_id);
  </pre>

  <hr>

  <div class="topic">
  <h2>Updating (Modifying) Constraints</h2>

  <p>
    In SQL, you <b>cannot directly modify a constraint</b>.  
    Instead, you must <b>drop</b> the existing constraint and then <b>add a new one</b>.
  </p>

  <h3>Example: Update a CHECK Constraint</h3>
  <pre>
-- Step 1: Drop old constraint
ALTER TABLE Students 
DROP CONSTRAINT chk_age;

-- Step 2: Add new constraint
ALTER TABLE Students 
ADD CONSTRAINT chk_age CHECK (age >= 16);
  </pre>
  ‚úÖ Now the minimum age allowed is 16 instead of 18.

  <hr>

  <h3>Example: Update a DEFAULT Constraint</h3>
  <pre>
-- Step 1: Drop old default
ALTER TABLE Students 
ALTER COLUMN grade DROP DEFAULT;

-- Step 2: Add new default
ALTER TABLE Students 
ALTER COLUMN grade SET DEFAULT 'Pending';
  </pre>
  ‚úÖ New default = "Pending" instead of "NA".

  <hr>

  <h3>Example: Update a PRIMARY KEY</h3>
  <pre>
-- Drop existing primary key
ALTER TABLE Students 
DROP CONSTRAINT pk_student;

-- Add new primary key on (student_id, email)
ALTER TABLE Students 
ADD CONSTRAINT pk_student PRIMARY KEY (student_id, email);
  </pre>
  ‚úÖ Now the primary key is a composite key.

  <hr>

  <h3>Note</h3>
  <ul>
    <li>SQL does not allow <code>ALTER CONSTRAINT</code> directly.</li>
    <li>Always <b>DROP</b> the old constraint ‚Üí <b>ADD</b> the updated one.</li>
    <li>For <b>DEFAULT</b>, some databases (like SQL Server, PostgreSQL) use <code>ALTER COLUMN</code> syntax directly.</li>
  </ul>
</div>

<hr>

  <h3>3. Removing Constraints (ALTER TABLE)</h3>
  <pre>
-- Drop Primary Key
ALTER TABLE Students DROP CONSTRAINT pk_student;

-- Drop Unique
ALTER TABLE Students DROP CONSTRAINT uq_email;

-- Drop Check
ALTER TABLE Students DROP CONSTRAINT chk_age;

-- Drop Foreign Key
ALTER TABLE Students DROP CONSTRAINT fk_dept;
  </pre>

  <hr>

  <h3>4. Inserting Data Example</h3>
  <pre>
INSERT INTO Students (student_id, name, email, age) 
VALUES (1, 'Aathi', 'aathi@mail.com', 20);

INSERT INTO Students (student_id, name, email, age) 
VALUES (2, 'John', 'john@mail.com', 17); -- ‚ùå Error (age < 18)
  </pre>

  ‚úÖ Output:  
  - First row inserted successfully.  
  - Second row rejected due to `CHECK (age >= 18)` constraint.  

  <hr>

  <h3>5. FOREIGN KEY Example (Referential Integrity)</h3>
  <pre>
CREATE TABLE Departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE Employees (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Departments(dept_id)
);
  </pre>

  <pre>
-- Insert Department
INSERT INTO Departments VALUES (1, 'HR');

-- Insert Employee with valid dept_id
INSERT INTO Employees VALUES (101, 'Ram', 1); -- ‚úÖ Works

-- Insert Employee with invalid dept_id
INSERT INTO Employees VALUES (102, 'Sam', 5); -- ‚ùå Error
  </pre>

  ‚úÖ Referential Integrity ‚Üí Ensures that the `dept_id` in Employees 
  must exist in Departments.
</div>

<hr>
<div class="topic">
  <h2>Foreign Key in SQL</h2>

  <p>
    A <b>Foreign Key</b> is a column (or group of columns) in one table that refers to the <b>Primary Key</b> in another table.  
    It enforces the <b>Referential Integrity Constraint</b>, ensuring that a record in one table corresponds to a valid record in another.
  </p>

  <h3>Key Points</h3>
  <ul>
    <li>Foreign key creates a <b>relationship</b> between two tables.</li>
    <li>The referencing table (child) depends on the referenced table (parent).</li>
    <li>Foreign key values must either <b>match</b> a primary key value in the parent table or be <b>NULL</b>.</li>
    <li>Helps prevent <b>orphan records</b> (child without parent).</li>
  </ul>

  <h3>Syntax</h3>
  <pre>
-- While creating a table
CREATE TABLE child_table (
    column_name datatype,
    ...
    FOREIGN KEY (column_name) REFERENCES parent_table(parent_column)
);

-- Adding foreign key after table creation
ALTER TABLE child_table
ADD CONSTRAINT fk_name
FOREIGN KEY (column_name) REFERENCES parent_table(parent_column);
  </pre>

  <h3>Example</h3>
  <pre>
-- Parent table
CREATE TABLE Department (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

-- Child table
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);
  </pre>

  <h3>Insert Data</h3>
  <pre>
-- Insert into parent first
INSERT INTO Department VALUES (1, 'HR'), (2, 'IT');

-- Valid inserts
INSERT INTO Employee VALUES (101, 'Alice', 1);
INSERT INTO Employee VALUES (102, 'Bob', 2);

-- Invalid insert (dept_id 3 doesn't exist)
INSERT INTO Employee VALUES (103, 'Charlie', 3);
  </pre>

  <h3>Output</h3>
  <pre>
Employee Table:
+--------+----------+---------+
| emp_id | emp_name | dept_id |
+--------+----------+---------+
|   101  | Alice    |    1    |
|   102  | Bob      |    2    |
+--------+----------+---------+

(Insert for dept_id=3 fails: Foreign key constraint error)
  </pre>

  <h3>Referential Integrity</h3>
  <p>
    <b>Referential Integrity</b> means that every foreign key value must either:
    <ul>
      <li>Match a primary key in the parent table</li>
      <li>Or be NULL</li>
    </ul>
  </p>

  <h3>ON DELETE / ON UPDATE Actions</h3>
  <p>
    You can control what happens when parent data is updated or deleted:
  </p>
  <pre>
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
  </pre>
  <ul>
    <li><b>ON DELETE CASCADE</b>: If a department is deleted, all employees in that department are also deleted.</li>
    <li><b>ON UPDATE CASCADE</b>: If dept_id in Department changes, it updates automatically in Employee.</li>
    <li><b>SET NULL</b>: If parent is deleted/updated, child foreign key becomes NULL.</li>
    <li><b>RESTRICT / NO ACTION</b>: Prevents delete/update if child rows exist.</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>Difference Between Primary Key and Foreign Key</h2>

  <h3>Primary Key</h3>
  <ul>
    <li>A <b>Primary Key</b> uniquely identifies each record in a table.</li>
    <li>It does not allow <b>NULL</b> values.</li>
    <li>A table can have only <b>one primary key</b> (can be composite with multiple columns).</li>
    <li>Ensures <b>entity integrity</b> of the table.</li>
  </ul>

  <h3>Foreign Key</h3>
  <ul>
    <li>A <b>Foreign Key</b> establishes a link between two tables.</li>
    <li>It can accept <b>NULL</b> values (unless NOT NULL constraint is specified).</li>
    <li>A table can have <b>multiple foreign keys</b>.</li>
    <li>Ensures <b>referential integrity</b> between parent and child tables.</li>
  </ul>

  <h3>Comparison Table</h3>
  <table  cellpadding="5" cellspacing="0">
    <tr>
      <th>Feature</th>
      <th>Primary Key</th>
      <th>Foreign Key</th>
    </tr>
    <tr>
      <td>Purpose</td>
      <td>Uniquely identifies each record in a table</td>
      <td>Establishes a relationship between two tables</td>
    </tr>
    <tr>
      <td>NULL values</td>
      <td>Not allowed</td>
      <td>Allowed (unless NOT NULL specified)</td>
    </tr>
    <tr>
      <td>Duplicates</td>
      <td>Not allowed</td>
      <td>Allowed</td>
    </tr>
    <tr>
      <td>Count in a Table</td>
      <td>Only one primary key</td>
      <td>Can have multiple foreign keys</td>
    </tr>
    <tr>
      <td>Integrity</td>
      <td>Ensures <b>entity integrity</b></td>
      <td>Ensures <b>referential integrity</b></td>
    </tr>
    <tr>
      <td>Defined On</td>
      <td>Parent table</td>
      <td>Child table</td>
    </tr>
  </table>

  <h3>Example</h3>
  <pre>
-- Parent table
CREATE TABLE Department (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

-- Child table
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);
  </pre>

  <h3>Explanation</h3>
  <ul>
    <li><b>dept_id</b> in Department ‚Üí Primary Key (unique, no nulls)</li>
    <li><b>dept_id</b> in Employee ‚Üí Foreign Key (refers to Department‚Äôs primary key)</li>
  </ul>
</div>

<hr>
<h2>üí∞ Salary Hike and Deduction in SQL</h2>

<h3>1. Salary Hike (Increase)</h3>
<p>We can increase salary using <b>arithmetic operators</b> in SQL. Generally hike is given in % (percentage).</p>

<pre>
-- Monthly salary hike by 10%
SELECT name, salary AS old_salary,
       salary * 1.10 AS new_monthly_salary
FROM Employees;

-- Annual salary hike (12 months)
SELECT name, (salary * 12) AS old_annual_salary,
       (salary * 12 * 1.10) AS new_annual_salary
FROM Employees;
</pre>

<hr>

<h3>2. Salary Deduction (Reduction)</h3>
<p>Deduction means reducing the salary by a fixed % or fixed amount.</p>

<pre>
-- Monthly salary deduction by 5%
SELECT name, salary AS old_salary,
       salary * 0.95 AS reduced_monthly_salary
FROM Employees;

-- Annual salary deduction
SELECT name, (salary * 12) AS old_annual_salary,
       (salary * 12 * 0.95) AS reduced_annual_salary
FROM Employees;
</pre>

<hr>

<h3>3. Alias in SQL</h3>
<p>An <b>Alias</b> is a temporary name for a column or table, given using the <b>AS</b> keyword. 
It helps in making output more readable.</p>

<pre>
-- Column Alias
SELECT salary * 12 AS annual_salary
FROM Employees;

-- Table Alias
SELECT e.name, d.dept_name
FROM Employees AS e
JOIN Department AS d
ON e.dept_id = d.dept_id;

-- Without space (no quotes needed)
SELECT salary * 12 AS annual_sal
FROM Employees;

-- With space (need quotes in standard SQL)
SELECT salary * 12 AS "annual sal"
FROM Employees;

-- With space (MySQL style using backticks)
SELECT salary * 12 AS `annual sal`
FROM Employees;

</pre>


<hr>

<div class="topic">
  <h2>Data Query Language (DQL)</h2>
  <p>
    <b>Definition:</b><br>
    DQL is used to retrieve data from a database. It mainly consists of the 
    <code>SELECT</code> statement, which allows filtering, sorting, grouping, 
    and joining of data.
  </p>

  <h3>SELECT Statement</h3>
  <p>
    <b>Syntax:</b>
  </p>
  <pre>
SELECT column1, column2, ...
FROM table_name
[WHERE condition]
[GROUP BY column]
[HAVING condition]
[ORDER BY column ASC|DESC];
  </pre>

  <h3>Concepts inside SELECT</h3>
  <ul>
    <li><b>Selection</b> ‚Üí Choosing rows based on conditions (using <code>WHERE</code>).</li>
    <li><b>Projection</b> ‚Üí Choosing specific columns to display.</li>
    <li><b>Joins</b> ‚Üí Combining rows from multiple tables.</li>
  </ul>

  <h3>Example:</h3>
  <pre>
-- Table: Students
student_id | name     | age | city
-----------------------------------
1          | Alex     | 20  | London
2          | Maria    | 22  | Paris
3          | John     | 21  | London

-- Selection: only rows where city = 'London'
SELECT * FROM Students WHERE city = 'London';

Output:
student_id | name  | age | city
--------------------------------
1          | Alex  | 20  | London
3          | John  | 21  | London

-- Projection: only display name and city
SELECT name, city FROM Students;

Output:
name   | city
---------------
Alex   | London
Maria  | Paris
John   | London
  </pre>
</div>

<hr>

<div class="topic">
  <h2>SQL Joins</h2>
  <p>
    <b>Definition:</b><br>
    A JOIN is used to combine rows from two or more tables based on a related column between them.
  </p>

  <h3>Sample Tables:</h3>
  <pre>
-- Table: Students
student_id | name    | course_id
--------------------------------
1          | Alex    | 101
2          | Maria   | 102
3          | John    | 103
4          | Sophia  | NULL

-- Table: Courses
course_id | course_name
------------------------
101       | Database
102       | Java
104       | Python
  </pre>

  <!-- INNER JOIN -->
  <h3>1. INNER JOIN</h3>
  <p>
    <b>Definition:</b> Returns rows that have matching values in both tables.
  </p>
  <pre>
SELECT Students.name, Courses.course_name
FROM Students
INNER JOIN Courses ON Students.course_id = Courses.course_id;
  </pre>
  <b>Output:</b>
  <pre>
name   | course_name
---------------------
Alex   | Database
Maria  | Java
  </pre>

  <!-- LEFT JOIN -->
  <h3>2. LEFT JOIN (LEFT OUTER JOIN)</h3>
  <p>
    <b>Definition:</b> Returns all rows from the left table (Students), 
    and the matched rows from the right table (Courses). 
    If no match ‚Üí NULL values.
  </p>
  <pre>
SELECT Students.name, Courses.course_name
FROM Students
LEFT JOIN Courses ON Students.course_id = Courses.course_id;
  </pre>
  <b>Output:</b>
  <pre>
name    | course_name
----------------------
Alex    | Database
Maria   | Java
John    | NULL
Sophia  | NULL
  </pre>

  <!-- RIGHT JOIN -->
  <h3>3. RIGHT JOIN (RIGHT OUTER JOIN)</h3>
  <p>
    <b>Definition:</b> Returns all rows from the right table (Courses),
    and the matched rows from the left table (Students).
    If no match ‚Üí NULL values.
  </p>
  <pre>
SELECT Students.name, Courses.course_name
FROM Students
RIGHT JOIN Courses ON Students.course_id = Courses.course_id;
  </pre>
  <b>Output:</b>
  <pre>
name   | course_name
---------------------
Alex   | Database
Maria  | Java
NULL   | Python
  </pre>

  <!-- FULL OUTER JOIN -->
  <h3>4. FULL OUTER JOIN</h3>
  <p>
    <b>Definition:</b> Returns all rows when there is a match in one of the tables.
    (Not directly supported in MySQL, but we can simulate using UNION of LEFT and RIGHT JOIN.)
  </p>
  <pre>
SELECT Students.name, Courses.course_name
FROM Students
LEFT JOIN Courses ON Students.course_id = Courses.course_id
UNION
SELECT Students.name, Courses.course_name
FROM Students
RIGHT JOIN Courses ON Students.course_id = Courses.course_id;
  </pre>
  <b>Output:</b>
  <pre>
name    | course_name
----------------------
Alex    | Database
Maria   | Java
John    | NULL
Sophia  | NULL
NULL    | Python
  </pre>

  <!-- NATURAL JOIN -->
  <h3>5. NATURAL JOIN</h3>
  <p>
    <li><b>Definition:</b> Automatically joins tables based on columns with the same name. </li>
    <li>if there are no columns with the same name, then NATURAL JOIN becomes just a CROSS JOIN (Cartesian product). it pairs every row of the first table with every row of the second table.</li>
    <li>Natural Join = Inner Join with automatic column matching.</li>
  </p>
  <pre>
SELECT name, course_id, course_name
FROM Students
NATURAL JOIN Courses;
  </pre>
  <b>Output:</b>
  <pre>
name   | course_id | course_name
--------------------------------
Alex   | 101       | Database
Maria  | 102       | Java
  </pre>

  <!-- SELF JOIN -->
  <h3>6. SELF JOIN</h3>
  <p>
    <b>Definition:</b> A table is joined with itself.
    Useful for comparing rows in the same table.
  </p>
  <pre>
-- Example: Find students enrolled in the same course
SELECT A.name AS Student1, B.name AS Student2, A.course_id
FROM Students A
JOIN Students B ON A.course_id = B.course_id
WHERE A.student_id < B.student_id;
  </pre>
  <b>Output:</b>
  <pre>
Student1 | Student2 | course_id
--------------------------------
Alex     | Maria    | 101
  </pre>
</div>

<hr>

<div class="topic">
  <h2>SQL Subqueries</h2>
  <p>
    <b>Definition:</b><br>
    A <b>subquery</b> (or inner query) is a query inside another query.
    It is enclosed in parentheses and can be used in SELECT, WHERE, or FROM clauses.
  </p>

  <h3>Types of Subqueries:</h3>
  <ol>
    <li><b>Single-row Subquery</b> ‚Äì returns one row</li>
    <li><b>Multi-row Subquery</b> ‚Äì returns multiple rows</li>
    <li><b>Multi-column Subquery</b> ‚Äì returns multiple columns</li>
    <li><b>Correlated Subquery</b> ‚Äì depends on the outer query</li>
  </ol>

  <h3>Sample Tables:</h3>
  <pre>
-- Students
student_id | name    | course_id | marks
----------------------------------------
1          | Alex    | 101       | 85
2          | Maria   | 102       | 90
3          | John    | 103       | 70
4          | Sophia  | NULL      | 60

-- Courses
course_id | course_name
------------------------
101       | Database
102       | Java
103       | C++
104       | Python
  </pre>

  <!-- Single-row Subquery -->
  <h3>1. Single-row Subquery</h3>
  <p>
    <b>Definition:</b> Returns exactly one row. Often used with =, >, &lt;, etc.
  </p>
  <pre>
-- Find the student who has the highest marks
SELECT name, marks
FROM Students
WHERE marks = (SELECT MAX(marks) FROM Students);
  </pre>
  <b>Output:</b>
  <pre>
name   | marks
----------------
Maria  | 90
  </pre>

  <!-- Multi-row Subquery -->
  <h3>2. Multi-row Subquery</h3>
  <p>
    <b>Definition:</b> Returns multiple rows. Used with IN, ANY, ALL.
  </p>
  <pre>
-- Find students enrolled in courses 101 and 102
SELECT name, course_id
FROM Students
WHERE course_id IN (SELECT course_id FROM Courses WHERE course_id IN (101, 102));
  </pre>
  <b>Output:</b>
  <pre>
name   | course_id
-------------------
Alex   | 101
Maria  | 102
  </pre>

  <!-- Multi-column Subquery -->
  <h3>3. Multi-column Subquery</h3>
  <p>
    <b>Definition:</b> Subquery returns more than one column.
  </p>
  <pre>
-- Find students with the same (course_id, marks) as Alex
SELECT name, course_id, marks
FROM Students
WHERE (course_id, marks) = (SELECT course_id, marks FROM Students WHERE name='Alex');
  </pre>
  <b>Output:</b>
  <pre>
name   | course_id | marks
----------------------------
Alex   | 101       | 85
  </pre>

  <!-- Correlated Subquery -->
  <h3>4. Correlated Subquery</h3>
  <p>
    <b>Definition:</b> A subquery that depends on values from the outer query.
    It is executed for each row of the outer query.
  </p>
  <pre>
-- Find students who have marks greater than the average marks of their course
SELECT name, marks, course_id
FROM Students S
WHERE marks > (SELECT AVG(marks) 
               FROM Students 
               WHERE course_id = S.course_id);
  </pre>
  <b>Output:</b>
  <pre>
name   | marks | course_id
----------------------------
Alex   | 85    | 101
Maria  | 90    | 102
  </pre>
</div>

<hr>

<div class="topic">
  <h2>Subquery Operators in SQL</h2>

  <p>
    Subquery operators are used when comparing a value from the main query with 
    a set of values returned by a subquery.
  </p>

  <h3>1. IN</h3>
  <p>
    Checks if a value matches <b>any value</b> returned by a subquery.
  </p>
  <pre>
-- Employees working in departments located in 'Chennai'
SELECT name
FROM Employees
WHERE dept_id IN (
    SELECT dept_id FROM Departments WHERE location = 'Chennai'
);
  </pre>

  <h3>2. ANY / SOME</h3>
  <p>
    - <b>ANY</b> and <b>SOME</b> are the same.  
    - They compare a value to <u>each value</u> returned by the subquery 
      and return TRUE if the condition is satisfied by <b>at least one value</b>.
  </p>
  <pre>
-- Employees earning more than at least one IT employee
SELECT name, salary
FROM Employees
WHERE salary > ANY (
    SELECT salary FROM Employees WHERE dept = 'IT'
);
  </pre>

  <h3>3. ALL</h3>
  <p>
    Compares a value with <u>all values</u> from the subquery.  
    The condition must be true for <b>every value</b> in the subquery.
  </p>
  <pre>
-- Employees earning more than all IT employees
SELECT name, salary
FROM Employees
WHERE salary > ALL (
    SELECT salary FROM Employees WHERE dept = 'IT'
);
  </pre>

  <h3>4. EXISTS</h3>
  <p>
    Returns TRUE if the subquery returns <b>at least one row</b>.
  </p>
  <pre>
-- Employees whose department exists in the Departments table
SELECT name
FROM Employees E
WHERE EXISTS (
    SELECT 1 FROM Departments D WHERE E.dept_id = D.dept_id
);
  </pre>

  <h3>5. NOT IN / NOT EXISTS</h3>
  <p>
    - <b>NOT IN</b>: TRUE if the value is not in the subquery result.  
    - <b>NOT EXISTS</b>: TRUE if the subquery returns no rows.
  </p>
  <pre>
-- Employees not working in any department in 'Chennai'
SELECT name
FROM Employees
WHERE dept_id NOT IN (
    SELECT dept_id FROM Departments WHERE location = 'Chennai'
);

-- Employees without a matching department
SELECT name
FROM Employees E
WHERE NOT EXISTS (
    SELECT 1 FROM Departments D WHERE E.dept_id = D.dept_id
);
  </pre>
</div>

<hr>

<div class="topic">
  <h2>Difference: Subquery vs Correlated Subquery</h2>

  <table  cellpadding="6" cellspacing="0">
    <tr>
      <th>Feature</th>
      <th>Subquery</th>
      <th>Correlated Subquery</th>
    </tr>

    <tr>
      <td><b>Definition</b></td>
      <td>A query inside another query, executed <b>only once</b>. The result is passed to the outer query.</td>
      <td>A query inside another query that depends on the outer query. It is executed <b>for every row</b> of the outer query.</td>
    </tr>

    <tr>
      <td><b>Execution</b></td>
      <td>Executed first, then its result is used by the outer query.</td>
      <td>Executed repeatedly (row by row) because it references columns from the outer query.</td>
    </tr>

    <tr>
      <td><b>Dependency</b></td>
      <td>Independent of the outer query.</td>
      <td>Dependent on the outer query for values.</td>
    </tr>

    <tr>
      <td><b>Performance</b></td>
      <td>Usually faster since it runs only once.</td>
      <td>Slower for large datasets since it runs multiple times.</td>
    </tr>

    <tr>
      <td><b>Example</b></td>
      <td>
        Find students with marks equal to the highest marks:<br>
        <pre>
SELECT name, marks
FROM Students
WHERE marks = (SELECT MAX(marks) FROM Students);
        </pre>
      </td>
      <td>
        Find students who scored above the average marks of their course:<br>
        <pre>
SELECT name, marks, course_id
FROM Students S
WHERE marks > (SELECT AVG(marks) 
               FROM Students 
               WHERE course_id = S.course_id);
        </pre>
      </td>
    </tr>

    <tr>
      <td><b>Output (for example)</b></td>
      <td>
        <pre>
name   | marks
----------------
Maria  | 90
        </pre>
      </td>
      <td>
        <pre>
name   | marks | course_id
----------------------------
Alex   | 85    | 101
Maria  | 90    | 102
        </pre>
      </td>
    </tr>
  </table>
</div>

<hr>

<div class="topic">
  <h2>Aggregate Functions in SQL</h2>

  <p>
    <b>Definition:</b> Aggregate functions perform calculations on a set of values and return a single value.  
    They are often used with <code>GROUP BY</code>.
  </p>

  <h3>1. COUNT()</h3>
  <p>Counts the number of rows.</p>
  <pre>
SELECT COUNT(*) AS total_orders FROM Orders;

-- Output:
total_orders
------------
5
  </pre>

  <h3>2. SUM()</h3>
  <p>Returns the total sum of a numeric column.</p>
  <pre>
SELECT SUM(amount) AS total_revenue FROM Orders;

-- Output:
total_revenue
-------------
1150
  </pre>

  <h3>3. AVG()</h3>
  <p>Returns the average value of a numeric column.</p>
  <pre>
SELECT AVG(amount) AS avg_amount FROM Orders;

-- Output:
avg_amount
----------
230.00
  </pre>

  <h3>4. MAX()</h3>
  <p>Returns the maximum value.</p>
  <pre>
SELECT MAX(amount) AS max_purchase FROM Orders;

-- Output:
max_purchase
------------
400
  </pre>

  <h3>5. MIN()</h3>
  <p>Returns the minimum value.</p>
  <pre>
SELECT MIN(amount) AS min_purchase FROM Orders;

-- Output:
min_purchase
------------
100
  </pre>
</div>

<hr>

<h1>SQL LIKE Operator</h1>
  <p>The <code>LIKE</code> operator is used in a <code>WHERE</code> clause to search for a specified pattern in a column.</p>

  <h2>Wildcards</h2>
  <ul>
    <li><b>%</b> ‚Üí Represents zero, one, or many characters.</li>
    <li><b>_</b> ‚Üí Represents exactly one character.</li>
  </ul>

  <h2>Example Table: Customers</h2>
  <table>
    <tr><th>customer_id</th><th>name</th><th>city</th></tr>
    <tr><td>1</td><td>Ravi</td><td>Delhi</td></tr>
    <tr><td>2</td><td>Amit</td><td>Mumbai</td></tr>
    <tr><td>3</td><td>Priya</td><td>Chennai</td></tr>
    <tr><td>4</td><td>Vinod</td><td>Kolkata</td></tr>
    <tr><td>5</td><td>Nisha</td><td>Delhi</td></tr>
  </table>

  <h2>1. Names starting with 'P'</h2>
  <pre>SELECT * FROM Customers WHERE name LIKE 'P%';</pre>
  <table>
    <tr><th>customer_id</th><th>name</th><th>city</th></tr>
    <tr><td>3</td><td>Priya</td><td>Chennai</td></tr>
  </table>

  <h2>2. Names ending with 'a'</h2>
  <pre>SELECT * FROM Customers WHERE name LIKE '%a';</pre>
  <table>
    <tr><th>customer_id</th><th>name</th><th>city</th></tr>
    <tr><td>3</td><td>Priya</td><td>Chennai</td></tr>
    <tr><td>5</td><td>Nisha</td><td>Delhi</td></tr>
  </table>

  <h2>3. Names containing 'i'</h2>
  <pre>SELECT * FROM Customers WHERE name LIKE '%i%';</pre>
  <table>
    <tr><th>customer_id</th><th>name</th><th>city</th></tr>
    <tr><td>1</td><td>Ravi</td><td>Delhi</td></tr>
    <tr><td>2</td><td>Amit</td><td>Mumbai</td></tr>
    <tr><td>3</td><td>Priya</td><td>Chennai</td></tr>
    <tr><td>4</td><td>Vinod</td><td>Kolkata</td></tr>
    <tr><td>5</td><td>Nisha</td><td>Delhi</td></tr>
  </table>

  <h2>4. Second character is 'i'</h2>
  <pre>SELECT * FROM Customers WHERE name LIKE '_i%';</pre>
  <table>
    <tr><th>customer_id</th><th>name</th><th>city</th></tr>
    <tr><td>2</td><td>Amit</td><td>Mumbai</td></tr>
    <tr><td>4</td><td>Vinod</td><td>Kolkata</td></tr>
    <tr><td>5</td><td>Nisha</td><td>Delhi</td></tr>
  </table>

  <h2>5. Names with exactly 4 letters</h2>
  <pre>SELECT * FROM Customers WHERE name LIKE '____';</pre>
  <table>
    <tr><th>customer_id</th><th>name</th><th>city</th></tr>
    <tr><td>1</td><td>Ravi</td><td>Delhi</td></tr>
    <tr><td>2</td><td>Amit</td><td>Mumbai</td></tr>
  </table>

  <hr>
  
<div class="topic">
  <h2>ORDER BY in SQL</h2>

  <p>
    <b>Definition:</b> <code>ORDER BY</code> is used to sort the result set in ascending (ASC) or descending (DESC) order.  
    By default, it sorts in <b>ascending order</b>.
  </p>

  <p><b>Syntax:</b></p>
  <pre>
SELECT column1, column2
FROM table_name
ORDER BY column_name [ASC|DESC];
  </pre>

  <h3>Example 1: Ascending Order</h3>
  <pre>
SELECT * FROM Orders
ORDER BY amount ASC;

-- Output:
order_id | customer_id | amount
--------------------------------
5        | 102         | 100
4        | 103         | 150
1        | 101         | 200
2        | 102         | 300
3        | 101         | 400
  </pre>

  <h3>Example 2: Descending Order</h3>
  <pre>
SELECT * FROM Orders
ORDER BY amount DESC;

-- Output:
order_id | customer_id | amount
--------------------------------
3        | 101         | 400
2        | 102         | 300
1        | 101         | 200
4        | 103         | 150
5        | 102         | 100
  </pre>

  <h3>Example 3: Multiple Columns</h3>
  <pre>
SELECT * FROM Orders
ORDER BY customer_id ASC, amount DESC;

-- Output:
order_id | customer_id | amount
--------------------------------
3        | 101         | 400
1        | 101         | 200
2        | 102         | 300
5        | 102         | 100
4        | 103         | 150
  </pre>
</div>

<hr>

<div class="topic">
  <h2>Set Operations in SQL</h2>

  <p>
    <b>Definition:</b> Set operations combine the results of two or more SELECT queries into a single result set.  
    The queries must return the <b>same number of columns</b> and the columns must have <b>compatible data types</b>.
  </p>

  <h3>Types of Set Operations</h3>
  <ol>
    <li>UNION</li>
    <li>UNION ALL</li>
    <li>INTERSECT</li>
    <li>EXCEPT (or MINUS in Oracle)</li>
  </ol>

  <hr>

  <h3>1. UNION</h3>
  <p>Combines results from two queries, removing <b>duplicates</b>.</p>
  <pre>
SELECT city FROM Customers
UNION
SELECT city FROM Suppliers;

-- Output:
city
---------
Chennai
Delhi
Mumbai
Kolkata
Bangalore
  </pre>

  <hr>

  <h3>2. UNION ALL</h3>
  <p>Combines results from two queries, <b>including duplicates</b>.</p>
  <pre>
SELECT city FROM Customers
UNION ALL
SELECT city FROM Suppliers;

-- Output:
city
---------
Chennai
Delhi
Delhi
Mumbai
Kolkata
Bangalore
  </pre>

  <hr>

  <h3>3. INTERSECT</h3>
  <p>Returns only the <b>common rows</b> from both queries.</p>
  <pre>
SELECT city FROM Customers
INTERSECT
SELECT city FROM Suppliers;

-- Output:
city
---------
Delhi
  </pre>

  <hr>

  <h3>4. EXCEPT / MINUS</h3>
  <p>Returns rows from the first query that are <b>not present</b> in the second query.</p>
  <pre>
SELECT city FROM Customers
EXCEPT
SELECT city FROM Suppliers;

-- Output:
city
---------
Chennai
Mumbai
Kolkata
  </pre>
</div>

<hr>

<div class="topic">
  <h2>Special Operators in SQL</h2>

  <p>
    SQL provides some special operators that help in filtering data using conditions.
    These are commonly used inside the <b>WHERE</b> clause.
  </p>

  <h3>1. IN Operator</h3>
  <p>
    The <b>IN</b> operator is used to check whether a value matches any value in a list.
  </p>
  <pre>
SELECT * FROM Customers
WHERE city IN ('Delhi', 'Mumbai');

-- Output:
customer_id | name    | city
--------------------------------
1           | Aathi   | Delhi
2           | Ramesh  | Mumbai
  </pre>

  <h3>2. NOT IN Operator</h3>
  <p>
    The <b>NOT IN</b> operator is used to exclude values from a list.
  </p>
  <pre>
SELECT * FROM Customers
WHERE city NOT IN ('Delhi', 'Mumbai');

-- Output:
customer_id | name    | city
--------------------------------
3           | Priya   | Chennai
4           | Suresh  | Kolkata
  </pre>

  <h3>3. BETWEEN Operator</h3>
  <p>
    The <b>BETWEEN</b> operator selects values within a given range (inclusive).
  </p>
  <pre>
SELECT * FROM Orders
WHERE amount BETWEEN 1000 AND 5000;

-- Output:
order_id | customer_id | amount
--------------------------------
101      | 1           | 1500
102      | 2           | 3000
104      | 4           | 5000
  </pre>

  <h3>4. NOT BETWEEN Operator</h3>
  <p>
    The <b>NOT BETWEEN</b> operator selects values <b>outside</b> the range.
  </p>
  <pre>
SELECT * FROM Orders
WHERE amount NOT BETWEEN 1000 AND 5000;

-- Output:
order_id | customer_id | amount
--------------------------------
103      | 3           | 700
105      | 5           | 6000
  </pre>

  <h3>5. LIKE Operator</h3>
  <p>
    The <b>LIKE</b> operator is used for pattern matching with wildcards:
    <ul>
      <li><b>%</b> ‚Üí Matches zero or more characters</li>
      <li><b>_</b> ‚Üí Matches exactly one character</li>
    </ul>
  </p>
  <pre>
SELECT * FROM Customers
WHERE name LIKE 'A%';

-- Output (names starting with A):
customer_id | name   | city
--------------------------------
1           | Aathi  | Delhi
5           | Anitha | Bangalore

SELECT * FROM Customers
WHERE name LIKE '_i%';

-- Output (second character is 'i'):
customer_id | name   | city
--------------------------------
3           | Priya  | Chennai
  </pre>

  <h3>6. IS NULL Operator</h3>
  <p>
    The <b>IS NULL</b> operator checks for NULL values (missing/unknown data).
  </p>
  <pre>
SELECT * FROM Customers
WHERE phone IS NULL;

-- Output:
customer_id | name   | city    | phone
--------------------------------
4           | Suresh | Kolkata | NULL
  </pre>

  <h3>7. IS NOT NULL Operator</h3>
  <p>
    The <b>IS NOT NULL</b> operator checks for non-NULL values.
  </p>
  <pre>
SELECT * FROM Customers
WHERE phone IS NOT NULL;

-- Output:
customer_id | name   | city    | phone
--------------------------------
1           | Aathi  | Delhi   | 9876543210
2           | Ramesh | Mumbai  | 8765432109
3           | Priya  | Chennai | 7654321098
  </pre>
</div>

  <h3>8. EXISTS Operator</h3>
  <p>
    <b>EXISTS</b> is used to check whether a subquery returns any rows.
    - Returns TRUE if the subquery has at least one row.  
    - Usually used with correlated subqueries.
  </p>
  <pre>
-- Example: Find customers who have placed at least one order
SELECT name
FROM Customers c
WHERE EXISTS (
    SELECT 1 FROM Orders o
    WHERE o.customer_id = c.customer_id
);

-- Output:
name
---------
Aathi
Ramesh
Priya
  </pre>

  <h3>9. NOT EXISTS Operator</h3>
  <p>
    <b>NOT EXISTS</b> checks if a subquery returns no rows.
  </p>
  <pre>
-- Example: Find customers who have not placed any order
SELECT name
FROM Customers c
WHERE NOT EXISTS (
    SELECT 1 FROM Orders o
    WHERE o.customer_id = c.customer_id
);

-- Output:
name
---------
Suresh
Anitha
  </pre>

  <h3>10. SOME (or ANY) Operator</h3>
  <p>
    <b>SOME</b> (or its synonym <b>ANY</b>) compares a value with a set of values returned by a subquery.
    It returns TRUE if the condition matches <u>at least one</u> value in the list.
  </p>
  <pre>
-- Example: Find orders where amount is greater than SOME of the amounts placed by customer_id = 1
SELECT order_id, amount
FROM Orders
WHERE amount > SOME (
    SELECT amount FROM Orders WHERE customer_id = 1
);

-- Suppose customer 1 has amounts: 1500, 3000
-- Then "greater than SOME" means: greater than at least one (1500 or 3000)

-- Output:
order_id | amount
-----------------
104      | 5000
105      | 6000
  </pre>

  <h3>10. ALL Operator</h3>
  <p>
    <b>ALL</b> compares a value with <u>all values</u> returned by a subquery.
    It returns TRUE only if the condition is true for every value.
  </p>
  <pre>
-- Example: Find orders where amount is greater than ALL amounts placed by customer_id = 1
SELECT order_id, amount
FROM Orders
WHERE amount > ALL (
    SELECT amount FROM Orders WHERE customer_id = 1
);

-- Suppose customer 1 has amounts: 1500, 3000
-- Then "greater than ALL" means: greater than both 1500 and 3000

-- Output:
order_id | amount
-----------------
104      | 5000
105      | 6000
  </pre>
</div>

<hr>

<div class="topic">
  <h2>DISTINCT in SQL</h2>

  <p>
    <b>DISTINCT</b> is used to remove duplicate rows from the result set.  
    It ensures that only <u>unique values</u> are returned.
  </p>

  <h3>1. Syntax</h3>
  <pre>
SELECT DISTINCT column1, column2, ...
FROM table_name;
  </pre>

  <h3>2. Example: Single Column</h3>
  <pre>
-- Table: Customers
customer_id | name   | city
-----------------------------
1           | Aathi  | Chennai
2           | Ramesh | Mumbai
3           | Priya  | Chennai
4           | Suresh | Delhi
5           | Anitha | Mumbai

-- Query: Get unique cities
SELECT DISTINCT city
FROM Customers;

-- Output:
city
---------
Chennai
Mumbai
Delhi
  </pre>

  <h3>3. Example: Multiple Columns</h3>
  <p>
    When multiple columns are used, DISTINCT removes rows where <u>all selected column values</u> are the same.
  </p>
  <pre>
-- Query: Get unique combinations of (city, name)
SELECT DISTINCT city, name
FROM Customers;

-- Output:
city     | name
-----------------
Chennai  | Aathi
Mumbai   | Ramesh
Chennai  | Priya
Delhi    | Suresh
Mumbai   | Anitha
  </pre>

  <h3>4. Example with COUNT()</h3>
  <p>
    Often used with <b>COUNT</b> to find number of unique values.
  </p>
  <pre>
-- Query: Count unique cities
SELECT COUNT(DISTINCT city) AS unique_cities
FROM Customers;

-- Output:
unique_cities
--------------
3
  </pre>

  <h3>5. Important Notes</h3>
  <ul>
    <li><b>DISTINCT applies to all selected columns</b> (not just one).</li>
    <li>If you want uniqueness on a single column but still include others, use <code>GROUP BY</code>.</li>
    <li>DISTINCT may reduce performance on very large datasets because it requires sorting/aggregation.</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>Logical Operators in SQL</h2>

  <p>
    Logical operators are used in the <b>WHERE</b> clause to filter records based on multiple conditions.
  </p>

  <h3>1. AND Operator</h3>
  <p>
    The <b>AND</b> operator returns records if <u>all conditions</u> separated by AND are true.
  </p>
  <pre>
-- Table: Employees
emp_id | name    | dept    | salary
------------------------------------
1      | Aathi   | HR      | 30000
2      | Ramesh  | IT      | 60000
3      | Priya   | IT      | 45000
4      | Suresh  | HR      | 28000
5      | Anitha  | IT      | 70000

-- Query: Employees in IT dept with salary > 50000
SELECT * 
FROM Employees
WHERE dept = 'IT' AND salary > 50000;

-- Output:
emp_id | name    | dept | salary
--------------------------------
2      | Ramesh  | IT   | 60000
5      | Anitha  | IT   | 70000
  </pre>

  <h3>2. OR Operator</h3>
  <p>
    The <b>OR</b> operator returns records if <u>at least one condition</u> is true.
  </p>
  <pre>
-- Query: Employees in HR dept OR salary > 60000
SELECT *
FROM Employees
WHERE dept = 'HR' OR salary > 60000;

-- Output:
emp_id | name    | dept | salary
--------------------------------
1      | Aathi   | HR   | 30000
4      | Suresh  | HR   | 28000
5      | Anitha  | IT   | 70000
  </pre>

  <h3>3. NOT Operator</h3>
  <p>
    The <b>NOT</b> operator reverses the result of a condition.
  </p>
  <pre>
-- Query: Employees not in HR dept
SELECT *
FROM Employees
WHERE NOT dept = 'HR';

-- Output:
emp_id | name    | dept | salary
--------------------------------
2      | Ramesh  | IT   | 60000
3      | Priya   | IT   | 45000
5      | Anitha  | IT   | 70000
  </pre>

  <h3>4. Combining AND, OR, NOT</h3>
  <p>
    Multiple logical operators can be combined. Use parentheses <code>()</code> to control order of evaluation.
  </p>
  <pre>
-- Query: Employees in IT dept with salary > 40000 OR NOT in HR
SELECT *
FROM Employees
WHERE (dept = 'IT' AND salary > 40000) OR NOT dept = 'HR';

-- Output:
emp_id | name    | dept | salary
--------------------------------
2      | Ramesh  | IT   | 60000
3      | Priya   | IT   | 45000
5      | Anitha  | IT   | 70000
  </pre>

  <h3>5. Other Common Operators in SQL</h3>
  <ul>
    <li><b>=</b> ‚Üí equal to</li>
    <li><b>&lt;&gt;</b> or <b>!=</b> ‚Üí not equal to</li>
    <li><b>&gt;</b>, <b>&lt;</b>, <b>&gt;=</b>, <b>&lt;=</b> ‚Üí comparison operators</li>
    <li><b>BETWEEN ... AND ...</b> ‚Üí check if value is within range</li>
    <li><b>IN (...)</b> ‚Üí check if value exists in a list</li>
    <li><b>LIKE</b> ‚Üí pattern matching (%, _)</li>
    <li><b>IS NULL / IS NOT NULL</b> ‚Üí check for NULL values</li>
    <li><b>EXISTS</b> ‚Üí check if subquery returns any rows</li>
    <li><b>SOME / ANY / ALL</b> ‚Üí compare with a set of values</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>SQL Functions</h2>

  <p>
    Functions are built-in operations provided by SQL to manipulate data, 
    perform calculations, or format results.  
  </p>

  <h3>Types of SQL Functions</h3>
  <ul>
    <li><b>1. Single-row (Scalar) Functions</b> ‚Üí operate on <u>one row at a time</u> and return a single value.</li>
    <li><b>2. Multi-row (Aggregate) (Group) Functions</b> ‚Üí operate on <u>multiple rows</u> and return one value for the group.</li>
  </ul>

  <hr>

  <h3>1. Single-Row (Scalar) Functions</h3>
  <p>These work on each row individually.</p>

  <h4>a) String Functions</h4>
  <pre>
-- Convert to upper/lower
SELECT UPPER('hello'), LOWER('HELLO');

-- Get substring
SELECT SUBSTRING('Database', 1, 4);  -- Output: Data

-- String length
SELECT LENGTH('SQL Tutorial');
  </pre>

  <h4>b) Numeric Functions</h4>
  <pre>
SELECT ABS(-10);     -- 10
SELECT CEIL(12.3);   -- 13
SELECT FLOOR(12.9);  -- 12
SELECT ROUND(123.456, 2);  -- 123.46
SELECT POWER(2, 3);  -- 8
  </pre>

  <h4>c) Date/Time Functions</h4>
  <pre>
SELECT CURRENT_DATE;        -- Today's date
SELECT CURRENT_TIME;        -- Current time
SELECT NOW();               -- Current timestamp
SELECT EXTRACT(YEAR FROM NOW());  -- Extract year
  </pre>

  <h4>d) Conversion Functions</h4>
  <pre>
SELECT CAST('2025-08-22' AS DATE);
SELECT CAST(123.45 AS INT);
  </pre>

  <hr>

  <h3>2. Aggregate Functions</h3>
  <p>These operate on groups of rows.</p>

  <pre>
-- Employee table (id, name, salary, dept)
SELECT COUNT(*) FROM Employees;          -- Total rows
SELECT MAX(salary) FROM Employees;       -- Highest salary
SELECT MIN(salary) FROM Employees;       -- Lowest salary
SELECT SUM(salary) FROM Employees;       -- Total salary
SELECT AVG(salary) FROM Employees;       -- Average salary

-- Grouping with aggregate
SELECT dept, AVG(salary)
FROM Employees
GROUP BY dept;
  </pre>
</div>

<hr>

<!-- ======================= -->
<!-- TCL -->
<!-- ======================= -->
<div class="topic">
  <h2>TCL in MySQL</h2>
  <p>
    TCL (Transaction Control Language) commands are used to manage transactions in a database.  
    Transactions allow multiple operations to be executed as a single unit of work.  
    They ensure <b>ACID properties</b> (Atomicity, Consistency, Isolation, Durability).
  </p>
</div>

<!-- 1) START TRANSACTION -->
<div class="topic">
  <h3>1) START TRANSACTION</h3>
  <pre>
-- Begin a transaction
START TRANSACTION;

-- Example
START TRANSACTION;
UPDATE accounts SET balance = balance - 500 WHERE acc_id = 101;
UPDATE accounts SET balance = balance + 500 WHERE acc_id = 102;
  </pre>
</div>

<!-- 2) COMMIT -->
<div class="topic">
  <h3>2) COMMIT</h3>
  <p>Commits (saves) all changes made during the current transaction permanently to the database.</p>
  <pre>
COMMIT;
  </pre>
</div>

<!-- 3) ROLLBACK -->
<div class="topic">
  <h3>3) ROLLBACK</h3>
  <p>Undo all changes made in the current transaction (before commit).</p>
  <pre>
ROLLBACK;
  </pre>
</div>

<!-- 4) SAVEPOINT -->
<div class="topic">
  <h3>4) SAVEPOINT</h3>
  <p>Create a point inside a transaction to which you can roll back.</p>
  <pre>
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE acc_id = 101;
SAVEPOINT sp1;

UPDATE accounts SET balance = balance + 200 WHERE acc_id = 102;
ROLLBACK TO sp1; -- Undo only changes after sp1
  </pre>
</div>

<!-- 5) RELEASE SAVEPOINT -->
<div class="topic">
  <h3>5) RELEASE SAVEPOINT</h3>
  <p>Delete a named savepoint, so it can‚Äôt be used for rollback.</p>
  <pre>
RELEASE SAVEPOINT sp1;
  </pre>
</div>

<!-- 6) AUTOCOMMIT -->
<div class="topic">
  <h3>6) AUTOCOMMIT</h3>
  <p>By default MySQL runs in AUTOCOMMIT mode (each query is committed automatically).  
     You can disable it and manage transactions manually.</p>
  <pre>
-- Disable autocommit
SET AUTOCOMMIT = 0;

-- Enable autocommit again
SET AUTOCOMMIT = 1;
  </pre>
</div>

<hr>

<div class="topic">
  <h2>Transaction Control Language (TCL)</h2>

  <p><b>TCL</b> is used to manage transactions in a database.  
  A <b>transaction</b> is a set of one or more SQL statements executed as a single unit of work.</p>

  <h3>Common TCL Commands</h3>
  <ul>
    <li><b>COMMIT</b> ‚Äì Saves all changes made by the transaction permanently.</li>
    <li><b>ROLLBACK</b> ‚Äì Undoes all changes made by the current transaction.</li>
    <li><b>SAVEPOINT</b> ‚Äì Creates a point within a transaction to which you can rollback later.</li>
    <li><b>ROLLBACK TO SAVEPOINT</b> ‚Äì Undoes part of the transaction, back to the defined savepoint.</li>
  </ul>

  <h3>1. COMMIT</h3>
  <pre>
-- Example: Insert a record and save permanently
INSERT INTO Employee(emp_id, emp_name, dept_id) VALUES (101, 'John', 1);
COMMIT;
  </pre>
  <p><b>Output:</b> Data is permanently saved in the table.</p>

  <h3>2. ROLLBACK</h3>
  <pre>
-- Example: Insert but undo changes
INSERT INTO Employee(emp_id, emp_name, dept_id) VALUES (102, 'Alice', 2);
ROLLBACK;
  </pre>
  <p><b>Output:</b> The record of Alice will not exist in the table (undone).</p>

  <h3>3. SAVEPOINT</h3>
  <pre>
-- Example with SAVEPOINT
INSERT INTO Employee(emp_id, emp_name, dept_id) VALUES (103, 'David', 1);
SAVEPOINT sp1;

INSERT INTO Employee(emp_id, emp_name, dept_id) VALUES (104, 'Emma', 2);
SAVEPOINT sp2;

-- Rollback only to sp1
ROLLBACK TO sp1;
COMMIT;
  </pre>
  <p><b>Output:</b> Record with <b>emp_id = 103</b> is saved.  
  Record with <b>emp_id = 104</b> is removed (rolled back).</p>

  <h3>Important Notes</h3>
  <ul>
    <li>TCL works only with <b>DML statements</b> (INSERT, UPDATE, DELETE).</li>
    <li>DDL statements (CREATE, DROP, ALTER) auto-commit, so TCL doesn‚Äôt apply to them.</li>
    <li>Once <b>COMMIT</b> is done, changes cannot be rolled back.</li>
  </ul>
</div>

<hr>

<!-- ======================= -->
<!-- DCL -->
<!-- ======================= -->
<div class="topic">
  <h2>DCL in MySQL</h2>
  <p>
    DCL (Data Control Language) commands are used to control access and permissions in a database.  
    They help in managing <b>authorization</b> and <b>security</b>.
  </p>
</div>

<!-- 1) GRANT -->
<div class="topic">
  <h3>1) GRANT</h3>
  <p>Used to provide specific privileges (permissions) to a user.</p>
  <pre>
-- Syntax
GRANT privilege_list ON database.table TO 'username'@'host';

-- Example: Give SELECT and INSERT permission on "student" table to user 'john'
GRANT SELECT, INSERT ON mydb.student TO 'john'@'localhost';
  </pre>
</div>

<!-- 2) REVOKE -->
<div class="topic">
  <h3>2) REVOKE</h3>
  <p>Used to remove (take back) privileges from a user.</p>
  <pre>
-- Syntax
REVOKE privilege_list ON database.table FROM 'username'@'host';

-- Example: Remove INSERT permission from 'john'
REVOKE INSERT ON mydb.student FROM 'john'@'localhost';
  </pre>
</div>

<!-- 3) SHOW GRANTS -->
<div class="topic">
  <h3>3) SHOW GRANTS</h3>
  <p>Used to display the privileges granted to a user.</p>
  <pre>
-- Example: Show grants for user 'john'
SHOW GRANTS FOR 'john'@'localhost';
  </pre>
</div>

<!-- Notes -->
<div class="topic">
  <h3>üîπ Notes</h3>
  <ul>
    <li>Privileges can be given at <b>global</b>, <b>database</b>, <b>table</b>, or <b>column</b> level.</li>
    <li>Common privileges: <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALL PRIVILEGES</code>.</li>
    <li>Only users with <b>ADMIN</b> or <b>SUPER</b> privilege can grant/revoke permissions.</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>Data Control Language (DCL)</h2>

  <p><b>DCL</b> is used to control access and permissions to the data stored in the database.  
  It ensures <b>security</b> and controls who can perform operations on tables, views, procedures, etc.</p>

  <h3>Common DCL Commands</h3>
  <ul>
    <li><b>GRANT</b> ‚Äì Provides a user specific privileges on database objects.</li>
    <li><b>REVOKE</b> ‚Äì Removes the privileges granted to a user.</li>
  </ul>

  <h3>1. GRANT</h3>
  <p>Syntax:</p>
  <pre>
GRANT privilege_name 
ON object_name 
TO user_name;
  </pre>

  <p>Example:</p>
  <pre>
-- Grant SELECT and INSERT permission to user 'john'
GRANT SELECT, INSERT
ON Employee
TO john;
  </pre>

  <p><b>Output:</b> User <b>john</b> can now select and insert rows into the <b>Employee</b> table.</p>

  <h3>2. REVOKE</h3>
  <p>Syntax:</p>
  <pre>
REVOKE privilege_name 
ON object_name 
FROM user_name;
  </pre>

  <p>Example:</p>
  <pre>
-- Remove INSERT permission from user 'john'
REVOKE INSERT
ON Employee
FROM john;
  </pre>

  <p><b>Output:</b> User <b>john</b> cannot insert rows into the <b>Employee</b> table anymore,  
  but still has <b>SELECT</b> permission (since only INSERT was revoked).</p>

  <h3>Important Notes</h3>
  <ul>
    <li>Privileges include: <b>SELECT, INSERT, UPDATE, DELETE, ALL</b>, etc.</li>
    <li>Only database administrators (DBA) or object owners can grant/revoke privileges.</li>
    <li>Granting <b>ALL</b> means the user can do anything on that table.</li>
    <li>DCL ensures <b>data security</b> by restricting unauthorized access.</li>
  </ul>
</div>

<hr>


<h1>SQL GROUP BY</h1>

<p>The <b>GROUP BY</b> clause in SQL is used to group rows that have the same values into summary rows, often used with aggregate functions (<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code>).</p>

<hr>

<h2>1. Basic GROUP BY</h2>
<pre>
SELECT dept_id, COUNT(*) AS total_employees
FROM employees
GROUP BY dept_id;
</pre>

<p><b>Explanation:</b> Groups employees by department and counts how many are in each department.</p>

<table>
  <tr><th>dept_id</th><th>total_employees</th></tr>
  <tr><td>101</td><td>3</td></tr>
  <tr><td>102</td><td>2</td></tr>
  <tr><td>103</td><td>4</td></tr>
</table>

<hr>

<h2>2. GROUP BY with SUM</h2>
<pre>
SELECT dept_id, SUM(salary) AS total_salary
FROM employees
GROUP BY dept_id;
</pre>
<p><b>Explanation:</b> Sums salaries for each department.</p>

<hr>

<h2>3. GROUP BY with AVG</h2>
<pre>
SELECT dept_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY dept_id;
</pre>
<p><b>Explanation:</b> Finds the average salary in each department.</p>

<hr>

<h2>4. GROUP BY with Multiple Columns</h2>
<pre>
SELECT dept_id, job_role, COUNT(*) AS count_role
FROM employees
GROUP BY dept_id, job_role;
</pre>
<p><b>Explanation:</b> Groups by both <code>dept_id</code> and <code>job_role</code>.</p>

<hr>

<h2>5. GROUP BY with HAVING</h2>
<pre>
SELECT dept_id, COUNT(*) AS total_employees
FROM employees
GROUP BY dept_id
HAVING COUNT(*) > 2;
</pre>
<p><b>Explanation:</b> Only shows departments where the number of employees is greater than 2.</p>

<hr>

<h2>6. GROUP BY with ORDER BY</h2>
<pre>
SELECT dept_id, SUM(salary) AS total_salary
FROM employees
GROUP BY dept_id
ORDER BY total_salary DESC;
</pre>
<p><b>Explanation:</b> Groups by department, sums salaries, and sorts results in descending order.</p>

<hr>

<h2>7. GROUP BY with WHERE</h2>
<pre>
SELECT dept_id, COUNT(*) AS total_employees
FROM employees
WHERE salary > 50000
GROUP BY dept_id;
</pre>
<p><b>Explanation:</b> First filters employees with salary greater than 50,000, then groups by department.</p>

<hr>

<h2>8. GROUP BY with DISTINCT (Not needed inside GROUP BY)</h2>
<pre>
SELECT dept_id, COUNT(DISTINCT job_role) AS unique_roles
FROM employees
GROUP BY dept_id;
</pre>
<p><b>Explanation:</b> Counts how many unique job roles are present in each department.</p>

<hr>

<h1>SQL HAVING Clause</h1>

<p>The <b>HAVING</b> clause in SQL is used to filter groups (created by <code>GROUP BY</code>).  
It is similar to <code>WHERE</code>, but while <code>WHERE</code> filters individual rows,  
<b>HAVING filters groups after aggregation</b>.</p>

<hr>

<h2>1. Basic HAVING with COUNT</h2>
<pre>
SELECT dept_id, COUNT(*) AS total_employees
FROM employees
GROUP BY dept_id
HAVING COUNT(*) > 2;
</pre>
<p><b>Explanation:</b> Counts employees in each department and shows only departments with more than 2 employees.</p>

<table>
  <tr><th>dept_id</th><th>total_employees</th></tr>
  <tr><td>101</td><td>3</td></tr>
  <tr><td>103</td><td>4</td></tr>
</table>

<hr>

<h2>2. HAVING with SUM</h2>
<pre>
SELECT dept_id, SUM(salary) AS total_salary
FROM employees
GROUP BY dept_id
HAVING SUM(salary) > 100000;
</pre>
<p><b>Explanation:</b> Shows departments where the total salary exceeds 100,000.</p>

<hr>

<h2>3. HAVING with AVG</h2>
<pre>
SELECT dept_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY dept_id
HAVING AVG(salary) BETWEEN 40000 AND 60000;
</pre>
<p><b>Explanation:</b> Displays departments whose average salary is between 40,000 and 60,000.</p>

<hr>

<h2>4. HAVING with Multiple Conditions</h2>
<pre>
SELECT dept_id, job_role, COUNT(*) AS count_role
FROM employees
GROUP BY dept_id, job_role
HAVING COUNT(*) > 1 AND dept_id = 101;
</pre>
<p><b>Explanation:</b> Groups by department and job role, then shows only those in dept 101  
where more than 1 employee has the same role.</p>

<hr>

<h2>5. Difference Between WHERE and HAVING</h2>
<pre>
-- Using WHERE (filters rows before grouping)
SELECT dept_id, COUNT(*) AS total_employees
FROM employees
WHERE salary > 50000
GROUP BY dept_id;

-- Using HAVING (filters groups after grouping)
SELECT dept_id, COUNT(*) AS total_employees
FROM employees
GROUP BY dept_id
HAVING AVG(salary) > 50000;
</pre>

<p><b>Explanation:</b></p>
<ul>
  <li><code>WHERE</code> ‚Üí applies before grouping (row-level condition).</li>
  <li><code>HAVING</code> ‚Üí applies after grouping (group-level condition).</li>
</ul>

<hr>

<h1>Database Objects</h1>
<div class="topic">
  <h2>1. VIEW</h2>
  <p>A <b>View</b> is a virtual table created using a SQL query. It does not store data itself but displays data from one or more tables.</p>

  <h3>Syntax:</h3>
  <pre>
CREATE VIEW view_name AS
SELECT column1, column2
FROM table_name
WHERE condition;
  </pre>

  <h3>Example:</h3>
  <pre>
CREATE VIEW EmployeeView AS
SELECT emp_id, emp_name, salary
FROM Employee
WHERE salary > 40000;

SELECT * FROM EmployeeView;
  </pre>

  <p><b>Output:</b> Displays employees with salary greater than 40000.</p>
</div>

---

<div class="topic">
  <h2>2. SQL Injection</h2>
  <p><b>SQL Injection</b> is a hacking technique where malicious queries are inserted into input fields to manipulate the database.</p>

  <h3>Example of Attack:</h3>
  <pre>
-- User enters:
' OR 1=1 --
  
SELECT * FROM Users WHERE username = '' OR 1=1 -- AND password = '';
  </pre>

  <p><b>Output:</b> Returns all rows (bypasses authentication).</p>

  <h3>Prevention:</h3>
  <ul>
    <li>Use <b>Prepared Statements</b> or <b>Parameterized Queries</b>.</li>
    <li>Validate and sanitize user input.</li>
  </ul>
</div>

---

<div class="topic">
  <h2>3. INDEX</h2>
  <p>An <b>Index</b> is a database object that improves the speed of data retrieval (SELECT queries) at the cost of slower INSERT/UPDATE.</p>

  <h3>Syntax:</h3>
  <pre>
CREATE INDEX index_name
ON table_name (column_name);
  </pre>

  <h3>Example:</h3>
  <pre>
CREATE INDEX idx_emp_name
ON Employee(emp_name);
  </pre>

  <p><b>Output:</b> Searching employees by <b>emp_name</b> becomes faster.</p>
</div>

---

<div class="topic">
  <h2>4. Hosting</h2>
  <p><b>Database Hosting</b> means storing your database on a remote server (cloud or dedicated server) so that it can be accessed from anywhere.</p>

  <h3>Examples:</h3>
  <ul>
    <li>Cloud: AWS RDS, Azure SQL Database, Google Cloud SQL.</li>
    <li>Shared Hosting: cPanel MySQL.</li>
    <li>Local Hosting: XAMPP, WAMP.</li>
  </ul>
</div>

---

<div class="topic">
  <h2>5. DEFAULT Constraint</h2>
  <p>The <b>DEFAULT</b> constraint provides a default value to a column if no value is given during insertion.</p>

  <h3>Syntax:</h3>
  <pre>
CREATE TABLE Student (
   id INT PRIMARY KEY,
   name VARCHAR(50),
   city VARCHAR(50) DEFAULT 'Chennai'
);
  </pre>

  <h3>Example:</h3>
  <pre>
INSERT INTO Student (id, name) VALUES (1, 'Aathi');

SELECT * FROM Student;
  </pre>

  <p><b>Output:</b><br>
  1 | Aathi | Chennai</p>
</div>

---

<div class="topic">
  <h2>6. AUTO INCREMENT</h2>
  <p><b>AUTO_INCREMENT</b> automatically generates unique values for a column (mostly used with PRIMARY KEY).</p>

  <h3>Syntax:</h3>
  <pre>
CREATE TABLE Orders (
   order_id INT AUTO_INCREMENT PRIMARY KEY,
   product_name VARCHAR(50)
);
  </pre>

  <h3>Example:</h3>
  <pre>
INSERT INTO Orders (product_name) VALUES ('Laptop');
INSERT INTO Orders (product_name) VALUES ('Mobile');

SELECT * FROM Orders;
  </pre>

  <p><b>Output:</b><br>
  1 | Laptop <br>
  2 | Mobile</p>
</div>

---

<div class="topic">
  <h2>7. BACKUP</h2>
  <p><b>Backup</b> is the process of copying database data to protect against loss.</p>

  <h3>SQL Backup Command:</h3>
  <pre>
-- MySQL
BACKUP DATABASE dbname
TO DISK = 'D:\backup\dbname.bak';
  </pre>

  <h3>Restore:</h3>
  <pre>
RESTORE DATABASE dbname
FROM DISK = 'D:\backup\dbname.bak';
  </pre>

  <h3>Other Backup Methods:</h3>
  <ul>
    <li>mysqldump tool (MySQL)</li>
    <li>pg_dump (PostgreSQL)</li>
    <li>Export/Import utilities</li>
    <li>Cloud backups (AWS, Azure, GCP)</li>
  </ul>
</div>

<hr>

<div class="topic">
  <h2>String Functions in MySQL</h2>
  <p>String functions are used to manipulate and process string values in SQL queries.</p>

  <!-- CONCAT -->
  <div class="subtopic">
    <h3>1. CONCAT()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT CONCAT(string1, string2, ...);</code></pre>
    <p><b>Explanation:</b> Joins two or more strings into one.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT CONCAT('Hello', ' ', 'World') AS result;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>result
-------
Hello World</code></pre>
  </div>

  <!-- LENGTH -->
  <div class="subtopic">
    <h3>2. LENGTH()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT LENGTH(string);</code></pre>
    <p><b>Explanation:</b> Returns the length of a string in bytes. Use CHAR_LENGTH() for character count.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT LENGTH('MySQL') AS len;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>len
---
5</code></pre>
  </div>

  <!-- CHAR_LENGTH -->
  <div class="subtopic">
    <h3>3. CHAR_LENGTH()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT CHAR_LENGTH(string);</code></pre>
    <p><b>Explanation:</b> Returns the number of characters in a string.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT CHAR_LENGTH('MySQL') AS char_len;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>char_len
--------
5</code></pre>
  </div>

  <!-- UPPER -->
  <div class="subtopic">
    <h3>4. UPPER() / UCASE()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT UPPER(string);</code></pre>
    <p><b>Explanation:</b> Converts string to uppercase.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT UPPER('mysql') AS upper_text;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>upper_text
----------
MYSQL</code></pre>
  </div>

  <!-- LOWER -->
  <div class="subtopic">
    <h3>5. LOWER() / LCASE()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT LOWER(string);</code></pre>
    <p><b>Explanation:</b> Converts string to lowercase.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT LOWER('HELLO') AS lower_text;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>lower_text
----------
hello</code></pre>
  </div>

  <!-- SUBSTRING -->
  <div class="subtopic">
    <h3>6. SUBSTRING()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT SUBSTRING(string, start, length);</code></pre>
    <p><b>Explanation:</b> Extracts part of the string starting at a given position.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT SUBSTRING('Database', 1, 4) AS part;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>part
----
Data</code></pre>
  </div>

  <!-- TRIM -->
  <div class="subtopic">
    <h3>7. TRIM()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT TRIM(string);</code></pre>
    <p><b>Explanation:</b> Removes spaces from both sides of a string.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT TRIM('   Hello   ') AS trimmed;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>trimmed
-------
Hello</code></pre>
  </div>

  <!-- LTRIM & RTRIM -->
  <div class="subtopic">
    <h3>8. LTRIM() & RTRIM()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT LTRIM(string), RTRIM(string);</code></pre>
    <p><b>Explanation:</b> Removes spaces from left or right side of a string.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT LTRIM('   SQL') AS left_trim, RTRIM('SQL   ') AS right_trim;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>left_trim | right_trim
----------|-----------
SQL       | SQL</code></pre>
  </div>

  <!-- REPLACE -->
  <div class="subtopic">
    <h3>9. REPLACE()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT REPLACE(string, from_substring, to_substring);</code></pre>
    <p><b>Explanation:</b> Replaces all occurrences of a substring with another string.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT REPLACE('I like Java', 'Java', 'MySQL') AS replaced_text;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>replaced_text
-------------
I like MySQL</code></pre>
  </div>

  <!-- REVERSE -->
  <div class="subtopic">
    <h3>10. REVERSE()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT REVERSE(string);</code></pre>
    <p><b>Explanation:</b> Reverses a string.</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT REVERSE('SQL') AS reversed;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>reversed
--------
LQS</code></pre>
  </div>

  <!-- LOCATE -->
  <div class="subtopic">
    <h3>11. LOCATE() / INSTR()</h3>
    <p><b>Syntax:</b></p>
    <pre><code>SELECT LOCATE(substring, string);</code></pre>
    <p><b>Explanation:</b> Returns the position of the substring inside a string (1-based index).</p>
    <p><b>Example:</b></p>
    <pre><code>SELECT LOCATE('a', 'Database') AS pos;</code></pre>
    <p><b>Output:</b></p>
    <pre><code>pos
---
2</code></pre>
  </div>
</div>

<hr>

<section>
  <h2>ACID Properties in DBMS</h2>
  <p>
    In database systems, especially in <b>transactions</b>, the ACID properties ensure data reliability, consistency, and correctness even in case of errors or system failures.
  </p>

  <h3>1. Atomicity</h3>
  <p>
    Ensures that a transaction is treated as a <b>single unit of work</b>.  
    Either the entire transaction is executed, or none of it is.  
    <br><b>Example:</b> If you transfer ‚Çπ1000 from Account A to Account B, both debit and credit must occur. If one fails, both are rolled back.
  </p>

  <h3>2. Consistency</h3>
  <p>
    Ensures that a transaction <b>brings the database from one valid state to another valid state</b>.  
    It preserves all integrity constraints.  
    <br><b>Example:</b> If Account A has ‚Çπ5000 and Account B has ‚Çπ2000, after transferring ‚Çπ1000, total money should remain ‚Çπ7000.
  </p>

  <h3>3. Isolation</h3>
  <p>
    Ensures that multiple transactions can occur <b>independently</b> without interference.  
    The intermediate state of a transaction is not visible to other transactions.  
    <br><b>Example:</b> If two people transfer money at the same time, their transactions should not affect each other.
  </p>

  <h3>4. Durability</h3>
  <p>
    Ensures that once a transaction is <b>committed</b>, it remains permanent in the database even if a system crash occurs.  
    <br><b>Example:</b> Once money is transferred successfully, it should not be lost even if the server restarts.
  </p>

  <h3>Summary</h3>
  <ul>
    <li><b>A</b> - Atomicity ‚Üí All or nothing</li>
    <li><b>C</b> - Consistency ‚Üí Preserves data integrity</li>
    <li><b>I</b> - Isolation ‚Üí Transactions don‚Äôt interfere</li>
    <li><b>D</b> - Durability ‚Üí Data is permanent after commit</li>
  </ul>
</section>

<hr>

<section>
  <h2>Trigger in DBMS</h2>
  <p>
    A <b>Trigger</b> is a special kind of stored procedure in SQL that is <b>automatically executed (fired)</b> when a specific event occurs on a table or view.  
    Triggers are commonly used to maintain <b>data integrity</b>, enforce business rules, and perform automatic actions like logging or validation.
  </p>

  <h3>Types of Triggers</h3>
  <ul>
    <li><b>BEFORE Trigger</b> ‚Üí Executes <b>before</b> an insert, update, or delete operation.</li>
    <li><b>AFTER Trigger</b> ‚Üí Executes <b>after</b> an insert, update, or delete operation.</li>
    <li><b>INSTEAD OF Trigger</b> ‚Üí Used mainly with views, executes <b>instead of</b> the triggering action.</li>
  </ul>

  <h3>Trigger Syntax</h3>
  <pre>
CREATE TRIGGER trigger_name
BEFORE | AFTER | INSTEAD OF INSERT | UPDATE | DELETE
ON table_name
FOR EACH ROW
BEGIN
   -- Trigger logic here
END;
  </pre>

  <h3>Example 1: BEFORE INSERT Trigger</h3>
  <p><b>Requirement:</b> Ensure that salary cannot be inserted as less than 5000.</p>
  <pre>
CREATE TRIGGER check_salary
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
   IF NEW.salary &lt; 5000 THEN
      SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'Salary must be at least 5000';
   END IF;
END;
  </pre>

  <h3>Example 2: AFTER INSERT Trigger</h3>
  <p><b>Requirement:</b> Log every new employee inserted into a log table.</p>
  <pre>
CREATE TRIGGER log_employee
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
   INSERT INTO employee_log(emp_id, action, log_time)
   VALUES (NEW.id, 'Inserted', NOW());
END;
  </pre>

  <h3>Example with Output</h3>
  <p>
    <b>employees table:</b><br>
    | id | name    | salary |<br>
    |----|---------|--------|<br>
    | 1  | Ram     | 6000   |<br>
    | 2  | Sita    | 7000   |<br>
    <br>
    <b>employee_log table after insert:</b><br>
    | log_id | emp_id | action    | log_time            |<br>
    |--------|--------|-----------|---------------------|<br>
    | 1      | 1      | Inserted  | 2025-08-22 20:15:00 |<br>
    | 2      | 2      | Inserted  | 2025-08-22 20:16:10 |<br>
  </p>

  <h3>When to Use Triggers?</h3>
  <ul>
    <li>Auditing changes (log table updates)</li>
    <li>Enforcing complex business rules</li>
    <li>Validating data before insertion</li>
    <li>Synchronizing tables automatically</li>
  </ul>
</section>

<hr>

<section>
  <h2>Stored Procedures in SQL</h2>
  <p>
    A <b>Stored Procedure</b> is a precompiled set of SQL statements that can be saved and reused.  
    It allows developers to encapsulate business logic, reduce redundancy, and improve performance.  
  </p>

  <h3>Syntax</h3>
  <pre>
CREATE PROCEDURE procedure_name (parameters)
BEGIN
   -- SQL statements
END;
  </pre>

  <h3>Example: Insert Employee</h3>
  <pre>
CREATE PROCEDURE add_employee(IN emp_name VARCHAR(50), IN emp_salary DECIMAL(10,2))
BEGIN
   INSERT INTO employees(name, salary) VALUES(emp_name, emp_salary);
END;
  </pre>

  <h3>Calling Procedure</h3>
  <pre>
CALL add_employee('Ravi', 8000);
  </pre>

  <h3>Advantages of Stored Procedures</h3>
  <ul>
    <li>Code reusability</li>
    <li>Improved performance (precompiled)</li>
    <li>Centralized business logic</li>
    <li>Better security (can restrict direct table access)</li>
  </ul>
</section>

<section>
  <h2>Functions in SQL</h2>
  <p>
    A <b>Function</b> is similar to a procedure, but it <b>always returns a single value</b>.  
    Functions are commonly used for calculations and reusable expressions.
  </p>

  <h3>Syntax</h3>
  <pre>
CREATE FUNCTION function_name (parameters)
RETURNS datatype
DETERMINISTIC
BEGIN
   -- SQL statements
   RETURN value;
END;
  </pre>

  <h3>Example: Calculate Bonus</h3>
  <pre>
CREATE FUNCTION get_bonus(salary DECIMAL(10,2))
RETURNS DECIMAL(10,2)
DETERMINISTIC
BEGIN
   DECLARE bonus DECIMAL(10,2);
   SET bonus = salary * 0.10;
   RETURN bonus;
END;
  </pre>

  <h3>Calling Function</h3>
  <pre>
SELECT name, salary, get_bonus(salary) AS bonus
FROM employees;
  </pre>

  <h3>Difference: Procedure vs Function</h3>
  <table  cellpadding="6">
    <tr>
      <th>Feature</th>
      <th>Procedure</th>
      <th>Function</th>
    </tr>
    <tr>
      <td>Return Type</td>
      <td>Can return none, one, or multiple values</td>
      <td>Must return a single value</td>
    </tr>
    <tr>
      <td>Usage</td>
      <td>Called with <b>CALL</b></td>
      <td>Called inside <b>SELECT</b></td>
    </tr>
    <tr>
      <td>Purpose</td>
      <td>Perform actions (insert, update, delete, logic)</td>
      <td>Perform calculations & return result</td>
    </tr>
  </table>
</section>

<hr>

<section>
  <h2>Cursors in SQL</h2>
  <p>
    A <b>Cursor</b> is a database object used to retrieve, manipulate, and navigate through a set of rows (result set) row by row.  
    Normally, SQL works with sets of data at once, but when row-by-row processing is required, cursors are useful.
  </p>

  <h3>Steps to Use a Cursor</h3>
  <ol>
    <li><b>Declare</b> the cursor</li>
    <li><b>Open</b> the cursor</li>
    <li><b>Fetch</b> rows from the cursor one by one</li>
    <li><b>Close</b> the cursor</li>
  </ol>

  <h3>Syntax</h3>
  <pre>
DECLARE cursor_name CURSOR FOR 
    SELECT column_list FROM table_name;

OPEN cursor_name;

FETCH NEXT FROM cursor_name INTO variable_list;

CLOSE cursor_name;

DEALLOCATE cursor_name;
  </pre>

  <h3>Example</h3>
  <pre>
DECLARE @emp_name VARCHAR(50), @emp_salary DECIMAL(10,2);

DECLARE emp_cursor CURSOR FOR
   SELECT name, salary FROM employees;

OPEN emp_cursor;

FETCH NEXT FROM emp_cursor INTO @emp_name, @emp_salary;

WHILE @@FETCH_STATUS = 0
BEGIN
   PRINT 'Employee: ' + @emp_name + ', Salary: ' + CAST(@emp_salary AS VARCHAR);
   FETCH NEXT FROM emp_cursor INTO @emp_name, @emp_salary;
END;

CLOSE emp_cursor;
DEALLOCATE emp_cursor;
  </pre>

  <h3>When to Use Cursors?</h3>
  <ul>
    <li>When row-by-row processing is required</li>
    <li>For complex operations where set-based queries are not sufficient</li>
    <li>When updating or processing specific rows sequentially</li>
  </ul>

  <h3>Disadvantages of Cursors</h3>
  <ul>
    <li>Slower than set-based operations</li>
    <li>Consumes more memory</li>
    <li>Should be avoided unless absolutely necessary</li>
  </ul>
</section>

<hr>

<section id="plsql">
  <h2>PL/SQL (Procedural Language/SQL)</h2>
  <p>
    <b>PL/SQL</b> stands for <b>Procedural Language extensions to SQL</b>.  
    It is Oracle‚Äôs procedural extension of SQL. It allows you to write <b>program blocks</b> with procedural features like loops, conditions, variables, functions, and error handling.
  </p>

  <h3>Features of PL/SQL</h3>
  <ul>
    <li>Combines SQL with procedural constructs.</li>
    <li>Supports variables, constants, cursors, and exceptions.</li>
    <li>Improves performance by reducing database calls (block executes as one unit).</li>
    <li>Supports modularity (procedures, functions, packages).</li>
    <li>Error handling with <code>EXCEPTION</code> block.</li>
  </ul>

  <h3>PL/SQL Block Structure</h3>
  <pre>
  DECLARE
      -- Declarations (variables, constants, cursors)
  BEGIN
      -- Executable statements (SQL + procedural code)
  EXCEPTION
      -- Exception handling (errors)
  END;
  </pre>

  <h3>Example 1: Basic PL/SQL Block</h3>
  <pre>
  DECLARE
      v_name VARCHAR2(20) := 'Alice';
  BEGIN
      DBMS_OUTPUT.PUT_LINE('Hello, ' || v_name);
  END;
  </pre>

  <h4>Output</h4>
  <pre>
  Hello, Alice
  </pre>

  <h3>Variables and Constants</h3>
  <pre>
  DECLARE
      v_id NUMBER := 101;
      v_salary NUMBER(10,2);
      c_bonus CONSTANT NUMBER := 500;
  BEGIN
      v_salary := 2000 + c_bonus;
      DBMS_OUTPUT.PUT_LINE('Total Salary: ' || v_salary);
  END;
  </pre>

  <h3>Control Structures</h3>
  <h4>IF Statement</h4>
  <pre>
  DECLARE
      v_marks NUMBER := 75;
  BEGIN
      IF v_marks >= 50 THEN
          DBMS_OUTPUT.PUT_LINE('Pass');
      ELSE
          DBMS_OUTPUT.PUT_LINE('Fail');
      END IF;
  END;
  </pre>

  <h4>LOOP Example</h4>
  <pre>
  DECLARE
      v_counter NUMBER := 1;
  BEGIN
      LOOP
          DBMS_OUTPUT.PUT_LINE('Counter = ' || v_counter);
          v_counter := v_counter + 1;
          EXIT WHEN v_counter > 5;
      END LOOP;
  END;
  </pre>

  <h3>Cursors</h3>
  <p>
    A <b>cursor</b> is a pointer to the result set of a query.  
    Used for row-by-row processing.
  </p>
  <pre>
  DECLARE
      CURSOR emp_cursor IS
          SELECT name, salary FROM Employees;
      v_name Employees.name%TYPE;
      v_salary Employees.salary%TYPE;
  BEGIN
      OPEN emp_cursor;
      LOOP
          FETCH emp_cursor INTO v_name, v_salary;
          EXIT WHEN emp_cursor%NOTFOUND;
          DBMS_OUTPUT.PUT_LINE(v_name || ' earns ' || v_salary);
      END LOOP;
      CLOSE emp_cursor;
  END;
  </pre>

  <h3>Exception Handling</h3>
  <pre>
  DECLARE
      v_num NUMBER := 10;
      v_den NUMBER := 0;
      v_result NUMBER;
  BEGIN
      v_result := v_num / v_den;
      DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
  EXCEPTION
      WHEN ZERO_DIVIDE THEN
          DBMS_OUTPUT.PUT_LINE('Error: Division by zero!');
      WHEN OTHERS THEN
          DBMS_OUTPUT.PUT_LINE('Some other error occurred.');
  END;
  </pre>

  <h3>Stored Procedure</h3>
  <pre>
  CREATE OR REPLACE PROCEDURE greet_user(p_name IN VARCHAR2) IS
  BEGIN
      DBMS_OUTPUT.PUT_LINE('Hello, ' || p_name || '!');
  END;
  </pre>

  <h3>Stored Function</h3>
  <pre>
  CREATE OR REPLACE FUNCTION get_bonus(p_salary NUMBER)
  RETURN NUMBER IS
  BEGIN
      RETURN p_salary * 0.10;
  END;
  </pre>

  <h3>Triggers in PL/SQL</h3>
  <pre>
  CREATE OR REPLACE TRIGGER trg_before_insert
  BEFORE INSERT ON Employees
  FOR EACH ROW
  BEGIN
      DBMS_OUTPUT.PUT_LINE('Before inserting employee: ' || :NEW.name);
  END;
  </pre>

  <h3>Packages</h3>
  <p>
    Packages group related procedures, functions, and variables together.
  </p>
  <pre>
  CREATE OR REPLACE PACKAGE emp_pkg IS
      PROCEDURE add_employee(p_name VARCHAR2, p_salary NUMBER);
      FUNCTION get_total_employees RETURN NUMBER;
  END emp_pkg;
  </pre>
</section>

<hr>

     <section id="dual">
  <h2>DUAL Table</h2>
  <p>
    <b>DUAL</b> is a special dummy table provided by Oracle.  
    It has only <b>one row and one column (called DUMMY)</b>.  
    It is mainly used when you want to <b>select a value, expression, or function output without using a real table</b>.
  </p>

  <h3>Structure of DUAL</h3>
  <pre>
  DESC DUAL;

  Column | DataType
  -------|---------
  DUMMY  | VARCHAR2(1)

  SELECT * FROM DUAL;

  Output:
  D
  -
  X
  </pre>

  <h3>Examples</h3>

  <h4>1. Display a string</h4>
  <pre>
  SELECT 'Hello World' FROM DUAL;

  Output:
  Hello World
  </pre>

  <h4>2. Perform calculations</h4>
  <pre>
  SELECT 10 + 20 AS result FROM DUAL;

  Output:
  30
  </pre>

  <h4>3. Get system date</h4>
  <pre>
  SELECT SYSDATE FROM DUAL;

  Output:
  22-AUG-25
  </pre>

  <h4>4. Using functions</h4>
  <pre>
  SELECT UPPER('oracle') FROM DUAL;

  Output:
  ORACLE
  </pre>

  <h4>5. Multiple columns</h4>
  <pre>
  SELECT 'Aathi' AS name, 100*5 AS marks, SYSDATE AS today
  FROM DUAL;

  Output:
  NAME   MARKS   TODAY
  -----  ------  ---------
  Aathi  500     22-AUG-25
  </pre>

  <p>
    ‚úÖ <b>Note:</b> In Oracle, <code>DUAL</code> is used widely,  
    but in other databases (MySQL, PostgreSQL, SQL Server) you may not need it or syntax can differ.
  </p>
     </section>
     
<hr>

<!-- ======================= -->
<!-- SQL ORDER OF EXECUTION -->
<!-- ======================= -->
<div class="topic">
  <h2>SQL Order of Execution</h2>
  <p>
    SQL commands have different categories (DDL, DML, DQL, TCL, DCL).  
    Each type of command has its own execution order inside MySQL.
  </p>
</div>

<!-- 1) DDL -->
<div class="topic">
  <h3>1) DDL (Data Definition Language)</h3>
  <ul>
    <li><b>Execution Order:</b> CREATE ‚Üí ALTER ‚Üí DROP ‚Üí TRUNCATE ‚Üí RENAME</li>
    <li>DDL commands are auto-committed (cannot be rolled back).</li>
  </ul>
</div>

<!-- 2) DML -->
<div class="topic">
  <h3>2) DML (Data Manipulation Language)</h3>
  <ul>
    <li><b>Execution Order:</b> INSERT ‚Üí UPDATE ‚Üí DELETE ‚Üí MERGE</li>
    <li>They modify data inside tables and <b>can be rolled back</b> (before COMMIT).</li>
  </ul>
</div>

<!-- 3) DQL -->
<div class="topic">
  <h3>3) DQL (Data Query Language)</h3>
  <p>Query execution inside SELECT follows a specific order:</p>
  <pre>
1. FROM      ‚Üí Choose tables
2. JOIN      ‚Üí Apply joins
3. WHERE     ‚Üí Filter rows
4. GROUP BY  ‚Üí Group rows
5. HAVING    ‚Üí Filter groups
6. SELECT    ‚Üí Choose columns
7. DISTINCT  ‚Üí Remove duplicates
8. ORDER BY  ‚Üí Sort results
9. LIMIT     ‚Üí Restrict output
  </pre>
</div>

<!-- 4) TCL -->
<div class="topic">
  <h3>4) TCL (Transaction Control Language)</h3>
  <ul>
    <li><b>Execution Order:</b> BEGIN / START TRANSACTION ‚Üí DML statements ‚Üí COMMIT / ROLLBACK ‚Üí SAVEPOINT (optional)</li>
    <li>TCL controls how transactions are applied to the database.</li>
  </ul>
</div>

<!-- 5) DCL -->
<div class="topic">
  <h3>5) DCL (Data Control Language)</h3>
  <ul>
    <li><b>Execution Order:</b> GRANT ‚Üí REVOKE ‚Üí SHOW GRANTS</li>
    <li>DCL is dependent on <b>admin privileges</b>, not normal user queries.</li>
  </ul>
</div>

<hr>

 <h1>Relational Algebra vs SQL</h1>
  <table>
    <tr>
      <th>Relational Algebra</th>
      <th>Meaning</th>
      <th>SQL Equivalent</th>
    </tr>
    <tr>
      <td><b>œÉ (Sigma)</b></td>
      <td>Selection (choose rows)</td>
      <td><code>WHERE</code></td>
    </tr>
    <tr>
      <td><b>œÄ (Pi)</b></td>
      <td>Projection (choose columns)</td>
      <td><code>SELECT column_list</code></td>
    </tr>
    <tr>
      <td><b>‚ãà (Join)</b></td>
      <td>Combine two tables based on condition</td>
      <td><code>JOIN ... ON</code></td>
    </tr>
    <tr>
      <td><b>√ó (Cross Product)</b></td>
      <td>All combinations of rows</td>
      <td><code>CROSS JOIN</code></td>
    </tr>
    <tr>
      <td><b>‚à™ (Union)</b></td>
      <td>Combine rows from two queries (no duplicates)</td>
      <td><code>UNION</code></td>
    </tr>
    <tr>
      <td><b>‚à© (Intersection)</b></td>
      <td>Common rows between queries</td>
      <td><code>INTERSECT</code> (not in MySQL, use <code>INNER JOIN</code> + condition)</td>
    </tr>
    <tr>
      <td><b>‚àí (Set Difference)</b></td>
      <td>Rows in one relation but not in another</td>
      <td><code>EXCEPT</code> (not in MySQL, use <code>LEFT JOIN ... WHERE NULL</code>)</td>
    </tr>
    <tr>
      <td><b>œÅ (Rho)</b></td>
      <td>Rename relation/attribute</td>
      <td><code>AS</code></td>
    </tr>
  </table>
  
</body>
</html>
