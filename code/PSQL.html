<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PSQL</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #0d1117;
    color: #e6edf3;
    line-height: 1.6;
    padding: 20px;
    max-width: 100%;
  }
  /* Existing styles remain unchanged */
  pre{background: #21262d;color:#aaffaa;padding:12px;border-radius:8px;overflow:auto}
  h1, h2, h3, h4, h5, h6 {
      margin-top: 30px;
      border-left: 5px solid #ff4747;
      padding-left: 12px;
      color: #333;
    }

  h1 {
    color: #f0f6fc;
    font-size: 2em;
    text-align: center;
    margin-top: 40px;
    margin-bottom: 20px;
    border-bottom: 3px solid #30363d;
    padding-bottom: 8px;
  }

  h3 {
    color: #79c0ff;
    font-size: 1.4em;
    margin-top: 25px;
    border-left: 4px solid #30363d;
    padding-left: 10px;
  }

  h4 {
    color: #4bffe7;
    font-size: 1.2em;
    margin-top: 20px;
  }

  h5 {
    color: #a5d6ff;
    font-size: 1.1em;
    margin-top: 15px;
    font-weight: normal;
  }

  h6 {
    color: #8b949e;
    font-size: 1em;
    margin-top: 10px;
    font-weight: normal;
    font-style: italic;
  }
  h2 {
    color: #58a6ff;
    border-bottom: 2px solid #30363d;
    padding-bottom: 4px;
  }
  a {
    color: #79c0ff;
    text-decoration: none;
  }
  a:hover {
    color: #fff;
    text-decoration: underline;
  }
  .index {
    background-color: #161b22;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 30px;
  }
  .index ul {
    columns: 2;
    list-style-type: none;
    padding-left: 0;
  }
  .index li {
    margin: 6px 0;
  }
  section {
    margin-bottom: 50px;
  }
  code {
    background-color: #21262d;
    padding: 4px 8px;
    border-radius: 6px;
    color: #ffa657;
  }
  table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}
table { 
    width: 100%; 
    border-collapse: collapse; 
    margin: 15px 0; 
}

th, td { 
    border: 1px solid #ccc; 
    padding: 8px; 
    text-align: left; 
}

th { 
    background: #34495e; 
    color: white; 
}
</style>
</head>
<body>

<section id="introduction">

    <h1>Introduction to PostgreSQL</h1>

    <!-- 1.1 What is PostgreSQL? -->
    <div class="topic">
        <h2>1.1 What is PostgreSQL?</h2>

        <p>
            PostgreSQL (often called <b>Postgres</b>) is an advanced, open-source
            <b>object-relational database management system (ORDBMS)</b>.
            It supports both SQL (relational) and JSON (non-relational) querying.
        </p>

        <ul>
            <li>Free and open-source</li>
            <li>Supports complex queries & advanced data types</li>
            <li>Highly reliable and ACID-compliant</li>
            <li>Used in enterprise applications and production systems</li>
        </ul>
    </div>


    <!-- 1.2 Features -->
    <div class="topic">
        <h2>1.2 Features of PostgreSQL</h2>

        <ul>
            <li><b>Strong ACID compliance</b></li>
            <li><b>Supports JSON, Arrays, HSTORE, UUID</b></li>
            <li><b>Highly extensible</b> (you can create custom functions, data types, operators)</li>
            <li><b>MVCC (Multi-Version Concurrency Control)</b> for fast reads</li>
            <li><b>Full-text search support</b></li>
            <li><b>Advanced indexing</b> (B-tree, Hash, GiST, GIN, BRIN)</li>
            <li><b>Replication support</b></li>
            <li><b>Cross-platform</b> (Windows, Linux, macOS)</li>
        </ul>
    </div>


    <!-- 1.3 Installation and psql -->
    <div class="topic">
        <h2>1.3 Installation & psql Command Line</h2>

        <h3>Install on Windows:</h3>
        <pre>
1. Download installer from: https://www.postgresql.org/download
2. Run installer and select:
   ✔ PostgreSQL Server
   ✔ pgAdmin
   ✔ Command Line Tools (psql)
3. Set a password for the postgres superuser
4. Complete installation
        </pre>

        <h3>Open psql (Command Line):</h3>
        <pre>
Open CMD and type:
psql -U postgres
        </pre>

        <p><b>Common psql commands:</b></p>
        <pre>
\l         -- list databases
\c dbname  -- connect to a database
\dt        -- list tables
\du        -- list users/roles
\q         -- quit psql
        </pre>
    </div>


    <!-- 1.4 Basic commands -->
    <div class="topic">
        <h2>1.4 Basic Database Commands</h2>

        <h3>Create a Database</h3>
        <pre>
CREATE DATABASE company;
        </pre>

        <h3>Connect to Database</h3>
        <pre>
\c company;
        </pre>

        <h3>Create a Table</h3>
        <pre>
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    salary NUMERIC
);
        </pre>

        <h3>Insert Record</h3>
        <pre>
INSERT INTO employees (name, age, salary) 
VALUES ('John', 25, 45000);
        </pre>

        <h3>Fetch Data</h3>
        <pre>
SELECT * FROM employees;
        </pre>

        <h3>Update Record</h3>
        <pre>
UPDATE employees SET salary = 50000 WHERE id = 1;
        </pre>

        <h3>Delete Record</h3>
        <pre>
DELETE FROM employees WHERE id = 1;
        </pre>
    </div>

</section>

<hr>

<section id="data-types">

    <h1>Data Types in PostgreSQL</h1>

    <p>
        PostgreSQL supports a wide range of data types including numbers,
        text, dates, JSON, arrays, geometric values, network types and more.
        Below is the complete list of commonly used and advanced data types.
    </p>

    <!-- ===============================
         1. NUMERIC DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>1. Numeric Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>SMALLINT</td><td>2-byte integer (-32,768 to 32,767)</td></tr>
            <tr><td>INTEGER / INT</td><td>4-byte integer</td></tr>
            <tr><td>BIGINT</td><td>8-byte integer</td></tr>

            <tr><td>DECIMAL(p, s)</td><td>Exact numeric with precision & scale</td></tr>
            <tr><td>NUMERIC(p, s)</td><td>Same as DECIMAL (unlimited precision)</td></tr>

            <tr><td>REAL</td><td>4-byte floating point</td></tr>
            <tr><td>DOUBLE PRECISION</td><td>8-byte floating point</td></tr>

            <tr><td>SERIAL</td><td>Auto increment integer (INT)</td></tr>
            <tr><td>BIGSERIAL</td><td>Auto increment (BIGINT)</td></tr>
            <tr><td>SMALLSERIAL</td><td>Auto increment (SMALLINT)</td></tr>
        </table>
    </div>

    <!-- ===============================
         2. TEXT DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>2. Text / Character Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>CHAR(n)</td><td>Fixed-length string</td></tr>
            <tr><td>VARCHAR(n)</td><td>Variable-length string</td></tr>
            <tr><td>TEXT</td><td>Unlimited-length text</td></tr>
            <tr><td>CITEXT</td><td>Case-insensitive text</td></tr>
            <tr><td>UUID</td><td>Universal Unique Identifier</td></tr>
            <tr><td>BYTEA</td><td>Binary data (images, files)</td></tr>
        </table>
    </div>

    <!-- ===============================
         3. BOOLEAN DATA TYPE
    ================================== -->
    <div class="topic">
        <h2>3. Boolean Data Type</h2>

        <p><b>BOOLEAN</b> → TRUE / FALSE values.</p>
        <pre>
CREATE TABLE sample (
    active BOOLEAN
);
        </pre>
    </div>

    <!-- ===============================
         4. DATE/TIME DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>4. Date & Time Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>DATE</td><td>Calendar date (YYYY-MM-DD)</td></tr>
            <tr><td>TIME</td><td>Time only (HH:MM:SS)</td></tr>
            <tr><td>TIMESTAMP</td><td>Date & Time</td></tr>
            <tr><td>TIMESTAMPTZ</td><td>Timestamp with timezone</td></tr>
            <tr><td>INTERVAL</td><td>Time duration (1 day, 2 hours, etc.)</td></tr>
        </table>
    </div>

    <!-- ===============================
         5. JSON DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>5. JSON Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>JSON</td><td>Text-based JSON (stored as plain text)</td></tr>
            <tr><td>JSONB</td><td>Binary JSON (faster indexing & search)</td></tr>
        </table>
    </div>

    <!-- ===============================
         6. ARRAY DATA TYPE
    ================================== -->
    <div class="topic">
        <h2>6. Arrays</h2>

        <p>You can store arrays of any data type.</p>

        <pre>
CREATE TABLE students (
    id SERIAL,
    marks INT[]
);
        </pre>
    </div>

    <!-- ===============================
         7. ENUM DATA TYPE
    ================================== -->
    <div class="topic">
        <h2>7. ENUM Data Type</h2>

        <p>Enum stores a set of predefined values.</p>

        <h3>Create ENUM type:</h3>
        <pre>
CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral');
        </pre>

        <h3>Use ENUM in a table:</h3>
        <pre>
CREATE TABLE person (
    id SERIAL,
    name TEXT,
    current_mood mood
);
        </pre>
    </div>

    <!-- ===============================
         8. NETWORK DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>8. Network Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>INET</td><td>IPv4/IPv6 address</td></tr>
            <tr><td>CIDR</td><td>Network block</td></tr>
            <tr><td>MACADDR</td><td>MAC address</td></tr>
        </table>
    </div>

    <!-- ===============================
         9. GEOMETRIC DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>9. Geometric Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>POINT</td><td>(x, y)</td></tr>
            <tr><td>LINE</td><td>Infinite line</td></tr>
            <tr><td>LSEG</td><td>Line segment</td></tr>
            <tr><td>BOX</td><td>Rectangular box</td></tr>
            <tr><td>PATH</td><td>Closed/open path</td></tr>
            <tr><td>POLYGON</td><td>Polygon</td></tr>
            <tr><td>CIRCLE</td><td>Circle (center, radius)</td></tr>
        </table>
    </div>

    <!-- ===============================
         10. MONEY TYPE
    ================================== -->
    <div class="topic">
        <h2>10. Money Data Type</h2>

        <p>MONEY → Stores currency values</p>

        <pre>
CREATE TABLE accounts (
    id SERIAL,
    balance MONEY
);
        </pre>
    </div>

    <!-- ===============================
         11. HSTORE
    ================================== -->
    <div class="topic">
        <h2>11. HSTORE (Key-Value Store)</h2>
        <p>Stores collections of key → value pairs.</p>

        <pre>
CREATE EXTENSION hstore;

CREATE TABLE products (
    id SERIAL,
    attributes hstore
);
        </pre>
    </div>

    <!-- ===============================
         12. XML TYPE
    ================================== -->
    <div class="topic">
        <h2>12. XML Data Type</h2>
        <pre>
CREATE TABLE docs (
    id SERIAL,
    data XML
);
        </pre>
    </div>

    <!-- ===============================
         13. BIT STRING TYPE
    ================================== -->
    <div class="topic">
        <h2>13. Bit String Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>BIT(n)</td><td>Fixed-length bit string</td></tr>
            <tr><td>VARBIT(n)</td><td>Variable-length bit string</td></tr>
        </table>
    </div>

    <!-- ===============================
         14. CUSTOM DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>14. Creating Custom Data Types</h2>

        <h3>A. Composite Type</h3>
        <pre>
CREATE TYPE address AS (
    street TEXT,
    city TEXT,
    pincode INT
);

CREATE TABLE employee (
    id SERIAL,
    name TEXT,
    home_address address
);
        </pre>

        <h3>B. DOMAIN Type</h3>
        <p>Domain = custom type + constraints</p>

        <pre>
CREATE DOMAIN positive_int AS INT
CHECK (VALUE > 0);

CREATE TABLE items (
    item_id positive_int,
    quantity positive_int
);
        </pre>

        <h3>C. ENUM Type (Already shown)</h3>
        <pre>
CREATE TYPE status AS ENUM ('pending', 'completed', 'cancelled');
        </pre>
    </div>

</section>

<section id="remaining-data-types">

    <h1>Additional PostgreSQL Data Types</h1>

    <p>
        PostgreSQL includes several advanced and internal data types used for ranges,
        object identifiers, text search, internal system functions, and more.
    </p>

    <!-- ===============================
         1. RANGE TYPES
    ================================== -->
    <div class="topic">
        <h2>1. Range Types</h2>

        <p>Range types store <b>start and end</b> values (example: 10–20).</p>
        
        <table cellpadding="5" cellspacing="0">
            <tr><th>Range Type</th><th>Description</th></tr>

            <tr><td>int4range</td><td>Range of INTEGER</td></tr>
            <tr><td>int8range</td><td>Range of BIGINT</td></tr>
            <tr><td>numrange</td><td>Range of NUMERIC values</td></tr>
            <tr><td>tsrange</td><td>Range of TIMESTAMP (no timezone)</td></tr>
            <tr><td>tstzrange</td><td>Range of TIMESTAMP WITH TIMEZONE</td></tr>
            <tr><td>daterange</td><td>Range of DATE values</td></tr>
        </table>

        <h3>Example Table Using Range</h3>
        <pre>
CREATE TABLE reservation (
    room INT,
    booked daterange
);
        </pre>

        <h3>Insert a Range</h3>
        <pre>
INSERT INTO reservation VALUES (101, '[2025-01-01, 2025-01-10]');
        </pre>

        <h3>Range Operators</h3>
        <pre>
@>   -- contains element
<@   -- element inside range
&&   -- overlap
-|-  -- adjacent
        </pre>
    </div>

    <!-- ===============================
         2. FULL TEXT SEARCH TYPES
    ================================== -->
    <div class="topic">
        <h2>2. Full-Text Search Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Type</th><th>Description</th></tr>

            <tr><td>tsvector</td><td>Document converted to searchable terms</td></tr>
            <tr><td>tsquery</td><td>Search query type</td></tr>
        </table>

        <h3>Example:</h3>
        <pre>
SELECT to_tsvector('english', 'PostgreSQL database system');
SELECT to_tsquery('english', 'database & system');
        </pre>
    </div>

    <!-- ===============================
         3. OBJECT IDENTIFIER (OID) TYPES
    ================================== -->
    <div class="topic">
        <h2>3. Object Identifier (OID) Types</h2>

        <p>
            PostgreSQL internally uses OIDs to identify rows, tables, indexes and internal objects.
        </p>

        <table cellpadding="5" cellspacing="0">
            <tr><th>OID Type</th><th>Description</th></tr>

            <tr><td>oid</td><td>Object identifier</td></tr>
            <tr><td>regclass</td><td>Reference to table</td></tr>
            <tr><td>regtype</td><td>Reference to type</td></tr>
            <tr><td>regproc</td><td>Reference to function</td></tr>
            <tr><td>regrole</td><td>Reference to role</td></tr>
            <tr><td>regnamespace</td><td>Reference to schema</td></tr>
        </table>

        <h3>Example</h3>
        <pre>
SELECT 'employees'::regclass;
        </pre>
    </div>

    <!-- ===============================
         4. INTERNAL / PSEUDO TYPES
    ================================== -->
    <div class="topic">
        <h2>4. Pseudo Types</h2>

        <p>
            Pseudo types cannot be used as table columns.  
            They are used in **functions, casting, and internal operations**.
        </p>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Pseudo Type</th><th>Description</th></tr>

            <tr><td>ANY</td><td>Accept any type</td></tr>
            <tr><td>ANYELEMENT</td><td>Any element type</td></tr>
            <tr><td>ANYARRAY</td><td>Any array type</td></tr>
            <tr><td>CSTRING</td><td>Null-terminated C string</td></tr>
            <tr><td>VOID</td><td>No value</td></tr>
            <tr><td>TRIGGER</td><td>Return type for trigger functions</td></tr>
            <tr><td>RECORD</td><td>Row type with unknown structure</td></tr>
            <tr><td>INTERNAL</td><td>Used only internally by PostgreSQL</td></tr>
            <tr><td>OPAQUE</td><td>Historical, still accepted</td></tr>
        </table>

        <h3>Example: Function using VOID</h3>
        <pre>
CREATE FUNCTION log_action()
RETURNS void AS $$
BEGIN
  RAISE NOTICE 'Action logged!';
END;
$$ LANGUAGE plpgsql;
        </pre>
    </div>

    <!-- ===============================
         5. SYSTEM IDENTIFIER TYPES
    ================================== -->
    <div class="topic">
        <h2>5. System Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Type</th><th>Description</th></tr>

            <tr><td>txid_snapshot</td><td>Transaction snapshot data</td></tr>
            <tr><td>pg_lsn</td><td>Log sequence number</td></tr>
            <tr><td>pg_snapshot</td><td>Snapshot for logical decoding</td></tr>
        </table>
    </div>

    <!-- ===============================
         6. ENUM + CUSTOM TYPE (SUMMARY)
    ================================== -->
    <div class="topic">
        <h2>6. ENUM + Custom Types (Summary)</h2>

        <h3>A. ENUM Type</h3>
        <pre>
CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral');
        </pre>

        <h3>B. Composite Type</h3>
        <pre>
CREATE TYPE address AS (street TEXT, city TEXT, pin INT);
        </pre>

        <h3>C. DOMAIN Type</h3>
        <pre>
CREATE DOMAIN positive_num AS INT CHECK (VALUE > 0);
        </pre>
    </div>

</section>

<hr>
<br>
<h1> Functions in PostgreSQL</h1>
<section id="string-functions">

    <h2>String Functions in PostgreSQL</h2>

    <p>String functions help manipulate and process text data in PostgreSQL.</p>

    <!-- 1. LENGTH -->
    <div class="topic">
        <h2>1. LENGTH()</h2>
        <p>Returns the number of characters in a string.</p>
        <pre>
SELECT LENGTH('PostgreSQL');
        </pre>
        <p><b>Output:</b> 10</p>
    </div>

    <!-- 2. UPPER -->
    <div class="topic">
        <h2>2. UPPER()</h2>
        <p>Converts text to uppercase.</p>
        <pre>
SELECT UPPER('postgres');
        </pre>
        <p><b>Output:</b> POSTGRES</p>
    </div>

    <!-- 3. LOWER -->
    <div class="topic">
        <h2>3. LOWER()</h2>
        <p>Converts text to lowercase.</p>
        <pre>
SELECT LOWER('HELLO');
        </pre>
        <p><b>Output:</b> hello</p>
    </div>

    <!-- 4. INITCAP -->
    <div class="topic">
        <h2>4. INITCAP()</h2>
        <p>Capitalizes the first letter of each word.</p>
        <pre>
SELECT INITCAP('postgres sql database');
        </pre>
        <p><b>Output:</b> Postgres Sql Database</p>
    </div>

    <!-- 5. CONCAT -->
    <div class="topic">
        <h2>5. CONCAT()</h2>
        <p>Joins multiple strings.</p>
        <pre>
SELECT CONCAT('Postgre', 'SQL');
        </pre>
        <p><b>Output:</b> PostgreSQL</p>
    </div>

    <!-- 6. CONCAT_WS -->
    <div class="topic">
        <h2>6. CONCAT_WS()</h2>
        <p>Concatenate with a separator.</p>
        <pre>
SELECT CONCAT_WS('-', '2025', '01', '20');
        </pre>
        <p><b>Output:</b> 2025-01-20</p>
    </div>

    <!-- 7. SUBSTRING -->
    <div class="topic">
        <h2>7. SUBSTRING()</h2>
        <p>Extract part of a string.</p>
        <pre>
SELECT SUBSTRING('PostgreSQL' FROM 1 FOR 4);
        </pre>
        <p><b>Output:</b> Post</p>
    </div>

    <!-- 8. LEFT -->
    <div class="topic">
        <h2>8. LEFT()</h2>
        <p>Get N characters from the left.</p>
        <pre>
SELECT LEFT('PostgreSQL', 4);
        </pre>
        <p><b>Output:</b> Post</p>
    </div>

    <!-- 9. RIGHT -->
    <div class="topic">
        <h2>9. RIGHT()</h2>
        <p>Get N characters from the right.</p>
        <pre>
SELECT RIGHT('PostgreSQL', 3);
        </pre>
        <p><b>Output:</b> SQL</p>
    </div>

    <!-- 10. REPLACE -->
    <div class="topic">
        <h2>10. REPLACE()</h2>
        <p>Replace substring in a string.</p>
        <pre>
SELECT REPLACE('Hello World', 'World', 'PostgreSQL');
        </pre>
        <p><b>Output:</b> Hello PostgreSQL</p>
    </div>

    <!-- 11. POSITION -->
    <div class="topic">
        <h2>11. POSITION()</h2>
        <p>Find position of substring.</p>
        <pre>
SELECT POSITION('SQL' IN 'PostgreSQL');
        </pre>
        <p><b>Output:</b> 8</p>
    </div>

    <!-- 12. TRIM -->
    <div class="topic">
        <h2>12. TRIM()</h2>
        <p>Remove spaces from both sides.</p>
        <pre>
SELECT TRIM('   hello   ');
        </pre>
        <p><b>Output:</b> hello</p>
    </div>

    <!-- 13. LTRIM / RTRIM -->
    <div class="topic">
        <h2>13. LTRIM() / RTRIM()</h2>
        <pre>
SELECT LTRIM('   data');
SELECT RTRIM('data   ');
        </pre>
        <p><b>Output:</b> data</p>
    </div>

    <!-- 14. LPAD / RPAD -->
    <div class="topic">
        <h2>14. LPAD() / RPAD()</h2>
        <p>Pad a string to a fixed length.</p>
        <pre>
SELECT LPAD('45', 5, '0');  
SELECT RPAD('Hi', 5, '.');
        </pre>
        <p><b>Output:</b> 00045, Hi...</p>
    </div>

    <!-- 15. SPLIT_PART -->
    <div class="topic">
        <h2>15. SPLIT_PART()</h2>
        <p>Split string and return part by index.</p>
        <pre>
SELECT SPLIT_PART('2025-01-20', '-', 2);
        </pre>
        <p><b>Output:</b> 01</p>
    </div>

    <!-- 16. REVERSE -->
    <div class="topic">
        <h2>16. REVERSE()</h2>
        <p>Reverse a string.</p>
        <pre>
SELECT REVERSE('PostgreSQL');
        </pre>
        <p><b>Output:</b> LQSergtsoP</p>
    </div>

    <!-- 17. STRING_AGG -->
    <div class="topic">
        <h2>17. STRING_AGG()</h2>
        <p>Aggregate strings into one value with a separator.</p>
        <pre>
SELECT STRING_AGG(name, ', ') FROM users;
        </pre>
        <p><b>Output:</b> John, Alex, Mary</p>
    </div>

    <!-- 18. REGEXP Functions Overview -->
    <div class="topic">
        <h2>18. Regular Expression String Functions (Summary)</h2>

        <ul>
            <li><b>regexp_matches()</b> – return matched text</li>
            <li><b>regexp_replace()</b> – replace using regex</li>
            <li><b>regexp_split_to_array()</b></li>
            <li><b>regexp_split_to_table()</b></li>
            <li><b>regexp_count()</b> – count matches</li>
        </ul>

        <h3>18.1 regexp_matches()</h3>
        <pre>
SELECT regexp_matches('abc123xyz', '\d+');
-- Output: {123}
        </pre>
    </div>

    <div class="topic">
        <h3>18.2 regexp_replace()</h3>
        <pre>
SELECT regexp_replace('a1b2c3', '\d', '#', 'g');
-- Output: a#b#c#
        </pre>
    </div>

    <div class="topic">
        <h3>18.3 regexp_split_to_array()</h3>
        <pre>
SELECT regexp_split_to_array('a,b,c', ',');
-- Output: {a,b,c}
        </pre>
    </div>

    <div class="topic">
        <h3>18.4 regexp_split_to_table()</h3>
        <pre>
SELECT regexp_split_to_table('a,b,c', ',');
-- Output (rows):
a
b
c
        </pre>
    </div>

    <div class="topic">
        <h3>18.5 regexp_count()  (PostgreSQL 15+)</h3>
        <pre>
SELECT regexp_count('a1b2c3', '\d');
-- Output: 3
        </pre>
    </div>

    <!-- FORMAT -->
    <div class="topic">
        <h2>19. FORMAT()</h2>
        <pre>
SELECT FORMAT('Name: %s, Age: %s', 'Aathi', 21);
-- Output: Name: Aathi, Age: 21
        </pre>
    </div>

</section>

<hr>

<section id="numeric-functions">

    <h2>Numeric Functions in PostgreSQL</h2>

    <!-- ABS -->
    <div class="topic">
        <h2>1. ABS()</h2>
        <p>Returns absolute value.</p>
        <pre>
SELECT ABS(-25);
-- Output: 25
        </pre>
    </div>

    <!-- CEIL / CEILING -->
    <div class="topic">
        <h2>2. CEIL() / CEILING()</h2>
        <p>Rounds a number up.</p>
        <pre>
SELECT CEIL(4.2);
-- Output: 5
        </pre>
    </div>

    <!-- FLOOR -->
    <div class="topic">
        <h2>3. FLOOR()</h2>
        <p>Rounds a number down.</p>
        <pre>
SELECT FLOOR(4.8);
-- Output: 4
        </pre>
    </div>

    <!-- ROUND -->
    <div class="topic">
        <h2>4. ROUND()</h2>
        <p>Rounds number to nearest integer or decimal position.</p>
        <pre>
SELECT ROUND(3.567, 2);
-- Output: 3.57
        </pre>
    </div>

    <!-- TRUNC -->
    <div class="topic">
        <h2>5. TRUNC()</h2>
        <p>Truncates without rounding.</p>
        <pre>
SELECT TRUNC(8.999);
-- Output: 8
        </pre>
    </div>

    <!-- POWER -->
    <div class="topic">
        <h2>6. POWER()</h2>
        <pre>
SELECT POWER(2, 4);
-- Output: 16
        </pre>
    </div>

    <!-- SQRT -->
    <div class="topic">
        <h2>7. SQRT()</h2>
        <pre>
SELECT SQRT(49);
-- Output: 7
        </pre>
    </div>

    <!-- CBRT -->
    <div class="topic">
        <h2>8. CBRT()</h2>
        <p>Cube root.</p>
        <pre>
SELECT CBRT(27);
-- Output: 3
        </pre>
    </div>

    <!-- MOD -->
    <div class="topic">
        <h2>9. MOD()</h2>
        <p>Returns remainder.</p>
        <pre>
SELECT MOD(17, 5);
-- Output: 2
        </pre>
    </div>

    <!-- PI -->
    <div class="topic">
        <h2>10. PI()</h2>
        <pre>
SELECT PI();
-- Output: 3.14159265358979
        </pre>
    </div>

    <!-- DEGREES -->
    <div class="topic">
        <h2>11. DEGREES()</h2>
        <p>Convert radians → degrees.</p>
        <pre>
SELECT DEGREES(PI());
-- Output: 180
        </pre>
    </div>

    <!-- RADIANS -->
    <div class="topic">
        <h2>12. RADIANS()</h2>
        <p>Convert degrees → radians.</p>
        <pre>
SELECT RADIANS(180);
-- Output: 3.14159
        </pre>
    </div>

    <!-- RANDOM -->
    <div class="topic">
        <h2>13. RANDOM()</h2>
        <p>Generates random number (0 to 1).</p>
        <pre>
SELECT RANDOM();
-- Output: (varies) e.g., 0.89234
        </pre>
    </div>

    <!-- SETSEED -->
    <div class="topic">
        <h2>14. SETSEED()</h2>
        <p>Sets seed for RANDOM().</p>
        <pre>
SELECT SETSEED(0.5);
SELECT RANDOM();
-- Output: (deterministic based on seed)
        </pre>
    </div>

    <!-- EXP -->
    <div class="topic">
        <h2>15. EXP()</h2>
        <pre>
SELECT EXP(1);
-- Output: 2.718281828
        </pre>
    </div>

    <!-- LN -->
    <div class="topic">
        <h2>16. LN()</h2>
        <p>Natural log.</p>
        <pre>
SELECT LN(10);
-- Output: 2.302585093
        </pre>
    </div>

    <!-- LOG -->
    <div class="topic">
        <h2>17. LOG()</h2>
        <p>Log base n.</p>
        <pre>
SELECT LOG(10, 1000);
-- Output: 3
        </pre>
    </div>

    <!-- SIGN -->
    <div class="topic">
        <h2>18. SIGN()</h2>
        <p>Returns -1, 0, or 1.</p>
        <pre>
SELECT SIGN(-50);
-- Output: -1
        </pre>
    </div>

    <!-- WIDTH_BUCKET -->
    <div class="topic">
        <h2>19. WIDTH_BUCKET()</h2>
        <p>Histogram bucket function.</p>
        <pre>
SELECT WIDTH_BUCKET(15, 0, 30, 3);
-- Range 0–30 split into 3 buckets:
-- Output: 2   (because 15 is in 2nd bucket)
        </pre>
    </div>

    <!-- SCALE -->
    <div class="topic">
        <h2>20. SCALE()</h2>
        <p>Number of decimal digits in the fractional part.</p>
        <pre>
SELECT SCALE(123.456);
-- Output: 3
        </pre>
    </div>

    <!-- Numeric Aggregate Functions -->
    <h2>21. Aggregate Numeric Functions</h2>

    <div class="topic">
        <h3>21.1 SUM()</h3>
        <pre>
SELECT SUM(salary) FROM employees;
-- Output example: 150000
        </pre>
    </div>

    <div class="topic">
        <h3>21.2 AVG()</h3>
        <pre>
SELECT AVG(age) FROM employees;
-- Output example: 27.5
        </pre>
    </div>

    <div class="topic">
        <h3>21.3 MIN(), MAX()</h3>
        <pre>
SELECT MIN(age), MAX(age) FROM employees;
-- Output: 21 | 35
        </pre>
    </div>

    <div class="topic">
        <h3>21.4 COUNT()</h3>
        <pre>
SELECT COUNT(*) FROM employees;
-- Output: 8
        </pre>
    </div>

    <div class="topic">
        <h3>21.5 STDDEV(), VARIANCE()</h3>
        <pre>
SELECT STDDEV(salary), VARIANCE(salary) FROM employees;
-- Output: e.g., 4500 | 20250000
        </pre>
    </div>

</section>

<hr>

<section id="date-time-functions">

    <h2>Date & Time Functions in PostgreSQL</h2>

    <!-- CURRENT_DATE -->
    <div class="topic">
        <h2>1. CURRENT_DATE</h2>
        <p>Returns today’s date.</p>
        <pre>
SELECT CURRENT_DATE;
-- Output: 2025-11-30
        </pre>
    </div>

    <!-- CURRENT_TIME -->
    <div class="topic">
        <h2>2. CURRENT_TIME</h2>
        <pre>
SELECT CURRENT_TIME;
-- Output: 10:45:23.123+05:30
        </pre>
    </div>

    <!-- CURRENT_TIMESTAMP -->
    <div class="topic">
        <h2>3. CURRENT_TIMESTAMP</h2>
        <pre>
SELECT CURRENT_TIMESTAMP;
-- Output: 2025-11-30 10:45:23.123+05:30
        </pre>
    </div>

    <!-- NOW() -->
    <div class="topic">
        <h2>4. NOW()</h2>
        <p>Same as CURRENT_TIMESTAMP.</p>
        <pre>
SELECT NOW();
        </pre>
    </div>

    <!-- TIMEOFDAY -->
    <div class="topic">
        <h2>5. TIMEOFDAY()</h2>
        <p>Human-readable system time.</p>
        <pre>
SELECT TIMEOFDAY();
-- Output: Sun Nov 30 10:45:23.123 IST 2025
        </pre>
    </div>

    <!-- AGE -->
    <div class="topic">
        <h2>6. AGE()</h2>
        <p>Difference between two dates.</p>
        <pre>
SELECT AGE('2025-11-30', '2001-04-10');
-- Output: 24 years 7 mons 20 days
        </pre>
    </div>

    <!-- EXTRACT -->
    <div class="topic">
        <h2>7. EXTRACT()</h2>
        <p>Extract part of date/time.</p>
        <pre>
SELECT EXTRACT(YEAR FROM DATE '2025-11-30');
-- Output: 2025

SELECT EXTRACT(MONTH FROM CURRENT_DATE);
-- Output: 11
        </pre>
    </div>

    <!-- DATE_PART -->
    <div class="topic">
        <h2>8. DATE_PART()</h2>
        <pre>
SELECT DATE_PART('dow', DATE '2025-11-30');
-- Output: 0   (Sunday)
        </pre>
    </div>

    <!-- DATE_TRUNC -->
    <div class="topic">
        <h2>9. DATE_TRUNC()</h2>
        <p>Truncate date to specific unit.</p>
        <pre>
SELECT DATE_TRUNC('month', TIMESTAMP '2025-11-30 10:45:00');
-- Output: 2025-11-01 00:00:00
        </pre>
    </div>

    <!-- JUSTIFY_INTERVAL -->
    <div class="topic">
        <h2>10. JUSTIFY_INTERVAL()</h2>
        <p>Fix oversized units (convert 30 days → 1 month etc.).</p>
        <pre>
SELECT JUSTIFY_INTERVAL('30 days');
-- Output: 1 mon
        </pre>
    </div>

    <!-- INTERVAL -->
    <div class="topic">
        <h2>11. INTERVAL</h2>
        <p>Duration representation.</p>
        <pre>
SELECT INTERVAL '2 hours 30 minutes';
-- Output: 02:30:00
        </pre>
    </div>

    <!-- ADD / SUBTRACT -->
    <div class="topic">
        <h2>12. ADD / SUBTRACT Dates</h2>
        <pre>
SELECT DATE '2025-11-30' + INTERVAL '5 days';
-- Output: 2025-12-05

SELECT DATE '2025-11-30' - INTERVAL '1 month';
-- Output: 2025-10-30
        </pre>
    </div>

    <!-- AGE() with now -->
    <div class="topic">
        <h2>13. AGE(timestamp)</h2>
        <pre>
SELECT AGE(NOW());
-- Output: 0 mons 0 days 00:00:00  (age from now to now)
        </pre>
    </div>

    <!-- OVERLAPS -->
    <div class="topic">
        <h2>14. OVERLAPS</h2>
        <p>Check if two time periods overlap.</p>
        <pre>
SELECT (DATE '2025-11-01', DATE '2025-11-10')
     OVERLAPS
       (DATE '2025-11-05', DATE '2025-11-20');

-- Output: true
        </pre>
    </div>

    <!-- MAKE_DATE -->
    <div class="topic">
        <h2>15. MAKE_DATE()</h2>
        <pre>
SELECT MAKE_DATE(2025, 11, 30);
-- Output: 2025-11-30
        </pre>
    </div>

    <!-- MAKE_TIME -->
    <div class="topic">
        <h2>16. MAKE_TIME()</h2>
        <pre>
SELECT MAKE_TIME(10, 45, 30);
-- Output: 10:45:30
        </pre>
    </div>

    <!-- MAKE_TIMESTAMP -->
    <div class="topic">
        <h2>17. MAKE_TIMESTAMP()</h2>
        <pre>
SELECT MAKE_TIMESTAMP(2025, 11, 30, 10, 45, 30);
-- Output: 2025-11-30 10:45:30
        </pre>
    </div>

    <!-- TO_CHAR -->
    <div class="topic">
        <h2>18. TO_CHAR()</h2>
        <p>Format date/time.</p>
        <pre>
SELECT TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI');
-- Output: 2025-11-30 10:45
        </pre>
    </div>

    <!-- TO_DATE -->
    <div class="topic">
        <h2>19. TO_DATE()</h2>
        <pre>
SELECT TO_DATE('30-11-2025', 'DD-MM-YYYY');
-- Output: 2025-11-30
        </pre>
    </div>

    <!-- TO_TIMESTAMP -->
    <div class="topic">
        <h2>20. TO_TIMESTAMP()</h2>
        <pre>
SELECT TO_TIMESTAMP('2025-11-30 10:45', 'YYYY-MM-DD HH24:MI');
-- Output: 2025-11-30 10:45:00
        </pre>
    </div>

    <!-- EXTRACT Time zone -->
    <div class="topic">
        <h2>21. Time Zone Functions</h2>

        <pre>
SELECT NOW() AT TIME ZONE 'UTC';
-- Output: 2025-11-30 05:15:00

SELECT NOW() AT TIME ZONE 'America/New_York';
-- Output: 2025-11-30 00:15:00
        </pre>
    </div>

</section>

<hr>

<section id="conditional-expressions">

    <h2>Conditional Expressions (CASE WHEN)</h2>

    <p>CASE is used to apply conditional logic in SQL queries.</p>

    <!-- SIMPLE CASE -->
    <div class="topic">
        <h2>1. Simple CASE Expression</h2>
        <p>Checks equality only.</p>

        <pre>
SELECT 
    marks,
    CASE marks
        WHEN 100 THEN 'Perfect'
        WHEN 90 THEN 'Excellent'
        WHEN 75 THEN 'Good'
        ELSE 'Average'
    END AS result
FROM students;

-- Output:
-- marks | result
-- 90    | Excellent
-- 72    | Average
        </pre>
    </div>

    <!-- SEARCHED CASE -->
    <div class="topic">
        <h2>2. Searched CASE Expression</h2>
        <p>Checks conditions using &lt;, &gt;, BETWEEN etc.</p>

        <pre>
SELECT 
    marks,
    CASE
        WHEN marks >= 90 THEN 'A'
        WHEN marks >= 80 THEN 'B'
        WHEN marks >= 70 THEN 'C'
        ELSE 'D'
    END AS grade
FROM students;

-- Output:
-- marks | grade
-- 95    | A
-- 76    | C
        </pre>
    </div>

    <!-- CASE with ORDER BY -->
    <div class="topic">
        <h2>3. CASE in ORDER BY (Custom Sorting)</h2>

        <pre>
SELECT name, role FROM employees
ORDER BY
    CASE role
        WHEN 'Manager' THEN 1
        WHEN 'Team Lead' THEN 2
        ELSE 3
    END;

-- Output sorted by custom rank
        </pre>
    </div>

    <!-- CASE as IF-ELSE -->
    <div class="topic">
        <h2>4. CASE as IF-ELSE Logic</h2>

        <pre>
SELECT
    salary,
    CASE 
        WHEN salary &gt; 50000 THEN salary * 0.10
        ELSE salary * 0.05
    END AS bonus
FROM employees;

-- Output:
-- salary | bonus
-- 60000  | 6000
-- 40000  | 2000
        </pre>
    </div>

    <!-- CASE inside AGGREGATES -->
    <div class="topic">
        <h2>5. CASE Inside Aggregate Functions</h2>

        <pre>
SELECT
    SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_count,
    SUM(CASE WHEN gender = 'F' THEN 1 ELSE 0 END) AS female_count
FROM students;

-- Output:
-- male_count | female_count
--     10     |     12
        </pre>
    </div>

    <!-- NULL Handling -->
    <div class="topic">
        <h2>6. CASE for NULL Handling</h2>

        <pre>
SELECT 
    name,
    CASE 
        WHEN phone IS NULL THEN 'No Number'
        ELSE phone
    END AS phone_info
FROM customers;

-- Output:
-- Ram     | 9876543210
-- Kumar   | No Number
        </pre>
    </div>

    <!-- CASE inside UPDATE -->
    <div class="topic">
        <h2>7. CASE in UPDATE Statement</h2>

        <pre>
UPDATE products
SET price = CASE
                WHEN category = 'Electronics' THEN price * 1.10
                WHEN category = 'Clothes' THEN price * 1.05
                ELSE price
            END;

-- Output:
-- Prices updated based on category
        </pre>
    </div>

</section>

<hr>

<section id="null-handling">
    <h2>Null Handling & Type Conversion Functions</h2>

    <!-- COALESCE -->
    <section>
        <h3>COALESCE()</h3>
        <p>Returns the first non-NULL value in the list.</p>

        <h4>Syntax:</h4>
        <pre><code>COALESCE(value1, value2, value3, ...)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT COALESCE(NULL, NULL, 'Hello', 'World');</code></pre>

        <h4>Output:</h4>
        <pre><code>Hello</code></pre>
    </section>

    <!-- NULLIF -->
    <section>
        <h3>NULLIF()</h3>
        <p>Returns NULL if both values are equal; otherwise returns the first value.</p>

        <h4>Syntax:</h4>
        <pre><code>NULLIF(value1, value2)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT NULLIF(10, 10);</code></pre>

        <h4>Output:</h4>
        <pre><code>NULL</code></pre>

        <h4>Another Example:</h4>
        <pre><code>SELECT NULLIF(10, 5);</code></pre>

        <h4>Output:</h4>
        <pre><code>10</code></pre>
    </section>

    <!-- GREATEST / LEAST -->
    <section>
        <h3>GREATEST() / LEAST()</h3>
        <p>GREATEST returns the maximum. LEAST returns the minimum.</p>

        <h4>Syntax:</h4>
        <pre><code>GREATEST(value1, value2, ...)
LEAST(value1, value2, ...)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT GREATEST(10, 20, 5), LEAST(10, 20, 5);</code></pre>

        <h4>Output:</h4>
        <pre><code> greatest | least
----------+-------
    20    |   5
</code></pre>
    </section>

    <!-- TYPE CASTING -->
    <section>
        <h2>Type Conversion</h2>

        <h3>1. CAST()</h3>
        <p>Converts a value from one data type to another.</p>

        <h4>Syntax:</h4>
        <pre><code>CAST(value AS datatype)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT CAST('123' AS INTEGER);</code></pre>

        <h4>Output:</h4>
        <pre><code>123</code></pre>

        <hr>

        <h3>2. Shorthand Casting (::)</h3>
        <p>PostgreSQL allows a shorter syntax for casting.</p>

        <h4>Syntax:</h4>
        <pre><code>value::datatype</code></pre>

        <h4>Examples:</h4>

        <pre><code>SELECT '123'::int;</code></pre>
        <pre><code>SELECT 100::text;</code></pre>
        <pre><code>SELECT '12.50'::numeric;</code></pre>

        <h4>Output:</h4>
        <pre><code>123
100
12.50
</code></pre>

        <h3>3. Common Conversions</h3>
        <pre><code>
SELECT '2024-01-01'::date;
SELECT '10:30'::time;
SELECT 'true'::boolean;
SELECT 99.9::int;       -- result: 100 (rounds)
SELECT '123abc'::int;   -- ERROR (invalid cast)
        </code></pre>
    </section>
</section>

<hr>

<section id="json-array-window-math">
    <h2>JSON, Array, Window & Math Functions</h2>

    <!-- JSON FUNCTIONS -->
    <section id="json-functions">
        <h3>JSON Functions</h3>

        <!-- json_extract_path -->
        <section>
            <h4>json_extract_path()</h4>
            <p>Extracts a value from a JSON object using a path.</p>

            <h4>Syntax:</h4>
            <pre><code>json_extract_path(json, VARIADIC path_elements)</code></pre>

            <h4>Example:</h4>
            <pre><code>
SELECT json_extract_path('{"name":"Aathi","details":{"age":21}}', 'details', 'age');
            </code></pre>

            <h4>Output:</h4>
            <pre><code>21</code></pre>
        </section>

        <!-- jsonb_set -->
        <section>
            <h4>jsonb_set()</h4>
            <p>Updates a value inside a JSONB object.</p>

            <h4>Syntax:</h4>
            <pre><code>jsonb_set(target_jsonb, path, new_value_jsonb)</code></pre>

            <h4>Example:</h4>
            <pre><code>
SELECT jsonb_set('{"name":"Aathi","age":21}'::jsonb,
                 '{age}',
                 '22'::jsonb);
            </code></pre>

            <h4>Output:</h4>
            <pre><code>{"name": "Aathi", "age": 22}</code></pre>
        </section>

        <!-- jsonb_array_elements -->
        <section>
            <h4>jsonb_array_elements()</h4>
            <p>Expands a JSON array into a set of rows.</p>

            <h4>Syntax:</h4>
            <pre><code>jsonb_array_elements(jsonb_array)</code></pre>

            <h4>Example:</h4>
            <pre><code>
SELECT jsonb_array_elements('["java","python","sql"]'::jsonb);
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 jsonb_array_elements
-----------------------
 "java"
 "python"
 "sql"
</code></pre>
        </section>
    </section>

    <hr>

    <!-- ARRAY FUNCTIONS -->
    <section id="array-functions">
        <h3>Array Functions</h3>

        <!-- array_length -->
        <section>
            <h4>array_length()</h4>
            <p>Returns length of array dimension.</p>

            <h4>Example:</h4>
            <pre><code>SELECT array_length(ARRAY[10, 20, 30], 1);</code></pre>

            <h4>Output:</h4>
            <pre><code>3</code></pre>
        </section>

        <!-- array_append -->
        <section>
            <h4>array_append()</h4>
            <p>Adds an element to the end of an array.</p>

            <h4>Example:</h4>
            <pre><code>SELECT array_append(ARRAY[1, 2, 3], 4);</code></pre>

            <h4>Output:</h4>
            <pre><code>{1,2,3,4}</code></pre>
        </section>

        <!-- array_remove -->
        <section>
            <h4>array_remove()</h4>
            <p>Removes all matching values from an array.</p>

            <h4>Example:</h4>
            <pre><code>SELECT array_remove(ARRAY[1, 2, 3, 2], 2);</code></pre>

            <h4>Output:</h4>
            <pre><code>{1,3}</code></pre>
        </section>
    </section>

    <hr>

    <!-- WINDOW FUNCTIONS -->
    <section id="window-functions">
        <h3>Window Functions</h3>

        <!-- row_number -->
        <section>
            <h4>row_number()</h4>
            <p>Gives a unique row number within the partition.</p>

            <h4>Example:</h4>
            <pre><code>
SELECT name, marks,
       row_number() OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 name   | marks | row_number
--------+-------+------------
 Aathi  |   99  |     1
 John   |   90  |     2
 Kiran  |   75  |     3
</code></pre>
        </section>

        <!-- rank -->
        <section>
            <h4>rank()</h4>
            <p>Gives rank with gaps for ties.</p>

            <pre><code>
SELECT name, marks,
       rank() OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 marks | rank
-------+------
  99   | 1
  90   | 2
  90   | 2
  75   | 4   <-- gap
</code></pre>
        </section>

        <!-- dense_rank -->
        <section>
            <h4>dense_rank()</h4>
            <p>No gaps in ranking.</p>

            <pre><code>
SELECT name, marks,
       dense_rank() OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 marks | dense_rank
-------+------------
  99   | 1
  90   | 2
  90   | 2
  75   | 3
</code></pre>
        </section>

        <!-- lag / lead -->
        <section>
            <h4>lag() / lead()</h4>
            <p>lag → previous row, lead → next row.</p>

            <pre><code>
SELECT name, marks,
       lag(marks) OVER (ORDER BY marks),
       lead(marks) OVER (ORDER BY marks)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 name  | marks | lag | lead
-------+-------+-----+------
 Kiran |   75  | NULL| 90
 John  |   90  | 75  | 99
 Aathi |   99  | 90  | NULL
</code></pre>
        </section>

        <!-- ntile -->
        <section>
            <h4>ntile(n)</h4>
            <p>Divides rows into n equal groups.</p>

            <pre><code>
SELECT name, marks,
       ntile(3) OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>
        </section>
    </section>

    <hr>

    <!-- MATH FUNCTIONS -->
    <section id="math-functions">
        <h3>Math Functions</h3>

        <h4>Common Math Functions:</h4>
        <pre><code>
SELECT sin(1.0);
SELECT cos(1.0);
SELECT tan(1.0);
SELECT sqrt(25);
SELECT abs(-10);
SELECT ceil(4.2);
SELECT floor(4.8);
SELECT round(4.567, 2);
        </code></pre>

        <h4>Output (example):</h4>
        <pre><code>
 sin     = 0.84
 cos     = 0.54
 tan     = 1.55
 sqrt    = 5
 abs     = 10
 ceil    = 5
 floor   = 4
 round   = 4.57
</code></pre>
    </section>
</section>

<hr>

<section id="system-functions">
    <h2>System Functions</h2>
    <p>These functions return information about the database, user, session, server, and timestamps.</p>

    <!-- current_database -->
    <section>
        <h3>current_database()</h3>
        <p>Returns the name of the current database.</p>

        <h4>Example:</h4>
        <pre><code>SELECT current_database();</code></pre>

        <h4>Output:</h4>
        <pre><code>mydb</code></pre>
    </section>

    <!-- version -->
    <section>
        <h3>version()</h3>
        <p>Returns PostgreSQL version and build details.</p>

        <h4>Example:</h4>
        <pre><code>SELECT version();</code></pre>

        <h4>Output:</h4>
        <pre><code>
PostgreSQL 15.3 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu) 12.2.0, 64-bit
</code></pre>
    </section>

    <!-- current_user -->
    <section>
        <h3>current_user</h3>
        <p>Returns the user currently executing the query.</p>

        <h4>Example:</h4>
        <pre><code>SELECT current_user;</code></pre>

        <h4>Output:</h4>
        <pre><code>postgres</code></pre>
    </section>

    <!-- now -->
    <section>
        <h3>now()</h3>
        <p>Returns current date and time at query start.</p>

        <h4>Example:</h4>
        <pre><code>SELECT now();</code></pre>

        <h4>Output:</h4>
        <pre><code>2025-11-30 10:15:22.123+05:30</code></pre>
    </section>

    <hr>

    <!-- current_schema -->
    <section>
        <h3>current_schema()</h3>
        <p>Returns the name of the active schema.</p>

        <h4>Example:</h4>
        <pre><code>SELECT current_schema();</code></pre>

        <h4>Output:</h4>
        <pre><code>public</code></pre>
    </section>

    <!-- session_user -->
    <section>
        <h3>session_user</h3>
        <p>The session's login role (may differ from current_user after SET ROLE).</p>

        <h4>Example:</h4>
        <pre><code>SELECT session_user;</code></pre>

        <h4>Output:</h4>
        <pre><code>postgres</code></pre>
    </section>

    <!-- inet_server_addr -->
    <section>
        <h3>inet_server_addr()</h3>
        <p>Returns server IP address.</p>

        <h4>Example:</h4>
        <pre><code>SELECT inet_server_addr();</code></pre>

        <h4>Output:</h4>
        <pre><code>127.0.0.1</code></pre>
    </section>

    <!-- pg_backend_pid -->
    <section>
        <h3>pg_backend_pid()</h3>
        <p>Returns the process ID of your PostgreSQL backend session.</p>

        <h4>Example:</h4>
        <pre><code>SELECT pg_backend_pid();</code></pre>

        <h4>Output:</h4>
        <pre><code>9284</code></pre>
    </section>

    <hr>

    <!-- Timestamp comparision -->
    <section>
        <h3>Timestamp System Functions</h3>

        <h4>1. clock_timestamp()</h4>
        <p>Returns the actual current time (keeps changing during query).</p>

        <pre><code>SELECT clock_timestamp();</code></pre>

        <h4>2. statement_timestamp()</h4>
        <p>Returns timestamp at the start of the current SQL statement.</p>

        <pre><code>SELECT statement_timestamp();</code></pre>

        <h4>3. transaction_timestamp()</h4>
        <p>Returns timestamp at the start of the transaction.</p>

        <pre><code>SELECT transaction_timestamp();</code></pre>

        <h4>Difference Example:</h4>
        <pre><code>
SELECT now(),
       clock_timestamp(),
       statement_timestamp(),
       transaction_timestamp();
        </code></pre>
    </section>
</section>

<hr>

<section id="ddl-create">
    <h2>DDL Commands — CREATE</h2>
    <p>CREATE commands are used to create databases, schemas, tables, views, indexes, sequences, types, functions, and triggers.</p>

    <!-- CREATE DATABASE -->
    <section>
        <h3>1. CREATE DATABASE</h3>

        <pre><code>CREATE DATABASE dbname;</code></pre>

        <h4>With options:</h4>
        <pre><code>
CREATE DATABASE mydb
    WITH OWNER = postgres
         ENCODING = 'UTF8'
         CONNECTION LIMIT = -1
         IS_TEMPLATE = false;
        </code></pre>
    </section>

    <!-- CREATE SCHEMA -->
    <section>
        <h3>2. CREATE SCHEMA</h3>

        <pre><code>CREATE SCHEMA sales;</code></pre>

        <h4>Create with owner:</h4>
        <pre><code>CREATE SCHEMA auth AUTHORIZATION aathi;</code></pre>
    </section>

    <!-- CREATE TABLE -->
    <section>
        <h3>3. CREATE TABLE</h3>

        <h4>Basic Syntax:</h4>
        <pre><code>
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    age  INT,
    salary NUMERIC(10,2),
    active BOOLEAN DEFAULT true
);
        </code></pre>

        <h4>Column Constraints:</h4>
        <ul>
            <li>PRIMARY KEY</li>
            <li>FOREIGN KEY</li>
            <li>UNIQUE</li>
            <li>CHECK</li>
            <li>NOT NULL</li>
            <li>DEFAULT</li>
        </ul>

        <pre><code>
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    amount NUMERIC CHECK (amount > 0),
    status TEXT DEFAULT 'pending',
    cust_id INT REFERENCES customers(id)
);
        </code></pre>

        <h4>Table Constraints:</h4>
        <pre><code>
CREATE TABLE student (
    id INT,
    name TEXT,
    age INT,
    CONSTRAINT age_check CHECK (age > 0),
    CONSTRAINT pk PRIMARY KEY (id)
);
        </code></pre>

        <h4>WITH Options:</h4>
        <pre><code>
CREATE TABLE logs (
    id SERIAL,
    message TEXT
) WITH (fillfactor = 70);
        </code></pre>
    </section>

    <!-- CREATE TABLE AS -->
    <section>
        <h3>4. CREATE TABLE AS</h3>
        <p>Create a table from SELECT result.</p>

        <pre><code>
CREATE TABLE backup_emp AS
SELECT * FROM employees WHERE active = true;
        </code></pre>
    </section>

    <!-- CREATE VIEW -->
    <section>
        <h3>5. CREATE VIEW</h3>

        <pre><code>
CREATE VIEW active_employees AS
SELECT id, name FROM employees WHERE active = true;
        </code></pre>
    </section>

    <!-- CREATE MATERIALIZED VIEW -->
    <section>
        <h3>6. CREATE MATERIALIZED VIEW</h3>

        <pre><code>
CREATE MATERIALIZED VIEW emp_summary AS
SELECT active, count(*) FROM employees GROUP BY active;
        </code></pre>
    </section>

    <!-- CREATE INDEX (basic intro only) -->
    <section>
        <h3>7. CREATE INDEX (Intro)</h3>

        <pre><code>
CREATE INDEX idx_emp_name ON employees(name);
        </code></pre>

        <p>A detailed INDEX section will come later.</p>
    </section>

    <!-- CREATE SEQUENCE -->
    <section>
        <h3>8. CREATE SEQUENCE</h3>

        <pre><code>
CREATE SEQUENCE invoice_seq
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    NO MAXVALUE
    CACHE 1;
        </code></pre>
    </section>

    <!-- CREATE TYPE -->
    <section>
        <h3>9. CREATE TYPE</h3>

        <h4>ENUM Type:</h4>
        <pre><code>
CREATE TYPE status_enum AS ENUM ('pending', 'approved', 'rejected');
        </code></pre>

        <h4>Composite Type:</h4>
        <pre><code>
CREATE TYPE address_type AS (
    city TEXT,
    pincode INT
);
        </code></pre>

        <h4>Range Type:</h4>
        <pre><code>
CREATE TYPE price_range AS RANGE (
    subtype = numeric
);
        </code></pre>
    </section>

    <!-- CREATE FUNCTION -->
    <section>
        <h3>10. CREATE FUNCTION (Simple)</h3>

        <pre><code>
CREATE FUNCTION add_two(a INT, b INT)
RETURNS INT AS $$
BEGIN
    RETURN a + b;
END;
$$ LANGUAGE plpgsql;
        </code></pre>
    </section>

    <!-- CREATE TRIGGER (header only) -->
    <section>
        <h3>11. CREATE TRIGGER (Short form)</h3>

        <pre><code>
CREATE TRIGGER log_changes
AFTER INSERT ON employees
FOR EACH ROW EXECUTE FUNCTION log_employee();
        </code></pre>

        <p>A full TRIGGER section will come later.</p>
    </section>
</section>

<hr>


<h2>DDL Commands - ALTER</h2>

<hr>
<section>
<h2>1. ALTER TABLE</h2>

<h3>1.1 Add Column</h3>
<pre><code>ALTER TABLE table_name 
ADD COLUMN column_name datatype;
</code></pre>

<h3>1.2 Add Multiple Columns</h3>
<pre><code>ALTER TABLE table_name 
ADD COLUMN c1 int,
ADD COLUMN c2 text;
</code></pre>

<h3>1.3 Drop Column</h3>
<pre><code>ALTER TABLE table_name 
DROP COLUMN column_name;
</code></pre>

<h3>Drop Column with CASCADE</h3>
<pre><code>ALTER TABLE table_name 
DROP COLUMN column_name CASCADE;
</code></pre>

<h3>1.4 Rename Column</h3>
<pre><code>ALTER TABLE table_name 
RENAME COLUMN old_name TO new_name;
</code></pre>

<h3>1.5 Change Data Type</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name TYPE new_datatype;
</code></pre>

<h4>With USING</h4>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN price TYPE int USING price::int;
</code></pre>

<h3>1.6 Set Default</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name SET DEFAULT 100;
</code></pre>

<h3>1.7 Drop Default</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name DROP DEFAULT;
</code></pre>

<h3>1.8 Set NOT NULL</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name SET NOT NULL;
</code></pre>

<h3>1.9 Drop NOT NULL</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name DROP NOT NULL;
</code></pre>

<h3>1.10 Rename Table</h3>
<pre><code>ALTER TABLE old_table 
RENAME TO new_table;
</code></pre>

<h3>1.11 Add Constraint</h3>

<h4>Primary Key</h4>
<pre><code>ALTER TABLE table_name 
ADD CONSTRAINT pk_name PRIMARY KEY (column_name);
</code></pre>

<h4>Unique</h4>
<pre><code>ALTER TABLE table_name 
ADD CONSTRAINT u_name UNIQUE (column_name);
</code></pre>

<h4>Foreign Key</h4>
<pre><code>ALTER TABLE child_table 
ADD CONSTRAINT fk_name FOREIGN KEY (column_name)
REFERENCES parent_table(parent_col);
</code></pre>

<h4>Check</h4>
<pre><code>ALTER TABLE table_name 
ADD CONSTRAINT chk_age CHECK (age > 0);
</code></pre>

<h3>1.12 Drop Constraint</h3>

<h4>Primary Key</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT pk_name;
</code></pre>

<h4>Unique</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT u_name;
</code></pre>

<h4>Foreign Key</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT fk_name;
</code></pre>

<h4>Check</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT chk_age;
</code></pre>

<h3>1.13 Add Auto-Increment Column</h3>

<h4>SERIAL</h4>
<pre><code>ALTER TABLE table_name 
ADD COLUMN id SERIAL;
</code></pre>

<h4>IDENTITY</h4>
<pre><code>ALTER TABLE table_name 
ADD COLUMN id INT GENERATED ALWAYS AS IDENTITY;
</code></pre>

<h3>1.14 Column Comment</h3>
<pre><code>COMMENT ON COLUMN table_name.column IS 'description';
</code></pre>

<h3>1.15 Table Comment</h3>
<pre><code>COMMENT ON TABLE table_name IS 'This is the employee table';
</code></pre>

<hr>

<h2>2. ALTER DATABASE</h2>

<h3>Rename Database</h3>
<pre><code>ALTER DATABASE old_name RENAME TO new_name;
</code></pre>

<h3>Change Owner</h3>
<pre><code>ALTER DATABASE db_name OWNER TO new_user;
</code></pre>

<h3>Change Collation</h3>
<pre><code>ALTER DATABASE db_name SET lc_collate TO 'en_US.utf8';
</code></pre>

<hr>

<h2>3. ALTER SCHEMA</h2>

<h3>Rename Schema</h3>
<pre><code>ALTER SCHEMA old_schema RENAME TO new_schema;
</code></pre>

<h3>Change Owner</h3>
<pre><code>ALTER SCHEMA schema_name OWNER TO user_name;
</code></pre>

<hr>

<h2>4. ALTER VIEW</h2>

<h3>Rename View</h3>
<pre><code>ALTER VIEW old_view RENAME TO new_view;
</code></pre>

<h3>Rename Column in View</h3>
<pre><code>ALTER VIEW view_name RENAME COLUMN old TO new;
</code></pre>

<hr>

<h2>5. ALTER FUNCTION</h2>

<h3>Rename Function</h3>
<pre><code>ALTER FUNCTION func_name(args) RENAME TO new_name;
</code></pre>

<h3>Change Owner</h3>
<pre><code>ALTER FUNCTION func_name(args) OWNER TO new_user;
</code></pre>

<hr>

<h2>6. ALTER INDEX</h2>

<h3>Rename Index</h3>
<pre><code>ALTER INDEX old_index RENAME TO new_index;
</code></pre>

<h3>Rebuild Index</h3>
<pre><code>ALTER INDEX index_name REBUILD;
</code></pre>

<hr>

<h2>7. ALTER SEQUENCE</h2>

<h3>Restart Sequence</h3>
<pre><code>ALTER SEQUENCE seq_name RESTART WITH 1;
</code></pre>

<h3>Change Increment</h3>
<pre><code>ALTER SEQUENCE seq_name INCREMENT BY 5;
</code></pre>
</section>

<hr>

<section id="ddl-part-3">
    <h2>DDL : DROP / TRUNCATE / RENAME / COMMENT</h2>
    <hr>

    <!-- DROP SECTION -->
    <h2>1. DROP Commands</h2>

    <h3>1.1 DROP TABLE</h3>
    <pre><code>DROP TABLE table_name;</code></pre>

    <h3>1.2 DROP TABLE IF EXISTS</h3>
    <pre><code>DROP TABLE IF EXISTS table_name;</code></pre>

    <h3>1.3 DROP TABLE CASCADE</h3>
    <pre><code>DROP TABLE table_name CASCADE;
-- Removes table + objects depending on it
</code></pre>

    <h3>1.4 DROP DATABASE</h3>
    <pre><code>DROP DATABASE db_name;</code></pre>

    <h3>1.5 DROP DATABASE IF EXISTS</h3>
    <pre><code>DROP DATABASE IF EXISTS db_name;</code></pre>

    <h3>1.6 DROP SCHEMA</h3>
    <pre><code>DROP SCHEMA schema_name;</code></pre>

    <h3>1.7 DROP SCHEMA CASCADE</h3>
    <pre><code>DROP SCHEMA schema_name CASCADE;
-- Removes schema + all objects inside
</code></pre>

    <h3>1.8 DROP VIEW</h3>
    <pre><code>DROP VIEW view_name;</code></pre>

    <h3>1.9 DROP MATERIALIZED VIEW</h3>
    <pre><code>DROP MATERIALIZED VIEW mv_name;</code></pre>

    <h3>1.10 DROP INDEX</h3>
    <pre><code>DROP INDEX index_name;</code></pre>

    <h3>1.11 DROP SEQUENCE</h3>
    <pre><code>DROP SEQUENCE seq_name;</code></pre>

    <h3>1.12 DROP FUNCTION</h3>
    <pre><code>DROP FUNCTION function_name(args);</code></pre>

    <h3>1.13 DROP TRIGGER</h3>
    <pre><code>DROP TRIGGER trigger_name ON table_name;</code></pre>

    <h3>1.14 DROP TYPE</h3>
    <pre><code>DROP TYPE custom_type;</code></pre>

    <hr>

    <!-- TRUNCATE SECTION -->
    <h2>2. TRUNCATE</h2>

    <h3>2.1 Basic Truncate</h3>
    <pre><code>TRUNCATE TABLE table_name;
-- Removes all rows, keeps structure
</code></pre>

    <h3>2.2 Truncate Multiple Tables</h3>
    <pre><code>TRUNCATE TABLE table1, table2;</code></pre>

    <h3>2.3 TRUNCATE CASCADE</h3>
    <pre><code>TRUNCATE TABLE table_name CASCADE;
-- Removes dependent table rows
</code></pre>

    <h3>2.4 Restart Identity</h3>
    <pre><code>TRUNCATE TABLE table_name RESTART IDENTITY;
-- Resets serial/identity values
</code></pre>

    <h3>2.5 Continue Identity</h3>
    <pre><code>TRUNCATE TABLE table_name CONTINUE IDENTITY;
-- Does not reset serial values
</code></pre>

    <hr>

    <!-- RENAME SECTION -->
    <h2>3. RENAME</h2>

    <h3>3.1 Rename Table</h3>
    <pre><code>ALTER TABLE old_name RENAME TO new_name;</code></pre>

    <h3>3.2 Rename Column</h3>
    <pre><code>ALTER TABLE table_name 
RENAME COLUMN old_col TO new_col;</code></pre>

    <h3>3.3 Rename View</h3>
    <pre><code>ALTER VIEW old_view RENAME TO new_view;</code></pre>

    <h3>3.4 Rename Index</h3>
    <pre><code>ALTER INDEX old_index RENAME TO new_index;</code></pre>

    <h3>3.5 Rename Sequence</h3>
    <pre><code>ALTER SEQUENCE old_seq RENAME TO new_seq;</code></pre>

    <h3>3.6 Rename Database</h3>
    <pre><code>ALTER DATABASE old_name RENAME TO new_name;</code></pre>

    <h3>3.7 Rename Schema</h3>
    <pre><code>ALTER SCHEMA old_schema RENAME TO new_schema;</code></pre>

    <hr>

    <!-- COMMENT SECTION -->
    <h2>4. COMMENT</h2>

    <h3>4.1 Comment on Table</h3>
    <pre><code>COMMENT ON TABLE employees 
IS 'Employee master table';</code></pre>

    <h3>4.2 Comment on Column</h3>
    <pre><code>COMMENT ON COLUMN employees.salary 
IS 'Salary stored in INR';</code></pre>

    <h3>4.3 Comment on Database</h3>
    <pre><code>COMMENT ON DATABASE mydb 
IS 'Production database';</code></pre>

    <h3>4.4 Comment on Schema</h3>
    <pre><code>COMMENT ON SCHEMA sales 
IS 'Contains sales-related tables';</code></pre>

    <h3>4.5 Comment on Function</h3>
    <pre><code>COMMENT ON FUNCTION calculate_bonus(int) 
IS 'Calculates employee bonus';</code></pre>

    <h3>4.6 Comment on View</h3>
    <pre><code>COMMENT ON VIEW emp_view 
IS 'View for employee details';</code></pre>

    <h3>4.7 Comment on Sequence</h3>
    <pre><code>COMMENT ON SEQUENCE emp_seq 
IS 'Employee ID sequence';</code></pre>

</section>

<hr>

<section id="dml">
    <h1>DML (Data Manipulation Language)</h1>
    <hr>

    <!-- INSERT -->
    <h2>1. INSERT</h2>

    <h3>1.1 Insert into all columns</h3>
    <pre><code>INSERT INTO employees
VALUES (1, 'Rahul', 50000, 'IT');</code></pre>

    <h3>1.2 Insert into specific columns</h3>
    <pre><code>INSERT INTO employees (id, name)
VALUES (2, 'Karan');</code></pre>

    <h3>1.3 Insert multiple rows</h3>
    <pre><code>INSERT INTO employees (id, name, salary, dept)
VALUES 
(3, 'Meena', 45000, 'HR'),
(4, 'Arjun', 55000, 'IT');</code></pre>

    <h3>1.4 Insert using SELECT</h3>
    <pre><code>INSERT INTO backup_employees
SELECT * FROM employees;</code></pre>

    <h3>1.5 Insert with DEFAULT</h3>
    <pre><code>INSERT INTO employees (id, name, salary)
VALUES (5, 'Anu', DEFAULT);</code></pre>

    <h3>1.6 Insert JSON values</h3>
    <pre><code>INSERT INTO products (id, details)
VALUES (1, '{"color":"red","size":"L"}');</code></pre>

    <hr>

    <!-- UPDATE -->
    <h2>2. UPDATE</h2>

    <h3>2.1 Basic Update</h3>
    <pre><code>UPDATE employees
SET salary = 60000
WHERE id = 1;</code></pre>

    <h3>2.2 Update multiple columns</h3>
    <pre><code>UPDATE employees
SET salary = 70000, dept = 'Finance'
WHERE id = 2;</code></pre>

    <h3>2.3 Update all rows</h3>
    <pre><code>UPDATE employees
SET dept = 'General';</code></pre>

    <h3>2.4 Update using subquery</h3>
    <pre><code>UPDATE employees e
SET salary = salary + 5000
WHERE e.dept IN (
    SELECT dept FROM high_performance
);</code></pre>

    <h3>2.5 Update with RETURNING (PostgreSQL)</h3>
    <pre><code>UPDATE employees
SET salary = salary + 1000
WHERE id = 3
RETURNING *;</code></pre>

    <hr>

    <!-- DELETE -->
    <h2>3. DELETE</h2>

    <h3>3.1 Delete specific rows</h3>
    <pre><code>DELETE FROM employees
WHERE id = 4;</code></pre>

    <h3>3.2 Delete all rows</h3>
    <pre><code>DELETE FROM employees;</code></pre>

    <h3>3.3 Delete using subquery</h3>
    <pre><code>DELETE FROM employees
WHERE id IN (
    SELECT emp_id FROM inactive_employees
);</code></pre>

    <h3>3.4 DELETE with RETURNING</h3>
    <pre><code>DELETE FROM employees
WHERE id = 5
RETURNING *;</code></pre>

    <hr>

    <!-- SELECT -->
    <h2>4. SELECT (Most Important DML)</h2>

    <h3>4.1 Select all rows</h3>
    <pre><code>SELECT * FROM employees;</code></pre>

    <h3>4.2 Select specific columns</h3>
    <pre><code>SELECT name, salary FROM employees;</code></pre>

    <h3>4.3 DISTINCT values</h3>
    <pre><code>SELECT DISTINCT dept FROM employees;</code></pre>

    <h3>4.4 WHERE condition</h3>
    <pre><code>SELECT * FROM employees
WHERE salary > 50000;</code></pre>

    <h3>4.5 AND / OR</h3>
    <pre><code>SELECT * FROM employees
WHERE dept = 'IT' AND salary > 40000;</code></pre>

    <h3>4.6 ORDER BY</h3>
    <pre><code>SELECT * FROM employees
ORDER BY salary DESC;</code></pre>

    <h3>4.7 LIMIT</h3>
    <pre><code>SELECT * FROM employees
LIMIT 5;</code></pre>

    <h3>4.8 OFFSET</h3>
    <pre><code>SELECT * FROM employees
LIMIT 10 OFFSET 20;</code></pre>

    <h3>4.9 BETWEEN</h3>
    <pre><code>SELECT * FROM employees
WHERE salary BETWEEN 30000 AND 70000;</code></pre>

    <h3>4.10 IN</h3>
    <pre><code>SELECT * FROM employees
WHERE dept IN ('IT','HR');</code></pre>

    <h3>4.11 LIKE</h3>
    <pre><code>SELECT * FROM employees
WHERE name LIKE 'A%';</code></pre>

    <h3>4.12 ILIKE (Case-insensitive)</h3>
    <pre><code>SELECT * FROM employees
WHERE name ILIKE '%an%';</code></pre>

    <h3>4.13 Aggregates</h3>
    <pre><code>SELECT COUNT(*), AVG(salary), SUM(salary)
FROM employees;</code></pre>

    <h3>4.14 GROUP BY</h3>
    <pre><code>SELECT dept, COUNT(*)
FROM employees
GROUP BY dept;</code></pre>

    <h3>4.15 HAVING</h3>
    <pre><code>SELECT dept, COUNT(*)
FROM employees
GROUP BY dept
HAVING COUNT(*) > 2;</code></pre>

    <h3>4.16 Subquery</h3>
    <pre><code>SELECT name FROM employees
WHERE salary > (
    SELECT AVG(salary) FROM employees
);</code></pre>

    <h3>4.17 JOIN (basic)</h3>
    <pre><code>SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept = d.id;</code></pre>

</section>


<hr>

<section id="dql">
    <h1>DQL (Data Query Language)</h1>
    <p>DQL is used to retrieve data from the database. The primary command is <b>SELECT</b>.</p>
    <hr>

    <!-- SELECT -->
    <h2>1. SELECT</h2>

    <h3>1.1 Select all columns</h3>
    <pre><code>SELECT * FROM employees;</code></pre>

    <h3>1.2 Select specific columns</h3>
    <pre><code>SELECT name, salary FROM employees;</code></pre>

    <h3>1.3 Select with expressions</h3>
    <pre><code>SELECT name, salary * 12 AS yearly_salary
FROM employees;</code></pre>

    <h3>1.4 Select with column alias</h3>
    <pre><code>SELECT name AS employee_name, dept AS department
FROM employees;</code></pre>

    <h3>1.5 Select with table alias</h3>
    <pre><code>SELECT e.name, e.salary
FROM employees e;</code></pre>

    <hr>

    <!-- WHERE -->
    <h2>2. WHERE</h2>

    <h3>2.1 Basic condition</h3>
    <pre><code>SELECT * FROM employees
WHERE salary > 50000;</code></pre>

    <h3>2.2 AND / OR</h3>
    <pre><code>SELECT * FROM employees
WHERE dept = 'IT' AND salary > 45000;</code></pre>

    <h3>2.3 BETWEEN</h3>
    <pre><code>SELECT * FROM employees
WHERE salary BETWEEN 30000 AND 60000;</code></pre>

    <h3>2.4 IN</h3>
    <pre><code>SELECT * FROM employees
WHERE dept IN ('IT', 'HR');</code></pre>

    <h3>2.5 LIKE</h3>
    <pre><code>SELECT * FROM employees
WHERE name LIKE 'A%';</code></pre>

    <h3>2.6 ILIKE (case-insensitive)</h3>
    <pre><code>SELECT * FROM employees
WHERE name ILIKE '%an%';</code></pre>

    <h3>2.7 IS NULL / IS NOT NULL</h3>
    <pre><code>SELECT * FROM employees
WHERE salary IS NULL;</code></pre>

    <hr>

    <!-- ORDER BY -->
    <h2>3. ORDER BY</h2>

    <h3>3.1 Ascending</h3>
    <pre><code>SELECT * FROM employees
ORDER BY salary ASC;</code></pre>

    <h3>3.2 Descending</h3>
    <pre><code>SELECT * FROM employees
ORDER BY salary DESC;</code></pre>

    <h3>3.3 Multiple columns</h3>
    <pre><code>SELECT * FROM employees
ORDER BY dept ASC, salary DESC;</code></pre>

    <hr>

    <!-- LIMIT & OFFSET -->
    <h2>4. LIMIT & OFFSET</h2>

    <h3>4.1 LIMIT</h3>
    <pre><code>SELECT * FROM employees
LIMIT 5;</code></pre>

    <h3>4.2 OFFSET</h3>
    <pre><code>SELECT * FROM employees
OFFSET 10;</code></pre>

    <h3>4.3 LIMIT + OFFSET</h3>
    <pre><code>SELECT * FROM employees
LIMIT 10 OFFSET 20;</code></pre>

    <h3>4.4 Pagination example</h3>
    <pre><code>-- Page number = 3, page size = 10
SELECT * FROM employees
LIMIT 10 OFFSET 20;</code></pre>

    <hr>

    <!-- DISTINCT -->
    <h2>5. DISTINCT</h2>

    <h3>5.1 Remove duplicates</h3>
    <pre><code>SELECT DISTINCT dept
FROM employees;</code></pre>

    <h3>5.2 DISTINCT on multiple columns</h3>
    <pre><code>SELECT DISTINCT dept, salary
FROM employees;</code></pre>

    <h3>5.3 DISTINCT ON (PostgreSQL only)</h3>
    <pre><code>SELECT DISTINCT ON (dept) dept, name, salary
FROM employees
ORDER BY dept, salary DESC;</code></pre>
    <p>→ Keeps the row with highest salary per department.</p>

</section>

<hr>

<section>
  <h2>🔹 Full SQL Conditions (Comparison + Logical + Pattern + NULL + Subquery Operators)</h2>

  <p>This section covers all important SQL conditional operators used inside WHERE clauses.</p>

  <!-- Comparison Operators -->
  <h3>1️⃣ Comparison Operators</h3>
  <pre>
=     → Equal  
>     → Greater than  
<     → Less than  
>=    → Greater than or equal  
<=    → Less than or equal  
!= or <> → Not equal  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM employees
WHERE salary >= 30000;
  </pre>

  <hr>

  <!-- Logical Operators -->
  <h3>2️⃣ Logical Operators</h3>
  <pre>
AND   → All conditions must be TRUE  
OR    → At least one condition is TRUE  
NOT   → Negates a condition
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM employees
WHERE department = 'IT' AND salary > 40000;
  </pre>

  <hr>

  <!-- BETWEEN -->
  <h3>3️⃣ BETWEEN & NOT BETWEEN</h3>
  <p>Checks if a value lies inside a range (inclusive).</p>

  <pre>
BETWEEN      → value in range  
NOT BETWEEN  → value outside range  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM products
WHERE price BETWEEN 100 AND 500;

SELECT * FROM products
WHERE price NOT BETWEEN 100 AND 500;
  </pre>

  <hr>

  <!-- LIKE and ILIKE -->
  <h3>4️⃣ LIKE & ILIKE</h3>
  <p>
  LIKE → Case-sensitive pattern match<br>
  ILIKE → Case-insensitive pattern match (PostgreSQL)
  </p>

  <h4>Wildcards:</h4>
  <pre>
%  → zero or more characters  
_  → one character  
  </pre>

  <h4>Examples:</h4>
  <pre>
SELECT * FROM customers WHERE name LIKE 'A%';
SELECT * FROM customers WHERE name ILIKE '%john%';
  </pre>

  <hr>

  <!-- IN -->
  <h3>5️⃣ IN & NOT IN</h3>
  <p>Checks if a value exists inside a list.</p>

  <pre>
IN      → value exists in list  
NOT IN  → value NOT in list  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM orders
WHERE status IN ('Pending', 'Shipped');

SELECT * FROM orders
WHERE status NOT IN ('Cancelled', 'Returned');
  </pre>

  <hr>

  <!-- EXISTS -->
  <h3>6️⃣ EXISTS & NOT EXISTS</h3>
  <p>Checks if a subquery returns at least one row.</p>

  <pre>
EXISTS      → TRUE if subquery returns ≥1 row  
NOT EXISTS  → TRUE if subquery returns 0 rows  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT name FROM customers c
WHERE EXISTS (
  SELECT 1 FROM orders o
  WHERE o.customer_id = c.id
);

SELECT name FROM customers c
WHERE NOT EXISTS (
  SELECT 1 FROM orders o
  WHERE o.customer_id = c.id
);
  </pre>

  <hr>

  <!-- NULL Check -->
  <h3>7️⃣ IS NULL & IS NOT NULL</h3>
  <p>Used to check NULL values ( = or != cannot be used ).</p>

  <pre>
IS NULL       → value is NULL  
IS NOT NULL   → value is NOT NULL  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM employees WHERE bonus IS NULL;
SELECT * FROM employees WHERE bonus IS NOT NULL;
  </pre>

  <hr>

  <!-- ANY & SOME -->
  <h3>8️⃣ ANY & SOME (same meaning)</h3>
  <p>Used with subqueries — condition is TRUE if it matches **any value** returned.</p>

  <pre>
ANY → TRUE if condition matches at least one value  
SOME → SAME as ANY  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM products
WHERE price > ANY (SELECT price FROM products WHERE category='Electronics');
  </pre>

  <hr>

  <!-- ALL -->
  <h3>9️⃣ ALL Operator</h3>
  <p>Condition must be TRUE for **all values** in the subquery.</p>

  <h4>Example:</h4>
  <pre>
SELECT * FROM products
WHERE price > ALL (SELECT price FROM products WHERE category='Mobile');
  </pre>

  <hr>

  <!-- Extra -->
  <h3>🔟 Other Important Operators (Extra)</h3>
  <pre>
= ANY(...)       → Same as IN  
!= ALL(...)      → No value should match  
value IS TRUE    → Boolean check (PostgreSQL)  
value IS FALSE  
value IS UNKNOWN  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM flags WHERE is_active IS TRUE;
  </pre>

</section>

<hr>

<section>
  <h2>🔹 SQL Joins & Set Operations</h2>
  <p>
    Joins are used to combine rows from two or more tables based on a related column.
    Below are all common joins with examples and outputs.
  </p>

  <!-- Sample Tables -->
  <h3>Sample Tables Used in Examples</h3>

  <h4>Employees Table</h4>
  <pre>
 id | name     | dept_id
----+----------+---------
 1  | Aathi    |   10
 2  | John     |   20
 3  | Kumar    |   10
 4  | Priya    |   30
 5  | David    |  NULL
  </pre>

  <h4>Departments Table</h4>
  <pre>
 dept_id | dept_name
---------+-----------
   10    | IT
   20    | HR
   40    | Sales
  </pre>

  <hr>

  <!-- 1. INNER JOIN -->
  <h3>1️⃣ INNER JOIN</h3>
  <p>Returns rows where matching values exist in both tables.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
INNER JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
  </pre>

  <hr>

  <!-- 2. LEFT JOIN -->
  <h3>2️⃣ LEFT JOIN</h3>
  <p>Returns all rows from LEFT table + matching rows from RIGHT table.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
LEFT JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
 Priya | NULL
 David | NULL
  </pre>

  <hr>

  <!-- 3. RIGHT JOIN -->
  <h3>3️⃣ RIGHT JOIN</h3>
  <p>Returns all rows from RIGHT table + matching rows from LEFT table.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
RIGHT JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
 NULL  | Sales     -- dept 40 has no employees
  </pre>

  <hr>

  <!-- 4. FULL OUTER JOIN -->
  <h3>4️⃣ FULL OUTER JOIN</h3>
  <p>Returns ALL rows from both tables (matched + unmatched).</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
FULL JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
 Priya | NULL
 David | NULL
 NULL  | Sales
  </pre>

  <hr>

  <!-- 5. CROSS JOIN -->
  <h3>5️⃣ CROSS JOIN</h3>
  <p>Creates a Cartesian product (every row combined with every row).</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
CROSS JOIN departments d;
  </pre>

  <h4>Output (Partial):</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Aathi | HR
 Aathi | Sales
 John  | IT
 John  | HR
 ... many more rows ...
  </pre>

  <hr>

  <!-- 6. SELF JOIN -->
  <h3>6️⃣ SELF JOIN</h3>
  <p>A table joins with itself. Example: employees reporting to managers.</p>

  <pre>
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m
ON e.manager_id = m.id;
  </pre>

  <h4>Output (Example):</h4>
  <pre>
 employee | manager
----------+---------
 Kumar    | Aathi
 Priya    | John
 David    | NULL
  </pre>

  <hr>

  <!-- 7. NATURAL JOIN -->
  <h3>7️⃣ NATURAL JOIN</h3>
  <p>
    Automatically joins tables using columns with the SAME NAME.<br>
    ⚠ Not recommended for production because unpredictable.
  </p>

  <pre>
SELECT *
FROM employees
NATURAL JOIN departments;
  </pre>

  <hr>

  <!-- 8. USING clause -->
  <h3>8️⃣ USING Clause</h3>
  <p>Cleaner join when both tables share the same column name.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d
USING (dept_id);
  </pre>

  <hr>

  <!-- 9. LATERAL JOIN -->
  <h3>9️⃣ LATERAL JOIN (PostgreSQL Only)</h3>
  <p>
    Allows a subquery to depend on each row of the outer table.<br>
    Super useful for JSON, arrays, and complex calculations.
  </p>

  <pre>
SELECT e.name, x.skill
FROM employees e,
LATERAL unnest(e.skills) AS x(skill);
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | skill
-------+--------
 Aathi | Java
 Aathi | SQL
 John  | Python
  </pre>

  <hr>

  <!-- Set Operators -->
  <h2>🔹 Set Operators</h2>

  <p>Used to combine results of two SELECT queries.</p>

  <!-- UNION -->
  <h3>1️⃣ UNION</h3>
  <p>Removes duplicates (distinct).</p>

  <pre>
SELECT name FROM table1
UNION
SELECT name FROM table2;
  </pre>

  <!-- UNION ALL -->
  <h3>2️⃣ UNION ALL</h3>
  <p>Keeps duplicates.</p>

  <pre>
SELECT name FROM table1
UNION ALL
SELECT name FROM table2;
  </pre>

  <!-- INTERSECT -->
  <h3>3️⃣ INTERSECT</h3>
  <p>Returns only common rows.</p>

  <pre>
SELECT name FROM table1
INTERSECT
SELECT name FROM table2;
  </pre>

  <!-- EXCEPT -->
  <h3>4️⃣ EXCEPT</h3>
  <p>Returns rows from first query that are NOT in second.</p>

  <pre>
SELECT name FROM table1
EXCEPT
SELECT name FROM table2;
  </pre>

  <hr>

  <!-- Extra -->
  <h3>5️⃣ Important Rules for Set Operators</h3>
  <pre>
✔ Both SELECT queries must have same number of columns  
✔ Column order must match  
✔ Data types must be compatible  
✔ ORDER BY only allowed at end  
  </pre>

</section>

<hr>

<section>
  <h2>🔹 SQL Subqueries</h2>

  <p>
    A subquery is a query inside another query. It can return a single value,
    a row, multiple rows, or a complete table.
  </p>

  <hr>

  <!-- Scalar Subquery -->
  <h3>1️⃣ Scalar Subquery (Returns ONE value)</h3>
  <p>Used when subquery returns exactly one value.</p>

  <pre>
SELECT name, salary
FROM employees
WHERE salary > (
    SELECT AVG(salary) FROM employees
);
  </pre>

  <h4>Output:</h4>
  <pre>
 name   | salary
--------+---------
 Aathi  | 60000
 Kumar  | 55000
  </pre>

  <hr>

  <!-- Row Subquery -->
  <h3>2️⃣ Row Subquery (Returns ONE complete row)</h3>

  <pre>
SELECT * FROM employees
WHERE (dept_id, salary) = (
    SELECT dept_id, MAX(salary)
    FROM employees
    GROUP BY dept_id
    LIMIT 1
);
  </pre>

  <hr>

  <!-- Table Subquery -->
  <h3>3️⃣ Table Subquery (Used like a table)</h3>

  <pre>
SELECT * FROM (
    SELECT name, salary FROM employees
    WHERE salary > 50000
) AS high_salary;
  </pre>

  <hr>

  <!-- Single Row -->
  <h3>4️⃣ Single-Row Subquery</h3>

  <pre>
SELECT name
FROM employees
WHERE salary = (
    SELECT MAX(salary) FROM employees
);
  </pre>

  <hr>

  <!-- Multi Row -->
  <h3>5️⃣ Multi-Row Subquery</h3>
  <p>Uses IN, ANY, SOME, ALL.</p>

  <pre>
SELECT name
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments
    WHERE location = 'Chennai'
);
  </pre>

  <hr>

  <!-- Multi Column -->
  <h3>6️⃣ Multi-Column Subquery</h3>

  <pre>
SELECT name
FROM employees
WHERE (dept_id, salary) IN (
    SELECT dept_id, MAX(salary)
    FROM employees
    GROUP BY dept_id
);
  </pre>

  <hr>

  <!-- Correlated Subquery -->
  <h3>7️⃣ Correlated Subquery</h3>
  <p>
    Subquery depends on outer query. Runs once for each row of outer query.
  </p>

  <pre>
SELECT e1.name, e1.salary
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.dept_id = e1.dept_id
);
  </pre>

  <h4>Output:</h4>
  <pre>
 name   | salary
--------+---------
 Aathi  | 60000
 John   | 55000
  </pre>

  <hr>

  <!-- EXISTS vs IN -->
  <h3>8️⃣ EXISTS vs IN (Deep Explanation)</h3>

  <h4>IN → Compares VALUES</h4>
  <p>Used when subquery returns a list of scalar values.</p>

  <pre>
SELECT name
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments
);
  </pre>

  <h4>EXISTS → Checks if at least one row exists</h4>

  <pre>
SELECT name
FROM employees e
WHERE EXISTS (
    SELECT 1
    FROM departments d
    WHERE d.dept_id = e.dept_id
);
  </pre>

  <h4>Performance:</h4>
  <pre>
✔ EXISTS → faster for large tables  
✔ IN → loads all values, slower  
✔ EXISTS stops as soon as ONE match is found  
  </pre>

  <h4>NOT EXISTS vs NOT IN:</h4>
  <pre>
NOT IN fails if NULL exists  
NOT EXISTS is safe with NULLs → always preferred
  </pre>

  <hr>

  <!-- Subquery inside SELECT -->
  <h3>9️⃣ Subquery inside SELECT</h3>

  <pre>
SELECT
    name,
    salary,
    (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees;
  </pre>

  <h4>Output:</h4>
  <pre>
 name   | salary | avg_salary
--------+--------+------------
 Aathi  | 60000  | 45000
 John   | 55000  | 45000
 Priya  | 30000  | 45000
  </pre>

  <hr>

  <!-- Subquery inside FROM -->
  <h3>🔟 Subquery inside FROM (Inline View)</h3>

  <pre>
SELECT name, salary
FROM (
    SELECT name, salary
    FROM employees
    WHERE salary > 40000
) AS temp;
  </pre>

  <hr>

  <!-- ANY SOME ALL -->
  <h3>1️⃣1️⃣ ANY / SOME / ALL</h3>

  <h4>ANY / SOME → match ANY value</h4>
  <pre>
SELECT name
FROM employees
WHERE salary > ANY (
    SELECT salary FROM employees WHERE dept_id = 10
);
  </pre>

  <h4>ALL → must be true for all values</h4>
  <pre>
SELECT name
FROM employees
WHERE salary > ALL (
    SELECT salary FROM employees WHERE dept_id = 10
);
  </pre>

</section>

<hr>

<section>
  <h2>🔹 SQL Constraints</h2>

  <p>
    Constraints are rules applied on table columns to maintain data integrity.
    Below are all major PostgreSQL constraints with examples.
  </p>

  <hr>

  <!-- PRIMARY KEY -->
  <h3>1️⃣ PRIMARY KEY</h3>
  <p>
    Ensures column has UNIQUE and NOT NULL values.  
    A table can have only one primary key (can be single or composite).
  </p>

  <h4>Example:</h4>
  <pre>
CREATE TABLE students (
    id INT PRIMARY KEY,
    name TEXT
);
  </pre>

  <h4>Composite Primary Key:</h4>
  <pre>
CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    PRIMARY KEY(student_id, course_id)
);
  </pre>

  <hr>

  <!-- FOREIGN KEY -->
  <h3>2️⃣ FOREIGN KEY</h3>
  <p>
    Links two tables. Ensures referenced value exists in parent table.
  </p>

  <h4>Example:</h4>
  <pre>
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name TEXT
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name TEXT,
    dept_id INT REFERENCES departments(dept_id)
);
  </pre>

  <h4>Foreign Key with Cascade Options:</h4>
  <pre>
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name TEXT,
    dept_id INT,
    FOREIGN KEY(dept_id)
      REFERENCES departments(dept_id)
      ON DELETE SET NULL
      ON UPDATE CASCADE
);
  </pre>

  <pre>
ON DELETE CASCADE     → delete related rows
ON DELETE SET NULL    → set dept_id = NULL when parent deleted
ON UPDATE CASCADE     → update child automatically
  </pre>

  <hr>

  <!-- UNIQUE -->
  <h3>3️⃣ UNIQUE</h3>
  <p>
    Ensures all column values are different. NULL is allowed.
  </p>

  <pre>
CREATE TABLE users (
    email TEXT UNIQUE,
    username TEXT UNIQUE
);
  </pre>

  <h4>Composite UNIQUE key:</h4>
  <pre>
CREATE TABLE orders (
    order_id INT,
    item_id INT,
    UNIQUE(order_id, item_id)
);
  </pre>

  <hr>

  <!-- NOT NULL -->
  <h3>4️⃣ NOT NULL</h3>
  <p>Column cannot contain NULL values.</p>

  <pre>
CREATE TABLE products (
    id INT PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC NOT NULL
);
  </pre>

  <hr>

  <!-- CHECK -->
  <h3>5️⃣ CHECK Constraint</h3>
  <p>Ensures values meet a condition.</p>

  <pre>
CREATE TABLE employees (
    id INT PRIMARY KEY,
    age INT CHECK (age >= 18),
    salary NUMERIC CHECK (salary > 0)
);
  </pre>

  <h4>Multiple CHECK Constraints:</h4>
  <pre>
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    balance NUMERIC,
    CHECK (balance >= 0 AND balance <= 100000)
);
  </pre>

  <hr>

  <!-- DEFAULT -->
  <h3>6️⃣ DEFAULT</h3>
  <p>Assigns a default value if no value is provided.</p>

  <pre>
CREATE TABLE orders (
    id INT PRIMARY KEY,
    status TEXT DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT NOW()
);
  </pre>

  <hr>

  <!-- AUTO-INCREMENT -->
  <h3>7️⃣ AUTO-INCREMENT</h3>

  <h4>1. SERIAL (older method)</h4>
  <pre>
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name TEXT
);
  </pre>

  <p>Automatically creates:</p>
  <pre>
id integer NOT NULL DEFAULT nextval('students_id_seq')
  </pre>

  <h4>2. IDENTITY (preferred modern method)</h4>
  <pre>
CREATE TABLE students (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT
);
  </pre>

  <h4>Identity Options:</h4>
  <pre>
GENERATED ALWAYS AS IDENTITY
  → cannot manually insert values

GENERATED BY DEFAULT AS IDENTITY
  → allows manual insert if needed
  </pre>

  <hr>

  <!-- Add Constraints Later -->
  <h3>8️⃣ Adding Constraints AFTER Table Creation</h3>

  <!-- Add PK -->
  <h4>Add Primary Key:</h4>
  <pre>
ALTER TABLE students
ADD CONSTRAINT pk_students PRIMARY KEY(id);
  </pre>

  <!-- Add Unique -->
  <h4>Add Unique:</h4>
  <pre>
ALTER TABLE users
ADD CONSTRAINT unique_email UNIQUE(email);
  </pre>

  <!-- Add Foreign Key -->
  <h4>Add Foreign Key:</h4>
  <pre>
ALTER TABLE employees
ADD CONSTRAINT fk_dept
FOREIGN KEY(dept_id) REFERENCES departments(dept_id);
  </pre>

  <!-- Add Check -->
  <h4>Add Check:</h4>
  <pre>
ALTER TABLE employees
ADD CONSTRAINT check_salary CHECK(salary > 0);
  </pre>

  <hr>

  <!-- Remove Constraints -->
  <h3>9️⃣ Dropping Constraints</h3>

  <pre>
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
  </pre>

  <h4>Examples:</h4>
  <pre>
ALTER TABLE employees DROP CONSTRAINT fk_dept;
ALTER TABLE users DROP CONSTRAINT unique_email;
ALTER TABLE students DROP CONSTRAINT pk_students;
  </pre>

</section>

<hr>

<section id="referential-integrity">
  <h2>🔗 Referential Integrity Actions (ON DELETE / ON UPDATE)</h2>

  <p>
    Referential actions define what should happen to the child table when the referenced row in the parent
    table is <b>deleted</b> or <b>updated</b>. These options apply to FOREIGN KEY constraints.
  </p>

  <h3>📝 Syntax</h3>
  <pre>
CREATE TABLE child_table (
    ...
    column REFERENCES parent_table(id)
        ON DELETE action
        ON UPDATE action
);
  </pre>

  <h3>📌 Available Actions</h3>

  <h3>1️⃣ ON DELETE / ON UPDATE CASCADE</h3>
  <p>Automatically deletes or updates the child rows when the parent row is deleted or updated.</p>

  <h4>Example</h4>
  <pre>
CREATE TABLE parent (
    id INT PRIMARY KEY
);

CREATE TABLE child (
    cid INT PRIMARY KEY,
    pid INT REFERENCES parent(id) ON DELETE CASCADE
);

INSERT INTO parent VALUES (1);
INSERT INTO child VALUES (101, 1);

DELETE FROM parent WHERE id = 1;
-- Child row with pid = 1 is also deleted.
  </pre>

  <h4>Output</h4>
  <pre>
child table → empty (child row deleted)
  </pre>

  <hr>

  <h3>2️⃣ ON DELETE / ON UPDATE SET NULL</h3>
  <p>Sets the foreign key column to NULL when the parent row is deleted/updated.</p>

  <pre>
CREATE TABLE child (
    cid INT PRIMARY KEY,
    pid INT REFERENCES parent(id) ON DELETE SET NULL
);

-- After deleting parent row: pid becomes NULL
  </pre>

  <pre>Output:
cid | pid
------------
101 | NULL
  </pre>

  <hr>

  <h3>3️⃣ ON DELETE / ON UPDATE SET DEFAULT</h3>
  <p>Sets the child FK to its DEFAULT value.</p>

  <pre>
CREATE TABLE child (
    cid INT PRIMARY KEY,
    pid INT DEFAULT 0 REFERENCES parent(id) ON DELETE SET DEFAULT
);
  </pre>

  <pre>Output:
cid | pid
------------
101 | 0
  </pre>

  <hr>

  <h3>4️⃣ ON DELETE / ON UPDATE RESTRICT</h3>
  <p>
    Prevents deletion or update of the parent row if it is referenced in the child table.
    (Check happens immediately.)
  </p>

  <pre>
DELETE FROM parent WHERE id = 1;
-- ERROR: update or delete on table "parent" violates foreign key constraint
  </pre>

  <hr>

  <h3>5️⃣ ON DELETE / ON UPDATE NO ACTION (DEFAULT)</h3>
  <p>
    Similar to RESTRICT, but constraint check happens at end of transaction.
  </p>

  <pre>
-- If child exists, deletion is blocked at commit time.
  </pre>

  <hr>

  <h3>📌 Summary Table</h3>

  <table>
    <tr>
      <th>Action</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td>CASCADE</td>
      <td>Child rows auto-deleted/updated</td>
    </tr>
    <tr>
      <td>SET NULL</td>
      <td>Child FK becomes NULL</td>
    </tr>
    <tr>
      <td>SET DEFAULT</td>
      <td>Child FK gets its default value</td>
    </tr>
    <tr>
      <td>RESTRICT</td>
      <td>Stops parent deletion if child exists (immediate check)</td>
    </tr>
    <tr>
      <td>NO ACTION</td>
      <td>Stops parent deletion (checked at end of transaction)</td>
    </tr>
  </table>

  <hr>

  <h3>🎯 Best Practices</h3>
  <ul>
    <li>Use <b>CASCADE</b> when child rows depend entirely on parent.</li>
    <li>Use <b>SET NULL</b> when child should survive independently.</li>
    <li>Use <b>RESTRICT</b> to prevent accidental deletion of important data.</li>
    <li>Use <b>SET DEFAULT</b> only when default makes logical sense.</li>
  </ul>
</section>

<hr>

<section id="keys-concepts">
  <h2>🔑 Keys in Relational Databases</h2>
  <p>
    Keys help uniquely identify rows and maintain consistency in relational databases.  
    Below are all important keys you must know in PostgreSQL & SQL.
  </p>

  <hr>

  <h3>1️⃣ Candidate Key</h3>
  <p>
    A <b>candidate key</b> is a minimal set of attributes that can uniquely identify a record.  
    A table can have multiple candidate keys.
  </p>

  <h4>Example</h4>
  <pre>
STUDENT
---------------------------------------
roll_no (unique)
email   (unique)
phone   (unique)

Candidate keys → roll_no, email, phone
  </pre>

  <p>All qualified to become PRIMARY KEY, but only one is chosen.</p>

  <hr>

  <h3>2️⃣ Composite Key</h3>
  <p>
    A <b>composite key</b> is a key made of <b>two or more columns</b> used together to uniquely identify a row.
  </p>

  <h4>Example</h4>
  <pre>
ENROLLMENT(student_id, course_id, date)

Composite key → (student_id, course_id)
  </pre>

  <p>No single column uniquely identifies a row — but both together do.</p>

  <hr>

  <h3>3️⃣ Super Key</h3>
  <p>
    A <b>super key</b> is any set of attributes that uniquely identifies a row.  
    It can contain extra/unnecessary attributes.
  </p>

  <h4>Example</h4>
  <pre>
Candidate keys:
    roll_no
    email

Super keys:
    roll_no
    email
    (roll_no, name)
    (email, phone)
  </pre>

  <p>👉 A candidate key is a <b>minimal super key</b>.</p>

  <hr>

  <h3>4️⃣ Alternative Key</h3>
  <p>
    All candidate keys except the one chosen as PRIMARY KEY are called <b>alternative keys</b>.
  </p>

  <h4>Example</h4>
  <pre>
Candidate keys: roll_no, email, phone
PRIMARY KEY = roll_no

Alternative keys → email, phone
  </pre>

  <hr>

  <h3>5️⃣ Unique Key</h3>
  <p>
    A <b>unique key</b> ensures all values in a column are unique.  
    Unlike PRIMARY KEY:
  </p>
  <ul>
    <li>Unique key allows <b>NULL values</b>.</li>
    <li>Table can have many UNIQUE constraints.</li>
  </ul>

  <h4>Syntax</h4>
  <pre>
CREATE TABLE users (
    email TEXT UNIQUE,
    phone TEXT UNIQUE
);
  </pre>

  <hr>

  <h3>6️⃣ Referential Integrity (Foreign Key)</h3>
  <p>
    Referential integrity ensures the relationship between two tables remains valid using a <b>FOREIGN KEY</b>.
  </p>

  <h4>Example</h4>
  <pre>
CREATE TABLE department (
    id INT PRIMARY KEY,
    name TEXT
);

CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    dept_id INT REFERENCES department(id)
);
  </pre>

  <p>
    dept_id must exist in department(id).  
    Prevents inserting invalid data and maintains consistency.
  </p>

  <h4>Referential Actions</h4>
  <ul>
    <li>ON DELETE CASCADE</li>
    <li>ON UPDATE CASCADE</li>
    <li>ON DELETE SET NULL</li>
    <li>ON UPDATE SET DEFAULT</li>
    <li>RESTRICT</li>
    <li>NO ACTION (default)</li>
  </ul>

  <a href="#referential-integrity">Click here for full detailed explanation →</a>

  <hr>

  <h3>📌 Summary Table</h3>

  <table>
    <tr>
      <th>Key Type</th>
      <th>Description</th>
    </tr>

    <tr>
      <td>Candidate Key</td>
      <td>Minimal attributes that uniquely identify a record</td>
    </tr>

    <tr>
      <td>Composite Key</td>
      <td>Key made of multiple columns</td>
    </tr>

    <tr>
      <td>Super Key</td>
      <td>Any attributes that uniquely identify a record</td>
    </tr>

    <tr>
      <td>Alternative Key</td>
      <td>Candidate keys that are not primary key</td>
    </tr>

    <tr>
      <td>Unique Key</td>
      <td>Ensures all values are unique (allows NULL)</td>
    </tr>

    <tr>
      <td>Referential Integrity</td>
      <td>Maintains parent-child consistency using foreign keys</td>
    </tr>
  </table>

</section>

<hr>

<section id="tcl">
  <h2>🔹 TCL (Transaction Control Language)</h2>

  <p>
    TCL is used to manage <b>transactions</b> in a database.  
    A transaction is a group of SQL statements that are executed as a single unit.
  </p>

  <p><b>ACID Properties:</b></p>
  <ul>
    <li><b>A</b>tomicity – all or nothing</li>
    <li><b>C</b>onsistency – database moves from one valid state to another</li>
    <li><b>I</b>solation – transactions do not affect each other</li>
    <li><b>D</b>urability – once committed, data is permanent</li>
  </ul>

  <hr>

  <!-- BEGIN / START TRANSACTION -->
  <h3>1️⃣ BEGIN / START TRANSACTION</h3>
  <p>Starts a new transaction.</p>

  <pre>
BEGIN;
-- or
START TRANSACTION;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts
SET balance = balance - 1000
WHERE id = 1;

UPDATE accounts
SET balance = balance + 1000
WHERE id = 2;

-- Decide later: COMMIT or ROLLBACK
  </pre>

  <hr>

  <!-- COMMIT -->
  <h3>2️⃣ COMMIT</h3>
  <p>
    Saves all changes made in the current transaction permanently to the database.
  </p>

  <pre>
COMMIT;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

COMMIT;   -- Money transfer is successful
  </pre>

  <hr>

  <!-- ROLLBACK -->
  <h3>3️⃣ ROLLBACK</h3>
  <p>
    Cancels all changes made in the current transaction and restores data to the previous committed state.
  </p>

  <pre>
ROLLBACK;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

-- Something went wrong
ROLLBACK;   -- All updates are undone
  </pre>

  <hr>

  <!-- SAVEPOINT -->
  <h3>4️⃣ SAVEPOINT</h3>
  <p>
    SAVEPOINT creates a <b>checkpoint</b> inside a transaction.  
    You can rollback only up to that point instead of full transaction.
  </p>

  <pre>
SAVEPOINT savepoint_name;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
SAVEPOINT sp1;

UPDATE accounts SET balance = balance + 1000 WHERE id = 2;
UPDATE accounts SET balance = balance + 500 WHERE id = 3;

-- Mistake in second part
ROLLBACK TO SAVEPOINT sp1;  -- Undo changes after sp1

COMMIT; -- First update (id=1) remains
  </pre>

  <hr>

  <!-- ROLLBACK TO SAVEPOINT -->
  <h3>5️⃣ ROLLBACK TO SAVEPOINT</h3>
  <p>Undo changes done after a specific savepoint, but keep earlier changes.</p>

  <pre>
ROLLBACK TO SAVEPOINT sp1;
  </pre>

  <hr>

  <!-- RELEASE SAVEPOINT -->
  <h3>6️⃣ RELEASE SAVEPOINT</h3>
  <p>Removes a savepoint (cannot ROLLBACK to it after release).</p>

  <pre>
RELEASE SAVEPOINT sp1;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
SAVEPOINT sp1;

UPDATE accounts SET balance = balance + 100 WHERE id = 2;

RELEASE SAVEPOINT sp1;

COMMIT;
  </pre>

  <hr>

  <!-- SET TRANSACTION -->
  <h3>7️⃣ SET TRANSACTION</h3>
  <p>Sets properties for the current transaction like isolation level, read/write mode.</p>

  <pre>
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION READ ONLY;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- Safe, fully isolated transaction
UPDATE accounts SET balance = balance - 200 WHERE id = 1;

COMMIT;
  </pre>

  <hr>

  <!-- AUTOCOMMIT -->
  <h3>8️⃣ Auto-Commit in PostgreSQL (psql)</h3>
  <p>
    In <b>psql</b>, every statement is automatically committed by default.  
    To use transactions, you must explicitly write:
  </p>

  <pre>
BEGIN;
-- your queries here
COMMIT;
-- or
ROLLBACK;
  </pre>

  <p>You can also turn off autocommit in some GUI tools (like DBeaver, pgAdmin) to control transactions manually.</p>

</section>

<hr>

<section id="dcl">
  <h2>🔹 DCL (Data Control Language)</h2>

  <p>
    DCL is used to control access and permissions on database objects such as tables, schemas, views, and sequences.
    It helps maintain database security.
  </p>

  <hr>

  <!-- GRANT -->
  <h3>1️⃣ GRANT</h3>
  <p>
    <b>GRANT</b> gives permissions to users or roles.
  </p>

  <h4>Syntax:</h4>
  <pre>
GRANT privilege_list
ON object_name
TO user_or_role;
  </pre>

  <h4>Example: Give SELECT to a user</h4>
  <pre>
GRANT SELECT ON employees TO user1;
  </pre>

  <h4>Example: Give multiple permissions</h4>
  <pre>
GRANT SELECT, INSERT, UPDATE
ON employees
TO hr_team;
  </pre>

  <h4>Example: Grant all privileges</h4>
  <pre>
GRANT ALL PRIVILEGES ON employees TO admin_user;
  </pre>

  <hr>

  <!-- Privilege Types -->
  <h3>2️⃣ Common Privileges in PostgreSQL</h3>

  <ul>
    <li><b>SELECT</b> – read rows</li>
    <li><b>INSERT</b> – insert rows</li>
    <li><b>UPDATE</b> – update rows</li>
    <li><b>DELETE</b> – delete rows</li>
    <li><b>TRUNCATE</b> – truncate table</li>
    <li><b>REFERENCES</b> – create foreign keys</li>
    <li><b>TRIGGER</b> – create triggers</li>
    <li><b>USAGE</b> – use sequences, languages</li>
    <li><b>EXECUTE</b> – run functions</li>
    <li><b>CREATE</b> – create objects in schema</li>
  </ul>

  <p><b>Note:</b> Permissions differ for tables, schemas, sequences, functions, etc.</p>

  <hr>

  <!-- WITH GRANT OPTION -->
  <h3>3️⃣ WITH GRANT OPTION</h3>
  <p>
    Allows the user to <b>give the same privilege to others</b>.
  </p>

  <h4>Example:</h4>
  <pre>
GRANT SELECT ON employees TO manager WITH GRANT OPTION;
  </pre>

  <p>manager can now grant SELECT to others.</p>

  <hr>

  <!-- REVOKE -->
  <h3>4️⃣ REVOKE</h3>
  <p>
    <b>REVOKE</b> removes permissions previously granted.
  </p>

  <h4>Syntax:</h4>
  <pre>
REVOKE privilege_list
ON object_name
FROM user_or_role;
  </pre>

  <h4>Example: Remove SELECT from user</h4>
  <pre>
REVOKE SELECT ON employees FROM user1;
  </pre>

  <h4>Example: Remove all privileges</h4>
  <pre>
REVOKE ALL PRIVILEGES ON employees FROM hr_team;
  </pre>

  <hr>

  <!-- COLUMN LEVEL -->
  <h3>5️⃣ Column-level Privileges</h3>

  <pre>
GRANT SELECT (name, salary)
ON employees
TO auditor;
  </pre>

  <pre>
REVOKE UPDATE (salary)
ON employees
FROM hr_intern;
  </pre>

  <hr>

  <!-- SCHEMA LEVEL -->
  <h3>6️⃣ Schema-level Permissions</h3>
  <p>
    Schema privileges control access to create objects inside a schema.
  </p>

  <pre>
GRANT USAGE ON SCHEMA public TO user1;
GRANT CREATE ON SCHEMA hr TO developer;
  </pre>

  <hr>

  <!-- SEQUENCE -->
  <h3>7️⃣ Sequence Privileges</h3>

  <pre>
GRANT USAGE, SELECT, UPDATE
ON SEQUENCE emp_id_seq
TO app_user;
  </pre>

  <hr>

  <!-- CREATE ROLE -->
  <h3>8️⃣ Roles (User Groups)</h3>

  <pre>
CREATE ROLE hr_team;
GRANT hr_team TO user1;  -- adds user1 to hr_team
  </pre>

  <p>
    Roles can hold permissions, making it easy to manage groups.
  </p>

  <hr>

  <!-- ROLE INHERITANCE -->
  <h3>9️⃣ Role Inheritance</h3>

  <p>
    By default, roles inherit permissions from the roles they belong to.
  </p>

  <h4>Example:</h4>
  <pre>
CREATE ROLE manager;
GRANT SELECT, UPDATE ON employees TO manager;

GRANT manager TO user1;
-- user1 now has SELECT & UPDATE privileges
  </pre>

  <hr>

  <!-- REMOVE ROLE -->
  <h3>🔟 Removing Role</h3>

  <pre>
DROP ROLE hr_team;
  </pre>

  <hr>

  <!-- Summary -->
  <h3>📌 Summary Table</h3>

  <table>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>

    <tr>
      <td>GRANT</td>
      <td>Give permissions to user or role</td>
    </tr>

    <tr>
      <td>REVOKE</td>
      <td>Remove permissions</td>
    </tr>

    <tr>
      <td>WITH GRANT OPTION</td>
      <td>User can re-grant permissions to others</td>
    </tr>

    <tr>
      <td>ROLE</td>
      <td>Group of users with same privileges</td>
    </tr>

    <tr>
      <td>USAGE</td>
      <td>Allows using sequences/languages/schemas</td>
    </tr>

    <tr>
      <td>EXECUTE</td>
      <td>Execute functions</td>
    </tr>
  </table>

</section>

<hr>

<div class="section">
    <h2>Performance Tuning (EXPLAIN, ANALYZE, VACUUM)</h2>

    <!-- EXPLAIN -->
    <h3>1. EXPLAIN</h3>
    <p><b>EXPLAIN</b> is used to see how PostgreSQL <b>will execute</b> a query.  
       It shows the <b>query plan</b> but does not run the query.</p>

    <h4>Why use EXPLAIN?</h4>
    <ul>
        <li>Check if query uses <b>index</b> or <b>sequential scan</b></li>
        <li>Identify slow operations</li>
        <li>Improve performance before running the query</li>
    </ul>

    <h4>Syntax:</h4>
    <pre>
EXPLAIN SELECT * FROM employees WHERE id = 10;
    </pre>

    <h4>Output Example:</h4>
    <pre>
Seq Scan on employees  (cost=0.00..12.50 rows=1 width=100)
  Filter: (id = 10)
    </pre>

    <!-- EXPLAIN ANALYZE -->
    <h3>2. EXPLAIN ANALYZE</h3>
    <p><b>EXPLAIN ANALYZE</b> runs the query and shows both the <b>plan + actual execution time</b>.</p>

    <h4>Why use EXPLAIN ANALYZE?</h4>
    <ul>
        <li>Shows real performance timings</li>
        <li>Compare estimated vs actual time</li>
        <li>Detect slow parts of query</li>
    </ul>

    <h4>Syntax:</h4>
    <pre>
EXPLAIN ANALYZE SELECT * FROM employees WHERE id = 10;
    </pre>

    <h4>Output Example:</h4>
    <pre>
Seq Scan on employees (actual time=0.040..0.080 rows=1 loops=1)
  Filter: (id = 10)
Planning Time: 0.20 ms
Execution Time: 0.10 ms
    </pre>

    <!-- VACUUM -->
    <h3>3. VACUUM</h3>
    <p><b>VACUUM</b> removes dead rows created by UPDATE and DELETE, reduces table size, and improves performance.</p>

    <h4>VACUUM Types:</h4>
    <ul>
        <li><b>VACUUM</b> – non-blocking background cleanup</li>
        <li><b>VACUUM FULL</b> – frees max space but <b>locks table</b></li>
    </ul>

    <h4>Syntax:</h4>
    <pre>
VACUUM employees;
VACUUM FULL employees;
    </pre>

    <!-- ANALYZE -->
    <h3>4. ANALYZE</h3>
    <p><b>ANALYZE</b> updates statistics so PostgreSQL can make better query plans.</p>

    <h4>Syntax:</h4>
    <pre>
ANALYZE employees;
    </pre>

    <h4>Combined Command:</h4>
    <pre>
VACUUM ANALYZE employees;
    </pre>

    <!-- Summary -->
    <h3>Summary Table</h3>
    <table  cellpadding="8">
        <tr>
            <th>Command</th>
            <th>Purpose</th>
            <th>Runs Query?</th>
            <th>Use Case</th>
        </tr>
        <tr>
            <td><b>EXPLAIN</b></td>
            <td>Shows query plan</td>
            <td>No</td>
            <td>Check how query will run</td>
        </tr>
        <tr>
            <td><b>EXPLAIN ANALYZE</b></td>
            <td>Plan + actual execution time</td>
            <td>Yes</td>
            <td>Find slow operations</td>
        </tr>
        <tr>
            <td><b>VACUUM</b></td>
            <td>Remove dead rows</td>
            <td>No</td>
            <td>Improve space & speed</td>
        </tr>
        <tr>
            <td><b>VACUUM FULL</b></td>
            <td>Rebuild table</td>
            <td>No</td>
            <td>Maximum cleanup (locks table)</td>
        </tr>
        <tr>
            <td><b>ANALYZE</b></td>
            <td>Update statistics</td>
            <td>No</td>
            <td>Better query planning</td>
        </tr>
    </table>
</div>

<hr>

<div class="section">
    <h2>Indexes in PostgreSQL</h2>

    <p>An <b>index</b> improves search performance by allowing PostgreSQL to quickly locate rows
    without scanning the entire table.</p>

    <h3>Why indexes?</h3>
    <ul>
        <li>Speed up SELECT queries</li>
        <li>Useful for large tables</li>
        <li>Improve JOIN performance</li>
        <li>Useful in WHERE, ORDER BY, GROUP BY</li>
    </ul>

    <h3>General Syntax</h3>
    <pre>
CREATE INDEX index_name ON table_name(column_name);
DROP INDEX index_name;
    </pre>

    <hr>

    <!-- B-Tree Index -->
    <h3>1. B-Tree Index (Default)</h3>
    <p>This is the <b>default index type</b> in PostgreSQL.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Equality (=)</li>
        <li>Inequality (&lt;, &gt;, &lt;=, &gt;=)</li>
        <li>Sorting (ORDER BY)</li>
        <li>Range searches (BETWEEN)</li>
        <li>Most common cases</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_emp_salary ON employees(salary);
    </pre>

    <hr>

    <!-- Hash Index -->
    <h3>2. Hash Index</h3>
    <p>Optimized only for <b>equality (=)</b> comparisons.</p>

    <h4>Best For:</h4>
    <ul>
        <li>WHERE column = value</li>
        <li>Fast exact match lookups</li>
    </ul>

    <p><b>Not good for:</b> range queries, ordering</p>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_emp_email_hash ON employees USING hash(email);
    </pre>

    <hr>

    <!-- GIN Index -->
    <h3>3. GIN Index (Generalized Inverted Index)</h3>
    <p>Used for indexing complex data types.</p>

    <h4>Best For:</h4>
    <ul>
        <li>JSONB</li>
        <li>Arrays</li>
        <li>Full-text search</li>
        <li>hstore</li>
        <li>Multiple values in a single column</li>
    </ul>

    <h4>Example (JSONB):</h4>
    <pre>
CREATE INDEX idx_data_json_gin ON logs USING gin(data);
    </pre>

    <h4>Example (Array):</h4>
    <pre>
CREATE INDEX idx_tags_gin ON posts USING gin(tags);
    </pre>

    <hr>

    <!-- GiST Index -->
    <h3>4. GiST Index (Generalized Search Tree)</h3>
    <p>Supports custom indexing for complex data types.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Geometric data (PostGIS)</li>
        <li>Ranges</li>
        <li>Fuzzy search</li>
        <li>Similarity search</li>
        <li>Full-text search (alternative to GIN)</li>
    </ul>

    <h4>Example (range type):</h4>
    <pre>
CREATE INDEX idx_numrange_gist ON items USING gist(price_range);
    </pre>

    <hr>

    <!-- BRIN Index -->
    <h3>5. BRIN Index (Block Range Index)</h3>
    <p>Very small index size and good for very large tables that are <b>naturally ordered</b>.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Timestamp columns (inserted in order)</li>
        <li>Auto-increment ID columns</li>
        <li>Large log or event tables</li>
        <li>Tables with millions/billions of rows</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_log_time_brin ON logs USING brin(created_at);
    </pre>

    <hr>

    <!-- Full Text Search Index -->
    <h3>6. Full-Text Search Index (GIN/GiST)</h3>
    <p>Used for text searching with <b>to_tsvector</b> and <b>to_tsquery</b>.</p>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_article_search 
ON articles USING gin(to_tsvector('english', content));
    </pre>

    <hr>

    <!-- Expression Index -->
    <h3>7. Expression Index</h3>
    <p>Index based on an expression, not a raw column.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Lowercase search</li>
        <li>Computed expressions</li>
        <li>Partial transformations</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_lower_email ON users (LOWER(email));
    </pre>

    <hr>

    <!-- Partial Index -->
    <h3>8. Partial Index</h3>
    <p>Index created on only a part of the table.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Frequently filtered subset</li>
        <li>Active users, recent records, non-null values</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_active_users 
ON users(status) WHERE status = 'active';
    </pre>

    <hr>

    <!-- Unique Index -->
    <h3>9. Unique Index</h3>
    <p>Ensures that no two rows have the same value.</p>

    <h4>Example:</h4>
    <pre>
CREATE UNIQUE INDEX idx_unique_email ON users(email);
    </pre>

    <hr>

    <!-- Covering Index -->
    <h3>10. Covering Index (INCLUDE)</h3>
    <p>Index stores extra columns so PostgreSQL can answer queries <b>without reading table</b>.</p>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_orders_covering 
ON orders(customer_id) INCLUDE(order_date, amount);
    </pre>

    <hr>

    <h3>Summary Table</h3>
    <table  cellpadding="8">
        <tr>
            <th>Index Type</th>
            <th>Best Use Case</th>
            <th>Supports</th>
        </tr>
        <tr>
            <td><b>B-Tree</b></td>
            <td>General-purpose, ranges, sorting</td>
            <td>=, <, >, BETWEEN, ORDER BY</td>
        </tr>
        <tr>
            <td><b>Hash</b></td>
            <td>Exact match</td>
            <td>= only</td>
        </tr>
        <tr>
            <td><b>GIN</b></td>
            <td>JSONB, arrays, FTS</td>
            <td>Multiple values, key→value lookup</td>
        </tr>
        <tr>
            <td><b>GiST</b></td>
            <td>Geometric, fuzzy, ranges</td>
            <td>Custom operators</td>
        </tr>
        <tr>
            <td><b>BRIN</b></td>
            <td>Very large sequential tables</td>
            <td>Block ranges</td>
        </tr>
        <tr>
            <td><b>Expression Index</b></td>
            <td>On expressions</td>
            <td>Computed values</td>
        </tr>
        <tr>
            <td><b>Partial Index</b></td>
            <td>Filtered data</td>
            <td>Conditional WHERE</td>
        </tr>
        <tr>
            <td><b>Covering Index</b></td>
            <td>Speed up SELECT</td>
            <td>INCLUDE extra columns</td>
        </tr>
    </table>
</div>

<hr>

<div class="section">

    <h2>Views in PostgreSQL</h2>

    <p>A <b>VIEW</b> is a virtual table based on a query.  
    It does not store data physically (except materialized views).  
    It helps simplify complex queries and improve security.</p>

    <h3>Why use Views?</h3>
    <ul>
        <li>Hide complex SQL logic</li>
        <li>Improve security (restrict access to specific columns)</li>
        <li>Reusable SQL queries</li>
        <li>Reduce code duplication</li>
    </ul>

    <hr>

    <!-- Create View -->
    <h3>1. CREATE VIEW</h3>
    <p>Creates a virtual table from a SELECT query.</p>

    <h4>Syntax</h4>
    <pre>
CREATE VIEW view_name AS
SELECT columns
FROM table
WHERE condition;
    </pre>

    <h4>Example</h4>
    <pre>
CREATE VIEW high_salary_emps AS
SELECT name, salary
FROM employees
WHERE salary > 50000;
    </pre>

    <hr>

    <!-- Using a View -->
    <h3>2. Using a View</h3>
    <pre>
SELECT * FROM high_salary_emps;
    </pre>

    <hr>

    <!-- Replace View -->
    <h3>3. CREATE OR REPLACE VIEW</h3>
    <p>Updates a view without dropping it.</p>

    <pre>
CREATE OR REPLACE VIEW high_salary_emps AS
SELECT name, salary, department
FROM employees
WHERE salary > 50000;
    </pre>

    <hr>

    <!-- Update View -->
    <h3>4. Updatable Views</h3>
    <p>A view is <b>updatable</b> if it is based on:</p>
    <ul>
        <li>Single table</li>
        <li>No aggregate functions</li>
        <li>No GROUP BY, ORDER BY</li>
        <li>No DISTINCT</li>
    </ul>

    <h4>Example</h4>
    <pre>
UPDATE high_salary_emps
SET salary = 70000
WHERE name = 'John';
    </pre>

    <hr>

    <!-- Check Option -->
    <h3>5. WITH CHECK OPTION</h3>
    <p>Prevents inserting/updating rows that do not match view condition.</p>

    <h4>Example</h4>
    <pre>
CREATE VIEW sales_team AS
SELECT * FROM employees
WHERE department = 'Sales'
WITH CHECK OPTION;
    </pre>

    <p><b>This prevents:</b></p>
    <pre>
INSERT INTO sales_team (name, department)
VALUES ('Alex', 'HR');   -- ❌ Not allowed
    </pre>

    <hr>

    <!-- Drop View -->
    <h3>6. DROP VIEW</h3>
    <pre>
DROP VIEW sales_team;
DROP VIEW IF EXISTS sales_team;
    </pre>

    <hr>

    <!-- Materialized View -->
    <h3>7. Materialized View</h3>
    <p>A <b>materialized view</b> stores data physically.  
    Faster for large queries but must be refreshed.</p>

    <h4>Create Materialized View</h4>
    <pre>
CREATE MATERIALIZED VIEW sales_summary AS
SELECT department, SUM(amount) AS total_sales
FROM sales
GROUP BY department;
    </pre>

    <h4>Refresh Materialized View</h4>
    <pre>
REFRESH MATERIALIZED VIEW sales_summary;
    </pre>

    <h4>Refresh without locking</h4>
    <pre>
REFRESH MATERIALIZED VIEW CONCURRENTLY sales_summary;
    </pre>

    <p>(Requires a unique index on the MV)</p>

    <hr>

    <!-- View vs Materialized View -->
    <h3>8. View vs Materialized View</h3>

    <table  cellpadding="8">
        <tr>
            <th>Feature</th>
            <th>View</th>
            <th>Materialized View</th>
        </tr>
        <tr>
            <td>Stores Data</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Speed</td>
            <td>Slower (runs query every time)</td>
            <td>Faster for repeated reads</td>
        </tr>
        <tr>
            <td>Refresh Needed?</td>
            <td>No</td>
            <td>Yes (REFRESH MATERIALIZED VIEW)</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Simplify queries</td>
            <td>Store precomputed results</td>
        </tr>
    </table>

</div>

<hr>

<div class="section">

    <h2>CTE (WITH Clause)</h2>

    <p>A <b>CTE (Common Table Expression)</b> is a temporary result set 
    defined using the <b>WITH</b> keyword.  
    It makes queries cleaner and reusable inside a SELECT.</p>

    <h3>Syntax</h3>
    <pre>
WITH cte_name AS (
    SELECT ...
)
SELECT * FROM cte_name;
    </pre>

    <h3>Example</h3>
    <pre>
WITH high_salary AS (
    SELECT name, salary
    FROM employees
    WHERE salary > 50000
)
SELECT * FROM high_salary;
    </pre>

    <hr>

    <h2>Recursive CTE</h2>

    <p>Recursive queries are used for hierarchical or tree-structured data
    (employees, categories, parent-child relationships).</p>

    <h3>Syntax</h3>
    <pre>
WITH RECURSIVE cte_name AS (
    -- Anchor part
    SELECT ...

    UNION ALL

    -- Recursive part
    SELECT ...
    FROM cte_name
)
SELECT * FROM cte_name;
    </pre>

    <h3>Example: Employee Hierarchy</h3>
    <pre>
WITH RECURSIVE emp_tree AS (
    -- anchor member
    SELECT id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- recursive member
    SELECT e.id, e.name, e.manager_id, t.level + 1
    FROM employees e
    INNER JOIN emp_tree t ON e.manager_id = t.id
)
SELECT * FROM emp_tree;
    </pre>

    <hr>

    <h2>JSON Data Type</h2>

    <p>PostgreSQL supports two JSON types:</p>
    <ul>
        <li><b>json</b> – stored as plain text</li>
        <li><b>jsonb</b> – stored in binary form (faster for search)</li>
    </ul>

    <h3>Create JSON Column</h3>
    <pre>
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    details JSONB
);
    </pre>

    <h3>Insert JSON</h3>
    <pre>
INSERT INTO products(details) VALUES (
    '{"name": "Laptop", "price": 50000, "specs": {"ram": "16GB"}}'
);
    </pre>

    <h3>Extract JSON Fields</h3>

    <ul>
        <li><b>-></b> returns JSON object</li>
        <li><b>->></b> returns text value</li>
    </ul>

    <pre>
SELECT details->'name'        FROM products;  -- JSON
SELECT details->>'name'       FROM products;  -- TEXT
SELECT details->'specs'->>'ram' FROM products;
    </pre>

    <hr>

    <h3>Search Inside JSONB</h3>
    <pre>
SELECT * FROM products
WHERE details @> '{"name": "Laptop"}';
    </pre>

    <p><b>@></b> checks if JSON contains another JSON.</p>

    <hr>

    <h3>jsonb_set (update JSON)</h3>
    <pre>
UPDATE products
SET details = jsonb_set(details, '{price}', '55000');
    </pre>

    <hr>

    <h3>jsonb_array_elements()</h3>

    <pre>
SELECT jsonb_array_elements('["red", "blue", "green"]'::jsonb);
    </pre>

    <hr>

    <h2>Arrays in PostgreSQL</h2>

    <p>PostgreSQL supports <b>multi-value arrays</b> inside a column.</p>

    <h3>Create Array Column</h3>
    <pre>
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    subjects TEXT[]
);
    </pre>

    <h3>Insert Array</h3>
    <pre>
INSERT INTO students(subjects)
VALUES ('{math,science,english}');
    </pre>

    <h3>Select Array Values</h3>
    <pre>
SELECT subjects[1] FROM students;     -- first element
SELECT subjects FROM students;
    </pre>

    <hr>

    <h3>Array Functions</h3>

    <h4>1. array_length()</h4>
    <pre>
SELECT array_length('{1,2,3,4}'::int[], 1);  -- output: 4
    </pre>

    <h4>2. array_append()</h4>
    <pre>
SELECT array_append('{1,2,3}'::int[], 4);  -- {1,2,3,4}
    </pre>

    <h4>3. array_remove()</h4>
    <pre>
SELECT array_remove('{1,2,3,2}'::int[], 2);  -- {1,3}
    </pre>

    <h4>4. array_cat()</h4>
    <pre>
SELECT array_cat('{a,b}'::text[], '{c,d}'::text[]);  
-- {a,b,c,d}
    </pre>

    <h4>5. ANY & ALL operators</h4>
    <pre>
SELECT 3 = ANY('{1,2,3}'::int[]);  -- true
SELECT 3 > ALL('{1,2}'::int[]);    -- true
    </pre>

    <hr>

    <h2>JSON vs Array</h2>

    <table  cellpadding="8">
        <tr>
            <th>Feature</th>
            <th>JSON</th>
            <th>Array</th>
        </tr>
        <tr>
            <td>Structure</td>
            <td>Key–value</td>
            <td>List of values</td>
        </tr>
        <tr>
            <td>Flexibility</td>
            <td>High (nested)</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Best Use</td>
            <td>Semi-structured data</td>
            <td>Ordered lists</td>
        </tr>
    </table>

</div>


<hr>

<h1>PostgreSQL SEQUENCES</h1>

<p>A sequence is a database object that generates unique numbers. Mostly used for primary keys.</p>

<hr>

<h2>1. CREATE SEQUENCE</h2>

<h3>Syntax:</h3>
<pre>
CREATE SEQUENCE sequence_name
START WITH start_value
INCREMENT BY step_value
MINVALUE min_value
MAXVALUE max_value
CACHE cache_value
CYCLE | NO CYCLE
OWNED BY table.column;   -- optional
</pre>

<h3>Example:</h3>
<pre>
CREATE SEQUENCE emp_seq
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 99999
CACHE 1
NO CYCLE;
</pre>

<hr>

<h2>2. USING THE SEQUENCE</h2>

<p>Use <b>nextval()</b> to get next number:</p>
<pre>
INSERT INTO employee(id, name)
VALUES (nextval('emp_seq'), 'Aathi');
</pre>

<hr>

<h2>3. SEQUENCE FUNCTIONS</h2>

<table  cellpadding="8">
<tr><th>Function</th><th>Description</th></tr>
<tr><td>nextval('seq')</td><td>Get next value and increment the sequence</td></tr>
<tr><td>currval('seq')</td><td>Returns current value (after nextval is called)</td></tr>
<tr><td>setval('seq', value)</td><td>Set the sequence to a specific number</td></tr>
</table>

<h3>Examples:</h3>
<pre>
SELECT nextval('emp_seq');   -- 1
SELECT currval('emp_seq');   -- 1
SELECT setval('emp_seq', 50);
SELECT nextval('emp_seq');   -- 51
</pre>

<hr>

<h2>4. ALTER SEQUENCE</h2>

<p><b>Common Syntax:</b></p>
<pre>
ALTER SEQUENCE sequence_name
    INCREMENT BY value
    MINVALUE value
    MAXVALUE value
    START WITH value
    RESTART [WITH value]
    CACHE value
    CYCLE | NO CYCLE
    OWNED BY table.column | NONE;
</pre>

<h3>Examples:</h3>

<h4>Change increment:</h4>
<pre>
ALTER SEQUENCE emp_seq INCREMENT BY 5;
</pre>

<h4>Restart sequence:</h4>
<pre>
ALTER SEQUENCE emp_seq RESTART WITH 1;
</pre>

<h4>Change minimum/maximum:</h4>
<pre>
ALTER SEQUENCE emp_seq MINVALUE 10;
ALTER SEQUENCE emp_seq MAXVALUE 999999;
</pre>

<h4>Assign sequence ownership:</h4>
<pre>
ALTER SEQUENCE emp_seq OWNED BY employee.id;
</pre>

<h4>Remove ownership:</h4>
<pre>
ALTER SEQUENCE emp_seq OWNED BY NONE;
</pre>

<hr>

<h2>5. DROP SEQUENCE</h2>

<h3>Syntax:</h3>
<pre>
DROP SEQUENCE sequence_name;
</pre>

<h3>Example:</h3>
<pre>
DROP SEQUENCE emp_seq;
</pre>

<hr>

<h2>6. SET DEFAULT using Sequence</h2>

<p>Automatically fill column using sequence:</p>
<pre>
ALTER TABLE employee
ALTER COLUMN id SET DEFAULT nextval('emp_seq');
</pre>

<p>Now insert without ID:</p>
<pre>
INSERT INTO employee(name) VALUES ('John');
</pre>

<hr>

<h2>7. Sequence with Multiple Tables</h2>

<p>A single sequence can be used by many tables. All will share the same counter.</p>

<pre>
CREATE SEQUENCE global_seq START 1;
</pre>

<h3>Table 1:</h3>
<pre>
CREATE TABLE customer(
    cid INT DEFAULT nextval('global_seq'),
    name TEXT
);
</pre>

<h3>Table 2:</h3>
<pre>
CREATE TABLE orders(
    oid INT DEFAULT nextval('global_seq'),
    amount INT
);
</pre>

<h3>Inserts:</h3>
<pre>
INSERT INTO customer(name) VALUES ('Aathi');
INSERT INTO orders(amount) VALUES (500);
INSERT INTO customer(name) VALUES ('Kavi');
</pre>

<h3>Generated Values:</h3>
<pre>
customer -> 1
orders   -> 2
customer -> 3
</pre>

<hr>

<h2>8. Quick Revision Table</h2>

<table  cellpadding="8">
<tr><th>Command</th><th>Purpose</th></tr>
<tr><td>CREATE SEQUENCE</td><td>Create new counter object</td></tr>
<tr><td>ALTER SEQUENCE</td><td>Modify sequence properties</td></tr>
<tr><td>DROP SEQUENCE</td><td>Delete sequence</td></tr>
<tr><td>nextval()</td><td>Get next number</td></tr>
<tr><td>currval()</td><td>Current number</td></tr>
<tr><td>setval()</td><td>Set sequence number manually</td></tr>
<tr><td>OWNED BY</td><td>Attach sequence to table column</td></tr>
</table>

<hr>

<h1>PostgreSQL – Advanced Topics</h1>
<hr>

<!-- ========================================================= -->
<!--                    STORED FUNCTIONS                       -->
<!-- ========================================================= -->

<h2>1. Stored Functions</h2>
<p>A stored function returns a value and can be used inside SELECT.</p>

<h3>Syntax:</h3>
<pre>
CREATE OR REPLACE FUNCTION function_name(param datatype)
RETURNS return_type AS $$
BEGIN
    -- logic
    RETURN value;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION add_numbers(a INT, b INT)
RETURNS INT AS $$
BEGIN
    RETURN a + b;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Call Function:</h3>
<pre>
SELECT add_numbers(10, 20);
-- Output: 30
</pre>

<hr>

<!-- ========================================================= -->
<!--                    STORED PROCEDURES                      -->
<!-- ========================================================= -->

<h2>2. Stored Procedures</h2>
<p>Stored procedures do NOT return values. Called using CALL.</p>

<h3>Syntax:</h3>
<pre>
CREATE OR REPLACE PROCEDURE procedure_name(param datatype)
LANGUAGE plpgsql AS $$
BEGIN
    -- logic
END;
$$;
</pre>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE PROCEDURE insert_student(name TEXT, age INT)
LANGUAGE plpgsql AS $$
BEGIN
    INSERT INTO students(name, age) VALUES (name, age);
END;
$$;

CALL insert_student('Aathi', 22);
</pre>

<hr>

<!-- ========================================================= -->
<!--                          TRIGGERS                         -->
<!-- ========================================================= -->

<h2>3. Triggers</h2>
<p>Triggers execute automatically on INSERT, UPDATE, DELETE.</p>

<h3>Steps:</h3>
<ol>
<li>Create function</li>
<li>Create trigger</li>
</ol>

<h3>Trigger Function:</h3>
<pre>
CREATE OR REPLACE FUNCTION log_employee_changes()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO employee_log(emp_id, action_time)
    VALUES (NEW.id, NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Create Trigger:</h3>
<pre>
CREATE TRIGGER emp_after_insert
AFTER INSERT ON employee
FOR EACH ROW
EXECUTE FUNCTION log_employee_changes();
</pre>

<h3>Example Insert:</h3>
<pre>
INSERT INTO employee(id, name) VALUES (1, 'John');

-- Automatically inserts into employee_log
</pre>

<hr>

<!-- ========================================================= -->
<!--                          CURSOR                           -->
<!-- ========================================================= -->

<h2>4. Cursors</h2>
<p>Cursors allow row-by-row processing inside a function or procedure.</p>

<h3>Syntax:</h3>
<pre>
DECLARE cursor_name CURSOR FOR SELECT ...;
FETCH NEXT FROM cursor_name;
CLOSE cursor_name;
</pre>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION process_students()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur CURSOR FOR SELECT id, name FROM students;
BEGIN
    OPEN cur;
    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Student: %, %', rec.id, rec.name;
    END LOOP;
    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT process_students();
</pre>

<hr>

<!-- ========================================================= -->
<!--                 LOCKS & CONCURRENCY                       -->
<!-- ========================================================= -->

<h2>5. Locks & Concurrency</h2>
<p>PostgreSQL uses MVCC (Multi-Version Concurrency Control) for safe parallel operations.</p>

<h3>Types of Locks:</h3>

<table  cellpadding="8">
<tr><th>Lock Type</th><th>Description</th></tr>
<tr><td>ROW SHARE</td><td>Used for SELECT ... FOR SHARE</td></tr>
<tr><td>ROW EXCLUSIVE</td><td>INSERT, UPDATE, DELETE</td></tr>
<tr><td>SHARE</td><td>Blocks writes</td></tr>
<tr><td>SHARE ROW EXCLUSIVE</td><td>Heavier lock on table</td></tr>
<tr><td>EXCLUSIVE</td><td>No parallel reads or writes</td></tr>
<tr><td>ACCESS EXCLUSIVE</td><td>DROP/ALTER TABLE</td></tr>
</table>

<h3>Important Commands:</h3>

<h4>1. SELECT FOR UPDATE</h4>
<pre>
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
</pre>

<h4>2. SELECT FOR SHARE</h4>
<pre>
SELECT * FROM products WHERE id = 10 FOR SHARE;
</pre>

<h4>3. Deadlock Example</h4>
<pre>
-- Session 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Session 2
BEGIN;
UPDATE accounts SET balance = balance + 50 WHERE id = 2;
</pre>

<p>If both try to update each other's rows — a deadlock happens.</p>

<h4>Check current locks</h4>
<pre>
SELECT * FROM pg_locks;
</pre>

<h4>Check waiting queries</h4>
<pre>
SELECT * FROM pg_stat_activity WHERE wait_event IS NOT NULL;
</pre>

<hr>

<!-- ========================================================= -->
<!--                      QUICK REVISION                       -->
<!-- ========================================================= -->

<h2>6. Quick Revision Table</h2>

<table  cellpadding="8">
<tr><th>Feature</th><th>Purpose</th></tr>
<tr><td>Stored Function</td><td>Returns value, used in SELECT</td></tr>
<tr><td>Stored Procedure</td><td>No return, use CALL</td></tr>
<tr><td>Trigger</td><td>Auto execute on DML</td></tr>
<tr><td>Cursor</td><td>Row-by-row processing</td></tr>
<tr><td>Locks</td><td>Control multi-user access</td></tr>
</table>

<hr>

<h1>PostgreSQL – Cursors & Triggers</h1>
<hr>

<!-- ========================================================= -->
<!--                           CURSORS                          -->
<!-- ========================================================= -->

<h2>1. CURSORS</h2>
<p>Cursors allow row-by-row processing of a result set inside a PL/pgSQL block.</p>

<h3>Why Cursors?</h3>
<ul>
<li>Used when you must process rows one-by-one</li>
<li>Needed in loops (FOR, WHILE, LOOP)</li>
<li>Used for complex business logic</li>
<li>Used when you can't operate using normal SQL set-based operations</li>
</ul>

<hr>

<h2>Types of Cursors</h2>

<table  cellpadding="8">
<tr><th>Type</th><th>Description</th></tr>
<tr><td>Implicit Cursor</td><td>Used automatically in FOR loops</td></tr>
<tr><td>Explicit Cursor</td><td>Manually declared, opened, fetched, and closed</td></tr>
<tr><td>Bound Cursor</td><td>Cursor with parameters</td></tr>
<tr><td>Unbound Cursor</td><td>Cursor created without a predefined query</td></tr>
</table>

<hr>

<h2>1.1 Implicit Cursor (Simplest)</h2>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION print_students()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN SELECT id, name FROM students LOOP
        RAISE NOTICE 'ID: %, Name: %', rec.id, rec.name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT print_students();
</pre>

<hr>

<h2>1.2 Explicit Cursor</h2>

<h3>Syntax:</h3>
<pre>
DECLARE cursor_name CURSOR FOR SELECT ...;
OPEN cursor_name;
FETCH cursor_name INTO variable;
CLOSE cursor_name;
</pre>

<h3>Full Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION read_students()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur CURSOR FOR SELECT id, name FROM students ORDER BY id;
BEGIN
    OPEN cur;
    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Student: %, %', rec.id, rec.name;
    END LOOP;
    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT read_students();
</pre>

<hr>

<h2>1.3 Cursor WITH PARAMETERS (Bound Cursor)</h2>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION list_students(min_id INT)
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur CURSOR (x INT) FOR SELECT id, name FROM students WHERE id >= x;
BEGIN
    OPEN cur(min_id);
    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'ID: %, Name: %', rec.id, rec.name;
    END LOOP;
    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT list_students(5);
</pre>

<hr>

<h2>1.4 Unbound Cursor (Assign Query Later)</h2>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION dynamic_cursor()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur REFCURSOR;
BEGIN
    cur := 'mycursor';

    OPEN cur FOR SELECT id, name FROM students WHERE age > 20;

    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;
        RAISE NOTICE 'Student: %, %', rec.id, rec.name;
    END LOOP;

    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT dynamic_cursor();
</pre>

<hr>

<h2>1.5 Cursor Output</h2>
<pre>
NOTICE: Student: 1, John
NOTICE: Student: 2, Ram
NOTICE: Student: 3, Kavi
</pre>

<hr>

<!-- ========================================================= -->
<!--                           TRIGGERS                         -->
<!-- ========================================================= -->

<h1>2. TRIGGERS</h1>
<p>Triggers automatically execute a function when INSERT, UPDATE or DELETE happens.</p>

<h2>Steps to create a trigger</h2>

<ol>
<li>Create trigger function (must return NEW or OLD)</li>
<li>Create trigger and attach it to a table</li>
</ol>

<hr>

<h2>2.1 Types of Triggers</h2>

<table  cellpadding="8">
<tr><th>Type</th><th>Description</th></tr>
<tr><td>BEFORE INSERT</td><td>Validates / modifies data before inserting</td></tr>
<tr><td>AFTER INSERT</td><td>Logs data after insert</td></tr>
<tr><td>BEFORE UPDATE</td><td>Modify values before update</td></tr>
<tr><td>AFTER UPDATE</td><td>History/audit logs</td></tr>
<tr><td>BEFORE DELETE</td><td>Check conditions before deleting</td></tr>
<tr><td>AFTER DELETE</td><td>Log removed rows</td></tr>
<tr><td>INSTEAD OF</td><td>Used with views</td></tr>
</table>

<hr>

<h2>2.2 AFTER INSERT Trigger (Log New Rows)</h2>

<h3>Trigger Function</h3>
<pre>
CREATE OR REPLACE FUNCTION log_insert()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO employee_log(emp_id, name, inserted_at)
    VALUES (NEW.id, NEW.name, NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Create Trigger</h3>
<pre>
CREATE TRIGGER trg_after_insert
AFTER INSERT ON employee
FOR EACH ROW
EXECUTE FUNCTION log_insert();
</pre>

<h3>Insert Example:</h3>
<pre>
INSERT INTO employee(id, name) VALUES (1, 'Aathi');
</pre>

<h3>Output:</h3>
<pre>
employee_log table:
id | name  | inserted_at
1  | Aathi | 2025-01-20 10:20:00
</pre>

<hr>

<h2>2.3 BEFORE UPDATE Trigger (Modify Values)</h2>

<h3>Example: Auto-update modified date</h3>

<pre>
CREATE OR REPLACE FUNCTION update_modified()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_update
BEFORE UPDATE ON employee
FOR EACH ROW
EXECUTE FUNCTION update_modified();
</pre>

<hr>

<h2>2.4 BEFORE DELETE Trigger (Prevent Deletion)</h2>

<pre>
CREATE OR REPLACE FUNCTION prevent_delete()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Deletion not allowed!';
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_delete
BEFORE DELETE ON employee
FOR EACH ROW
EXECUTE FUNCTION prevent_delete();
</pre>

<hr>

<h2>2.5 AFTER DELETE Trigger (Audit)</h2>

<pre>
CREATE OR REPLACE FUNCTION log_delete()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO deleted_users(id, name, deleted_at)
    VALUES (OLD.id, OLD.name, NOW());
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_delete
AFTER DELETE ON employee
FOR EACH ROW
EXECUTE FUNCTION log_delete();
</pre>

<hr>

<h2>2.6 INSTEAD OF Trigger (For VIEWS)</h2>

<pre>
CREATE VIEW emp_names AS
SELECT id, name FROM employee;

CREATE OR REPLACE FUNCTION insert_view_fn()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO employee(id, name) VALUES (NEW.id, NEW.name);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_instead_insert
INSTEAD OF INSERT ON emp_names
FOR EACH ROW
EXECUTE FUNCTION insert_view_fn();
</pre>

<hr>

<h1>3. Quick Revision Table</h1>

<table  cellpadding="8">
<tr><th>Feature</th><th>Used For</th></tr>
<tr><td>Cursor</td><td>Row-by-row processing</td></tr>
<tr><td>Trigger</td><td>Auto actions on INSERT/UPDATE/DELETE</td></tr>
<tr><td>BEFORE</td><td>Validate or modify NEW data</td></tr>
<tr><td>AFTER</td><td>Logging, audit, history</td></tr>
<tr><td>INSTEAD OF</td><td>Triggers on views</td></tr>
</table>

<h1>PL/pgSQL – IF, LOOP, WHILE, CASE</h1>
<hr>

<!-- ========================================================= -->
<!--                          INTRO                             -->
<!-- ========================================================= -->

<p>PL/pgSQL is PostgreSQL’s procedural language used to write functions, triggers, loops, conditional logic, and more.</p>

<h2>Topics Covered</h2>
<ul>
<li>IF / ELSIF / ELSE</li>
<li>Simple IF</li>
<li>IF with expressions</li>
<li>LOOP / EXIT / CONTINUE</li>
<li>WHILE loop</li>
<li>FOR loops</li>
<li>CASE expressions</li>
</ul>

<hr>

<!-- ========================================================= -->
<!--                           IF STATEMENT                     -->
<!-- ========================================================= -->

<h1>1. IF Statements</h1>

<h3>Syntax:</h3>
<pre>
IF condition THEN
    statements;
ELSIF condition THEN
    statements;
ELSE
    statements;
END IF;
</pre>

<hr>

<h2>1.1 Simple IF</h2>
<pre>
CREATE OR REPLACE FUNCTION check_age(a INT)
RETURNS TEXT AS $$
BEGIN
    IF a >= 18 THEN
        RETURN 'Adult';
    END IF;

    RETURN 'Minor';
END;
$$ LANGUAGE plpgsql;

SELECT check_age(20);  -- Adult
</pre>

<hr>

<h2>1.2 IF – ELSIF – ELSE</h2>
<pre>
CREATE OR REPLACE FUNCTION grade(score INT)
RETURNS TEXT AS $$
BEGIN
    IF score >= 90 THEN
        RETURN 'A';
    ELSIF score >= 75 THEN
        RETURN 'B';
    ELSIF score >= 50 THEN
        RETURN 'C';
    ELSE
        RETURN 'Fail';
    END IF;
END;
$$ LANGUAGE plpgsql;

SELECT grade(80); -- B
</pre>

<hr>

<h2>1.3 Nested IF</h2>
<pre>
IF salary > 50000 THEN
    IF experience > 5 THEN
        RETURN 'Senior';
    END IF;
END IF;
</pre>

<hr>

<!-- ========================================================= -->
<!--                            LOOPS                           -->
<!-- ========================================================= -->

<h1>2. LOOP Statements</h1>
<p>LOOP creates an infinite loop until EXIT is used.</p>

<h3>Syntax:</h3>
<pre>
LOOP
    statements;
    EXIT WHEN condition;
END LOOP;
</pre>

<hr>

<h2>2.1 Basic LOOP Example</h2>
<pre>
CREATE OR REPLACE FUNCTION loop_demo()
RETURNS VOID AS $$
DECLARE
    i INT := 1;
BEGIN
    LOOP
        RAISE NOTICE 'i = %', i;
        i := i + 1;

        EXIT WHEN i > 5;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT loop_demo();
</pre>

<h3>Output:</h3>
<pre>
NOTICE: i = 1
NOTICE: i = 2
NOTICE: i = 3
NOTICE: i = 4
NOTICE: i = 5
</pre>

<hr>

<h2>2.2 CONTINUE</h2>
<pre>
LOOP
    i := i + 1;
    CONTINUE WHEN i = 3;
    RAISE NOTICE 'Value: %', i;
    EXIT WHEN i > 5;
END LOOP;
</pre>

<h3>Skips printing when i = 3</h3>

<hr>

<!-- ========================================================= -->
<!--                           WHILE LOOP                       -->
<!-- ========================================================= -->

<h1>3. WHILE Loop</h1>

<h3>Syntax:</h3>
<pre>
WHILE condition LOOP
    statements;
END LOOP;
</pre>

<hr>

<h2>Example:</h2>
<pre>
CREATE OR REPLACE FUNCTION while_demo()
RETURNS VOID AS $$
DECLARE
    x INT := 1;
BEGIN
    WHILE x <= 5 LOOP
        RAISE NOTICE 'x = %', x;
        x := x + 1;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT while_demo();
</pre>

<hr>

<!-- ========================================================= -->
<!--                            FOR LOOP                        -->
<!-- ========================================================= -->

<h1>4. FOR Loop</h1>

<p>PostgreSQL supports 3 types of FOR loops:</p>
<ul>
<li>Integer FOR loop</li>
<li>Reverse integer FOR loop</li>
<li>FOR-IN-SELECT loop</li>
</ul>

<hr>

<h2>4.1 Integer FOR Loop</h2>
<pre>
FOR i IN 1..5 LOOP
    RAISE NOTICE 'Number: %', i;
END LOOP;
</pre>

<hr>

<h2>4.2 Reverse Loop</h2>
<pre>
FOR i IN REVERSE 5..1 LOOP
    RAISE NOTICE 'i = %', i;
END LOOP;
</pre>

<hr>

<h2>4.3 FOR-IN-SELECT Loop</h2>
<pre>
FOR rec IN SELECT id, name FROM employees LOOP
    RAISE NOTICE 'Employee: %, %', rec.id, rec.name;
END LOOP;
</pre>

<hr>

<!-- ========================================================= -->
<!--                            CASE STATEMENT                  -->
<!-- ========================================================= -->

<h1>5. CASE Statement</h1>

<h2>5.1 Simple CASE</h2>
<pre>
CREATE OR REPLACE FUNCTION check_day(day INT)
RETURNS TEXT AS $$
BEGIN
    CASE day
        WHEN 1 THEN RETURN 'Monday';
        WHEN 2 THEN RETURN 'Tuesday';
        WHEN 3 THEN RETURN 'Wednesday';
        ELSE RETURN 'Unknown';
    END CASE;
END;
$$ LANGUAGE plpgsql;

SELECT check_day(2); -- Tuesday
</pre>

<hr>

<h2>5.2 Searched CASE</h2>
<pre>
CASE
    WHEN marks >= 90 THEN 'High'
    WHEN marks >= 60 THEN 'Medium'
    ELSE 'Low'
END
</pre>

<hr>

<h2>5.3 CASE inside SELECT</h2>
<pre>
SELECT name,
       CASE 
            WHEN salary > 50000 THEN 'High Salary'
            WHEN salary > 30000 THEN 'Medium Salary'
            ELSE 'Low Salary'
       END AS category
FROM employees;
</pre>

<hr>

<h1>Quick Revision Table</h1>

<table  cellpadding="7">
<tr><th>Feature</th><th>Use</th></tr>
<tr><td>IF / ELSIF</td><td>Conditional logic</td></tr>
<tr><td>LOOP</td><td>Infinite loop with EXIT</td></tr>
<tr><td>WHILE</td><td>Loop while condition true</td></tr>
<tr><td>FOR</td><td>Numeric range or SELECT loop</td></tr>
<tr><td>CASE</td><td>Multiple condition evaluation</td></tr>
</table>

<hr>

<section>
    <h2>Backup & Restore in PostgreSQL</h2>
    <p>PostgreSQL provides powerful tools for backing up and restoring databases using <code>pg_dump</code>, <code>pg_restore</code>, and <code>psql</code>. These tools support full, custom, table-level, and schema-level backups.</p>

    <h3>1. Backup Using pg_dump</h3>

    <h4>📌 A) Full Database Backup (Plain SQL File)</h4>
    <pre><code>pg_dump -U username dbname > backup.sql</code></pre>

    <p><b>Restores using:</b> psql</p>
    <pre><code>psql -U username -d dbname -f backup.sql</code></pre>

    <h4>📌 B) Backup Specific Table</h4>
    <pre><code>pg_dump -U username -t table_name dbname > table_backup.sql</code></pre>

    <h4>📌 C) Backup Specific Schema</h4>
    <pre><code>pg_dump -U username -n schema_name dbname > schema_backup.sql</code></pre>

    <h4>📌 D) Custom Format Backup (.dump / .backup)</h4>
    <pre><code>pg_dump -U username -F c -f backup.dump dbname</code></pre>

    <p>This custom format requires <code>pg_restore</code> to restore.</p>

    <h4>📌 E) Directory Format Backup</h4>
    <pre><code>pg_dump -U username -F d -f backup_dir dbname</code></pre>

    <h4>📌 F) Backup Only Schema (No Data)</h4>
    <pre><code>pg_dump -U username -s dbname > schema_only.sql</code></pre>

    <h4>📌 G) Backup Only Data (No Schema)</h4>
    <pre><code>pg_dump -U username -a dbname > data_only.sql</code></pre>

    <hr>

    <h3>2. Restore Using pg_restore (for custom/directory format)</h3>

    <h4>📌 A) Restore Into Existing Database</h4>
    <pre><code>pg_restore -U username -d dbname backup.dump</code></pre>

    <h4>📌 B) Restore with Clean (Drop existing objects)</h4>
    <pre><code>pg_restore -U username --clean -d dbname backup.dump</code></pre>

    <h4>📌 C) Restore Only Schema</h4>
    <pre><code>pg_restore -U username -s -d dbname backup.dump</code></pre>

    <h4>📌 D) Restore Only Data</h4>
    <pre><code>pg_restore -U username -a -d dbname backup.dump</code></pre>

    <h4>📌 E) List Contents of a Backup File</h4>
    <pre><code>pg_restore -l backup.dump</code></pre>

    <hr>

    <h3>3. Restore Using psql (for plain .sql backups)</h3>

    <h4>📌 A) Restore Full Database</h4>
    <pre><code>psql -U username -d dbname -f backup.sql</code></pre>

    <h4>📌 B) Restore a Schema Only</h4>
    <pre><code>psql -U username -d dbname -f schema_only.sql</code></pre>

    <h4>📌 C) Restore Data Only</h4>
    <pre><code>psql -U username -d dbname -f data_only.sql</code></pre>

    <hr>

    <h3>4. Backup & Restore All Databases</h3>

    <h4>📌 Backup all databases</h4>
    <pre><code>pg_dumpall -U username > alldb_backup.sql</code></pre>

    <h4>📌 Restore all databases</h4>
    <pre><code>psql -U username -f alldb_backup.sql</code></pre>

    <hr>

    <h3>5. Backup Roles & Permissions</h3>

    <h4>📌 Backup roles only</h4>
    <pre><code>pg_dumpall -U username --globals-only > roles.sql</code></pre>

    <h4>📌 Restore roles</h4>
    <pre><code>psql -U username -f roles.sql</code></pre>

    <hr>

    <h3>6. Important Notes</h3>
    <ul>
        <li><code>pg_dump</code> does NOT block other operations — no downtime.</li>
        <li><code>pg_restore</code> requires a database created beforehand.</li>
        <li>For large DBs, custom format (<code>-F c</code>) is best.</li>
        <li>Plain SQL backups restore slower but are human-readable.</li>
    </ul>
</section>

<hr>

<section>
    <h2>Backup Strategies in PostgreSQL (Full, Incremental, WAL)</h2>
    <p>PostgreSQL supports multiple backup strategies to ensure data safety, fast recovery, and minimal downtime. These strategies include Full backups, Incremental backups, and WAL (Write-Ahead Log) archiving.</p>

    <hr>
    <h3>1. Full Backup</h3>
    <p>A full backup takes a complete snapshot of the entire database at a point in time.</p>

    <h4>📌 Full Backup Using pg_dump</h4>
    <pre><code>pg_dump -U username dbname > full_backup.sql</code></pre>

    <h4>📌 Full Backup of All Databases</h4>
    <pre><code>pg_dumpall -U username > alldb_full_backup.sql</code></pre>

    <h4>✔ Advantages</h4>
    <ul>
        <li>Easy to create and restore</li>
        <li>Readable .sql files</li>
        <li>No dependency on WAL logs</li>
    </ul>

    <h4>✘ Disadvantages</h4>
    <ul>
        <li>Slow for large databases</li>
        <li>Consumes more storage space</li>
    </ul>

    <hr>
    <h3>2. Incremental Backup</h3>
    <p>PostgreSQL does NOT support true incremental backups using pg_dump.  
    Incremental backups are achieved using <b>File System Level backup + WAL Archiving + Continuous Archiving</b>.</p>

    <p>This allows restoring the database up to any moment in time.</p>

    <h4>📌 Incremental Logic</h4>
    <ol>
        <li>Take a base backup (file-system level)</li>
        <li>Enable WAL archiving</li>
        <li>Store all WAL files that record every database change</li>
        <li>Restore base backup + replay WAL → Recover database state</li>
    </ol>

    <hr>

    <h3>3. WAL Archiving (Write-Ahead Logging)</h3>
    <p>WAL files store every database change.  
    Enabling WAL archiving allows:
        <ul>
            <li>Incremental recovery</li>
            <li>Point-In-Time Recovery (PITR)</li>
            <li>Standby servers / replication</li>
        </ul>
    </p>

    <h4>📌 Enable WAL Archiving (postgresql.conf)</h4>
    <pre><code>wal_level = archive
archive_mode = on
archive_command = 'cp %p /path/to/archive/%f'</code></pre>

    <h4>✔ Base Backup Command (File System Backup)</h4>
    <pre><code>pg_basebackup -U username -D /backup/location -Ft -z -P</code></pre>

    <p>This produces a base backup + WAL files.</p>

    <hr>

    <h3>4. Point-In-Time Recovery (PITR)</h3>
    <p>Using WAL + base backup, PostgreSQL can reconstruct the database up to any timestamp.</p>

    <h4>📌 Recovery Example (recovery.signal)</h4>
    <pre><code>restore_command = 'cp /path/to/archive/%f %p'
recovery_target_time = '2025-01-01 10:00:00'</code></pre>

    <p>Place the above settings in <code>postgresql.auto.conf</code> for recovery.</p>

    <hr>

    <h3>5. Backup Strategy Comparison</h3>

    <table  cellpadding="6">
        <tr><th>Backup Type</th><th>Description</th><th>Speed</th><th>Storage</th><th>Use Case</th></tr>
        <tr><td>Full Backup</td><td>Complete copy of DB</td><td>Slow</td><td>High</td><td>Small/medium DB, simple restore</td></tr>
        <tr><td>Incremental</td><td>Base backup + WAL logs</td><td>Fast (after base)</td><td>Low</td><td>Large DB, enterprise backup</td></tr>
        <tr><td>WAL Archiving</td><td>Continuous log-based backup</td><td>Very fast</td><td>Medium</td><td>PITR, High availability</td></tr>
    </table>

    <hr>

    <h3>6. Recommended Best Practices</h3>
    <ul>
        <li>Daily full backup for small databases</li>
        <li>Weekly base backup + WAL archiving for large databases</li>
        <li>Store backups on remote/cloud storage</li>
        <li>Test restores regularly</li>
        <li>Enable WAL compression</li>
    </ul>
</section>


<section id="psql-functions">
  <h2>🛠️ PostgreSQL Functions</h2>

  <p>A <strong>function</strong> in PostgreSQL is a stored program that returns a value. Functions can be written in <code>SQL</code> or <code>PL/pgSQL</code>. They allow code reuse, logic implementation, calculations, and return results directly inside <code>SELECT</code> statements.</p>

  <hr>

  <!-- Basic Syntax -->
  <h3>📘 Basic Syntax (SQL Function)</h3>
  <pre><code>
CREATE FUNCTION function_name(param_name datatype, ...)
RETURNS return_datatype
AS $$
    SQL Query Here;
$$ LANGUAGE sql;
  </code></pre>

  <h4>✔ Example</h4>
  <pre><code>
CREATE FUNCTION get_price(pid INT)
RETURNS INT
AS $$
    SELECT price FROM products WHERE productid = pid;
$$ LANGUAGE sql;
  </code></pre>

  <hr>

  <!-- PLPGSQL Syntax -->
  <h3>📘 Basic Syntax (PL/pgSQL Function)</h3>
  <pre><code>
CREATE FUNCTION function_name(param datatype, ...)
RETURNS return_type
LANGUAGE plpgsql
AS $$
DECLARE
    variable datatype;
BEGIN
    -- logic here
    RETURN value;
END;
$$;
  </code></pre>

  <h4>✔ Example</h4>
  <pre><code>
CREATE FUNCTION discount(price INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN price - (price * 0.10);
END;
$$;
  </code></pre>

  <hr>

  <!-- Multiple Parameters -->
  <h3>📘 Function With Multiple Parameters</h3>
  <pre><code>
CREATE FUNCTION add_numbers(a INT, b INT)
RETURNS INT
AS $$
    SELECT a + b;
$$ LANGUAGE sql;
  </code></pre>

  <hr>

  <!-- Return Table -->
  <h3>📘 Function Returning a Table</h3>
  <pre><code>
CREATE FUNCTION top_products()
RETURNS TABLE(productid INT, total_quantity INT)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT productid, SUM(quantity)
    FROM orderitems
    GROUP BY productid
    ORDER BY SUM(quantity) DESC;
END;
$$;
  </code></pre>

  <h4>✔ Use</h4>
  <pre><code>
SELECT * FROM top_products();
  </code></pre>

  <hr>

  <!-- OUT Parameters -->
  <h3>📘 Function With OUT Parameters</h3>
  <pre><code>
CREATE FUNCTION double_value(IN num INT, OUT result INT)
LANGUAGE plpgsql
AS $$
BEGIN
    result := num * 2;
END;
$$;
  </code></pre>

  <h4>✔ Use</h4>
  <pre><code>
SELECT double_value(10);
  </code></pre>

  <hr>

  <!-- IF ELSE -->
  <h3>📘 Function With IF / ELSE</h3>
  <pre><code>
CREATE FUNCTION grade(marks INT)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
BEGIN
    IF marks >= 90 THEN
        RETURN 'A';
    ELSIF marks >= 70 THEN
        RETURN 'B';
    ELSE
        RETURN 'C';
    END IF;
END;
$$;
  </code></pre>

  <hr>

  <!-- LOOP -->
  <h3>📘 Function With LOOP</h3>
  <pre><code>
CREATE FUNCTION sum_upto(n INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    total INT := 0;
    i INT := 1;
BEGIN
    WHILE i <= n LOOP
        total := total + i;
        i := i + 1;
    END LOOP;

    RETURN total;
END;
$$;
  </code></pre>

  <hr>

  <!-- CASE -->
  <h3>📘 Function Using CASE</h3>
  <pre><code>
CREATE FUNCTION day_type(dayname TEXT)
RETURNS TEXT
AS $$
    SELECT CASE 
             WHEN dayname IN ('Saturday','Sunday') THEN 'Weekend'
             ELSE 'Weekday'
           END;
$$ LANGUAGE sql;
  </code></pre>

  <hr>

  <!-- Exception Handling -->
  <h3>📘 Function With Exception Handling</h3>
  <pre><code>
CREATE FUNCTION safe_divide(a INT, b INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RETURN NULL;
END;
$$;
  </code></pre>

  <hr>

  <!-- Replace Function -->
  <h3>📘 Create or Replace Function</h3>
  <pre><code>
CREATE OR REPLACE FUNCTION function_name(...)
RETURNS return_type
AS $$
BEGIN
    -- updated logic
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <hr>

  <!-- Drop Function -->
  <h3>📘 Drop Function</h3>
  <pre><code>
DROP FUNCTION function_name(argument_types);
  </code></pre>

  <h4>✔ Example</h4>
  <pre><code>
DROP FUNCTION get_price(INT);
  </code></pre>

  <hr>

  <!-- Function Limitations -->
  <h3>⚠️ Important Notes</h3>
  <ul>
    <li>Functions <strong>must return</strong> a value.</li>
    <li>Functions <strong>cannot</strong> use COMMIT or ROLLBACK.</li>
    <li>Functions <strong>can be used</strong> in SELECT queries.</li>
    <li>Functions are used for <strong>calculations, logic, returning results</strong>.</li>
  </ul>

</section>


<section id="procedures">

<h1>📘 PostgreSQL Procedures — Complete Notes</h1>

<h2>📌 What is a Procedure?</h2>
<p>
A <b>procedure</b> in PostgreSQL is a stored program that performs actions like 
INSERT, UPDATE, DELETE or calling other procedures.  
Unlike functions, procedures:
</p>
<ul>
  <li>do <b>not return</b> a value</li>
  <li>are executed using <code>CALL</code></li>
  <li>allow <b>transaction control</b> (COMMIT, ROLLBACK)</li>
</ul>

<hr>

<h2>📘 Syntax: Create a Procedure</h2>

<pre>
CREATE PROCEDURE procedure_name (parameters)
LANGUAGE plpgsql
AS $$
BEGIN
    -- body of procedure
END;
$$;
</pre>

<hr>

<h2>📘 Example 1 — Simple Procedure</h2>

<pre>
CREATE PROCEDURE hello_proc()
LANGUAGE plpgsql
AS $$
BEGIN
    RAISE NOTICE 'Hello from Procedure!';
END;
$$;

CALL hello_proc();
</pre>

<hr>

<h2>📘 Procedure With Parameters</h2>

<pre>
CREATE PROCEDURE add_product(pname TEXT, pprice INT)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO products(productname, price)
    VALUES (pname, pprice);
END;
$$;

CALL add_product('Laptop', 45000);
</pre>

<hr>

<h2>📘 IN, OUT, INOUT Parameters</h2>

<h3>✔ IN (default)</h3>
<p>Used to send input into procedure</p>

<h3>✔ OUT</h3>
<p>Used to return a value</p>

<h3>✔ INOUT</h3>
<p>Input → modified → returned</p>

<pre>
CREATE PROCEDURE update_price(INOUT p INT)
LANGUAGE plpgsql
AS $$
BEGIN
    p := p + 100;
END;
$$;

CALL update_price(900); 
-- result: 1000
</pre>

<hr>

<h2>📘 Procedure With Transaction Control (Allowed)</h2>

<pre>
CREATE PROCEDURE transaction_test()
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO logs VALUES ('Before Commit');

    COMMIT;

    INSERT INTO logs VALUES ('After Commit');
END;
$$;
</pre>

<hr>

<h2>📘 ALTER PROCEDURE</h2>

<h3>✔ Rename Procedure</h3>
<pre>
ALTER PROCEDURE hello_proc() RENAME TO hi_proc;
</pre>

<h3>✔ Change Owner</h3>
<pre>
ALTER PROCEDURE hello_proc() OWNER TO new_user;
</pre>

<h3>✔ Move to Another Schema</h3>
<pre>
ALTER PROCEDURE hello_proc() SET SCHEMA newschema;
</pre>

<hr>

<h2>📘 DROP PROCEDURE</h2>

<pre>
DROP PROCEDURE procedure_name(parameters);
</pre>

<h3>Example:</h3>
<pre>
DROP PROCEDURE add_product(TEXT, INT);
</pre>

<hr>

<h2>📘 Procedure vs Function — Comparison</h2>

<table border="1" cellpadding="5">
<tr>
  <th>Feature</th>
  <th>Function</th>
  <th>Procedure</th>
</tr>
<tr>
  <td>Returns value</td>
  <td>Yes</td>
  <td>No</td>
</tr>
<tr>
  <td>Execution</td>
  <td>SELECT function()</td>
  <td>CALL procedure()</td>
</tr>
<tr>
  <td>Transaction control</td>
  <td>❌ Not allowed</td>
  <td>✔ Allowed</td>
</tr>
<tr>
  <td>Main use</td>
  <td>Calculations</td>
  <td>Database operations</td>
</tr>
</table>

</section>

<section id="cte">

<h1>📘 CTE — Common Table Expressions (WITH Clause)</h1>

<p>
A CTE (Common Table Expression) is a temporary result set created using <code>WITH</code>.  
It is readable, reusable, and best for complex queries.
</p>

<hr>

<h2>📌 1. Basic CTE</h2>

<pre>
WITH temp AS (
    SELECT productid, price 
    FROM products
    WHERE price > 1000
)
SELECT * FROM temp;
</pre>

<p>✔ Creates CTE named <b>temp</b> and then selects from it.</p>

<hr>

<h2>📌 2. CTE With Joins</h2>

<pre>
WITH order_total AS (
    SELECT o.productid, SUM(o.quantity) AS total
    FROM orderitems o
    GROUP BY o.productid
)
SELECT p.productname, o.total
FROM products p
JOIN order_total o
    ON p.productid = o.productid;
</pre>

<hr>

<h2>📌 3. Multiple CTEs</h2>

<pre>
WITH 
high_price AS (
    SELECT * FROM products WHERE price > 2000
),
max_by_cat AS (
    SELECT category, MAX(price) AS maxprice
    FROM high_price
    GROUP BY category
)
SELECT p.category, p.productname, p.price
FROM high_price p
JOIN max_by_cat m
   ON p.category = m.category
  AND p.price = m.maxprice;
</pre>

<p>✔ Each CTE can use previous CTEs.</p>

<hr>

<h2>📌 4. CTE for UPDATE</h2>

<p>Update rows using a CTE result.</p>

<pre>
WITH price_raise AS (
    SELECT productid FROM products
    WHERE category = 'Electronics'
)
UPDATE products
SET price = price + 1000
WHERE productid IN (SELECT productid FROM price_raise);
</pre>

<p>✔ CTE simplifies complex UPDATE logic.</p>

<hr>

<h2>📌 5. CTE for DELETE</h2>

<pre>
WITH old_orders AS (
    SELECT orderid FROM orders
    WHERE orderdate < '2023-01-01'
)
DELETE FROM orders
WHERE orderid IN (SELECT orderid FROM old_orders);
</pre>

<hr>

<h2>📌 6. Recursive CTE Basics</h2>

<p>
A recursive CTE has two parts:
</p>

<ul>
  <li><b>Anchor member</b> → runs once</li>
  <li><b>Recursive member</b> → repeats until no rows returned</li>
</ul>

<pre>
WITH RECURSIVE numbers AS (
    SELECT 1 AS n            -- anchor
    UNION ALL
    SELECT n + 1             -- recursive
    FROM numbers
    WHERE n < 10
)
SELECT * FROM numbers;
</pre>

<p>Output: 1 to 10</p>

<hr>

<h2>📌 7. Recursive CTE — Factorial</h2>

<pre>
WITH RECURSIVE fact AS (
    SELECT 1 AS n, 1 AS value      -- anchor
    UNION ALL
    SELECT n + 1, value * (n + 1)
    FROM fact
    WHERE n < 5
)
SELECT * FROM fact;
</pre>

<p>✔ Shows factorial sequence.</p>

<hr>

<h2>📌 8. Recursive CTE — Tree / Hierarchy Example</h2>

<p>Employees table with manager relationships.</p>

<pre>
WITH RECURSIVE emp_tree AS (
    SELECT empid, name, managerid, 1 AS level
    FROM employees
    WHERE managerid IS NULL      -- top-most manager

    UNION ALL

    SELECT e.empid, e.name, e.managerid, t.level + 1
    FROM employees e
    JOIN emp_tree t
        ON e.managerid = t.empid
)
SELECT * FROM emp_tree ORDER BY level;
</pre>

<p>✔ Shows full reporting hierarchy.</p>

<hr>

<h2>📌 9. Recursive CTE — Parent → Child</h2>

<pre>
WITH RECURSIVE tree AS (
   SELECT id, parent_id, name
   FROM category
   WHERE parent_id IS NULL  -- parent

   UNION ALL

   SELECT c.id, c.parent_id, c.name
   FROM category c
   JOIN tree t ON c.parent_id = t.id
)
SELECT * FROM tree;
</pre>

<hr>

<h2>📌 10. Using CTE for INSERT</h2>

<pre>
WITH newprod AS (
    INSERT INTO products(productname, price)
    VALUES ('Tablet', 25000)
    RETURNING productid
)
INSERT INTO stock(productid, quantity)
SELECT productid, 100 FROM newprod;
</pre>

<hr>

<h2>📌 11. CTE + Window Functions</h2>

<pre>
WITH totals AS (
    SELECT productid, SUM(quantity) AS total
    FROM orderitems
    GROUP BY productid
)
SELECT *, 
       RANK() OVER (ORDER BY total DESC) AS rnk
FROM totals;
</pre>

<hr>

<h2>📌 12. Materialized CTE (CTE executed once)</h2>

<pre>
WITH MATERIALIZED temp AS (
    SELECT * FROM products WHERE price > 1000
)
SELECT * FROM temp;
</pre>

<hr>

<h2>📌 13. Inline CTE — Used Inside Subquery</h2>

<pre>
SELECT *
FROM (
    WITH x AS (SELECT 1 AS a)
    SELECT a FROM x
) t;
</pre>

</section>

<section id="psql-admin">

<h1>📘 PostgreSQL Administration Commands</h1>

<p>
This section covers important <b>psql meta-commands</b> and <b>PostgreSQL administration operations</b> 
such as databases, roles, privileges, schemas, backup/restore, and server information.
</p>

<hr>

<h2>🔹 1. Basic <code>psql</code> Meta-Commands</h2>

<pre>
\l              -- list all databases
\c dbname       -- connect to a database
\dt             -- list all tables
\di             -- list indexes
\dv             -- list views
\dn             -- list schemas
\df             -- list functions
\du             -- list roles/users
\d tablename    -- describe table
\q              -- quit psql
\copyright
\encoding
</pre>

<hr>

<h2>🔹 2. Describe Objects</h2>

<pre>
\d table        -- structure of table
\d+ table       -- with storage and size info
\df+            -- functions with details
\dx             -- list installed extensions
\det            -- list foreign tables
</pre>

<hr>

<h2>🔹 3. Database Management</h2>

<h3>⚡ Create Database</h3>
<pre>
CREATE DATABASE company;
</pre>

<h3>⚡ Drop Database</h3>
<pre>
DROP DATABASE company;
</pre>

<h3>⚡ Rename Database</h3>
<pre>
ALTER DATABASE company RENAME TO company_new;
</pre>

<h3>⚡ Set Default Encoding / Owner</h3>
<pre>
CREATE DATABASE salesdb OWNER aathi ENCODING 'UTF8';
</pre>

<hr>

<h2>🔹 4. User & Role Management</h2>

<h3>⚡ Create User</h3>
<pre>
CREATE USER aathi WITH PASSWORD '1234';
</pre>

<h3>⚡ Create Superuser</h3>
<pre>
CREATE ROLE admin SUPERUSER LOGIN PASSWORD 'pass';
</pre>

<h3>⚡ Grant Privileges</h3>
<pre>
GRANT ALL PRIVILEGES ON DATABASE salesdb TO aathi;
GRANT SELECT, INSERT ON products TO developer;
</pre>

<h3>⚡ Revoke Privileges</h3>
<pre>
REVOKE INSERT ON products FROM developer;
</pre>

<h3>⚡ Change Password</h3>
<pre>
ALTER USER postgres WITH PASSWORD 'newpass';
</pre>

<hr>

<h2>🔹 5. Role Attributes</h2>

<pre>
ALTER ROLE developer CREATEDB;
ALTER ROLE tester CREATEROLE;
ALTER ROLE analyst LOGIN;
ALTER ROLE support NOLOGIN;
</pre>

<hr>

<h2>🔹 6. Schema Administration</h2>

<h3>⚡ Create Schema</h3>
<pre>
CREATE SCHEMA sales;
</pre>

<h3>⚡ Drop Schema</h3>
<pre>
DROP SCHEMA sales CASCADE;
</pre>

<h3>⚡ Change Search Path</h3>
<pre>
SET search_path TO sales, public;
</pre>

<h3>⚡ Ownership</h3>
<pre>
ALTER SCHEMA sales OWNER TO manager;
</pre>

<hr>

<h2>🔹 7. Table & Column Level Admin Commands</h2>

<h3>⚡ Rename Table</h3>
<pre>
ALTER TABLE products RENAME TO items;
</pre>

<h3>⚡ Add/Drop Columns</h3>
<pre>
ALTER TABLE products ADD COLUMN stock INT DEFAULT 0;
ALTER TABLE products DROP COLUMN stock;
</pre>

<h3>⚡ Add Constraints</h3>
<pre>
ALTER TABLE products 
ADD CONSTRAINT price_check CHECK (price > 0);
</pre>

<hr>

<h2>🔹 8. Index Administration</h2>

<pre>
CREATE INDEX idx_price ON products(price);
DROP INDEX idx_price;
</pre>

<hr>

<h2>🔹 9. Server Information & Settings</h2>

<pre>
SHOW all;                   -- all PostgreSQL settings
SHOW port;                  -- port number
SHOW data_directory;        -- data directory
SELECT version();           -- PostgreSQL version
SELECT current_database();  
SELECT current_user();
</pre>

<hr>

<h2>🔹 10. Monitoring & Processes</h2>

<pre>
SELECT * FROM pg_stat_activity;
SELECT pid, query, state FROM pg_stat_activity;
SELECT * FROM pg_locks;
</pre>

<h3>Kill a Query</h3>
<pre>
SELECT pg_terminate_backend(pid);
</pre>

<hr>

<h2>🔹 11. Extensions</h2>

<pre>
\dx                              -- list extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION pgcrypto;
</pre>

<hr>

<h2>🔹 12. Backup & Restore</h2>

<h3>⚡ Backup Entire Database</h3>
<pre>
pg_dump -U postgres -F c -f backup.dump company;
</pre>

<h3>⚡ Restore</h3>
<pre>
pg_restore -U postgres -d company backup.dump;
</pre>

<h3>⚡ Export SQL Format</h3>
<pre>
pg_dump -U postgres company > company.sql
</pre>

<hr>

<h2>🔹 13. Import / Export CSV</h2>

<h3>Export</h3>
<pre>
COPY products TO '/tmp/products.csv' CSV HEADER;
</pre>

<h3>Import</h3>
<pre>
COPY products FROM '/tmp/products.csv' CSV HEADER;
</pre>

<hr>

<h2>🔹 14. Transaction Commands</h2>

<pre>
BEGIN;
UPDATE products SET price = price + 100;
COMMIT;

BEGIN;
DELETE FROM products WHERE productid = 10;
ROLLBACK;
</pre>

<hr>

<h2>🔹 15. Analyze & Vacuum</h2>

<pre>
VACUUM;                    -- cleanup
VACUUM FULL;               -- fully reclaim space
ANALYZE;                   -- update planner statistics
VACUUM ANALYZE;            -- both
</pre>

</section>


<hr>

<!-- Prepared Statements -->
<div class="section">
<h2>1. Prepared Statements</h2>

<h3>📘 Description</h3>
<p>A prepared statement is a precompiled SQL statement stored by PostgreSQL for faster and safer execution.</p>

<h3>📌 Usage</h3>
<ul>
  <li>Improves performance</li>
  <li>Prevents SQL injection</li>
  <li>Good for repeated queries</li>
</ul>

<h3>🧩 Syntax</h3>
<pre>
PREPARE stmt_name(datatype, datatype, ...)
AS SQL query;
</pre>

<h3>▶ Execute</h3>
<pre>EXECUTE stmt_name(value1, value2);</pre>

<h3>🧪 Example</h3>
<pre>
PREPARE get_customer(INT) AS
SELECT * FROM customers WHERE customerid = $1;

EXECUTE get_customer(10);
</pre>

<h3>🧹 Remove Prepared Statement</h3>
<pre>DEALLOCATE get_customer;</pre>
</div>

<!-- Raise -->
<div class="section">
<h2>2. RAISE NOTICE, WARNING, EXCEPTION</h2>

<h3>📘 Description</h3>
<p>Used inside functions, procedures, or DO blocks to display messages.</p>

<pre>
RAISE NOTICE 'Normal message';
RAISE WARNING 'Warning message';
RAISE EXCEPTION 'Error message';
</pre>

<h3>🧪 Example</h3>
<pre>
DO $$
BEGIN
    RAISE NOTICE 'Hello!';
    RAISE WARNING 'Low balance!';
    RAISE EXCEPTION 'Stop, error occurred!';
END $$;
</pre>
</div>

<!-- Procedures -->
<div class="section">
<h2>3. Procedures</h2>

<h3>📘 Description</h3>
<p>Procedures can perform <b>transactions</b> (COMMIT, ROLLBACK). Functions cannot.</p>

<h3>🧩 Syntax</h3>
<pre>
CREATE PROCEDURE proc_name(args)
LANGUAGE plpgsql
AS $$
BEGIN
    -- code
END $$;
</pre>

<h3>🧪 Example</h3>
<pre>
CREATE PROCEDURE increase_price(p_percent INT)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE products
    SET price = price + (price * p_percent / 100);
END $$;

CALL increase_price(10);
</pre>
</div>

<!-- Views -->
<div class="section">
<h2>4. Views (Updatable & Non-Updatable)</h2>

<h3>📘 Updatable View Conditions</h3>
<ul>
    <li>Single table only</li>
    <li>No DISTINCT</li>
    <li>No GROUP BY / HAVING</li>
    <li>No aggregates</li>
</ul>

<h3>🧪 Example (Updatable)</h3>
<pre>
CREATE VIEW v_customers AS
SELECT customerid, name, city FROM customers;

UPDATE v_customers SET city='Chennai' WHERE customerid=1;
</pre>

<h3>❌ Non-Updatable View</h3>
<pre>
CREATE VIEW v_sales_summary AS
SELECT salesperson, SUM(amount)
FROM sales
GROUP BY salesperson;
</pre>
</div>

<!-- Index behavior -->
<div class="section">
<h2>5. Index Behavior on DELETE / UPDATE</h2>

<p><b>DELETE</b> removes the specific row's index entry.<br>
<b>UPDATE</b> removes the old index entry & adds a new one.</p>
</div>

<!-- format function -->
<div class="section">
<h2>6. format() Function</h2>

<h3>📘 Description</h3>
<p>Used to construct dynamic SQL safely.</p>

<pre>
format('SELECT * FROM %I', table_name);  -- %I for identifiers
format('Hello %s', name);               -- %s for strings
</pre>

<h3>🧪 Example</h3>
<pre>
DO $$
DECLARE t text := 'customers';
BEGIN
    EXECUTE format('SELECT * FROM %I', t);
END $$;
</pre>
</div>

<!-- Dynamic SQL -->
<div class="section">
<h2>7. EXECUTE (Dynamic SQL)</h2>

<pre>
DO $$
DECLARE col text := 'city';
BEGIN
   EXECUTE 'SELECT ' || col || ' FROM customers';
END $$;
</pre>
</div>

<!-- Cursors -->
<div class="section">
<h2>8. Cursors</h2>

<h3>📘 Description</h3>
<p>Used to fetch rows one by one.</p>

<pre>
DO $$
DECLARE
    cur CURSOR FOR SELECT name FROM customers;
    val text;
BEGIN
    OPEN cur;
    LOOP
        FETCH cur INTO val;
        EXIT WHEN NOT FOUND;
        RAISE NOTICE 'Customer: %', val;
    END LOOP;
    CLOSE cur;
END $$;
</pre>
</div>

<!-- COPY -->
<div class="section">
<h2>9. COPY (Import/Export CSV)</h2>

<h3>📤 Export</h3>
<pre>COPY customers TO '/tmp/cust.csv' CSV HEADER;</pre>

<h3>📥 Import</h3>
<pre>COPY customers FROM '/tmp/cust.csv' CSV HEADER;</pre>
</div>

<!-- Sequences -->
<div class="section">
<h2>10. Sequence Functions</h2>

<pre>
SELECT nextval('seq');
SELECT currval('seq');
SELECT setval('seq', 500, true);
</pre>
</div>

<!-- Functions -->
<div class="section">
<h2>11. Functions (plpgsql)</h2>

<h3>🧩 Syntax</h3>
<pre>
CREATE FUNCTION funcname(args)
RETURNS datatype
LANGUAGE plpgsql
AS $$
BEGIN
   RETURN something;
END $$;
</pre>
</div>

<!-- Triggers -->
<div class="section">
<h2>12. Triggers</h2>

<h3>📘 Description</h3>
<p>Trigger executes automatically <b>before/after</b> INSERT, UPDATE, or DELETE.</p>

<h3>🧪 Example</h3>
<pre>
CREATE FUNCTION log_update()
RETURNS trigger AS $$
BEGIN
   INSERT INTO audit(message) VALUES ('Row updated');
   RETURN NEW;
END $$ LANGUAGE plpgsql;

CREATE TRIGGER t1
AFTER UPDATE ON customers
FOR EACH ROW
EXECUTE FUNCTION log_update();
</pre>
</div>

<!-- Window -->
<div class="section">
<h2>13. Window Functions</h2>

<pre>
SELECT
   name,
   amount,
   SUM(amount) OVER (ORDER BY amount) AS running_total
FROM sales;
</pre>
</div>

<!-- Materialized Views -->
<div class="section">
<h2>14. Materialized Views</h2>

<pre>
CREATE MATERIALIZED VIEW mv_sales AS
SELECT * FROM sales;

REFRESH MATERIALIZED VIEW mv_sales;
</pre>
</div>

<!-- JSONB -->
<div class="section">
<h2>15. JSONB Functions</h2>

<pre>
SELECT data->>'name' FROM users;
SELECT data->'address'->>'city' FROM users;
SELECT jsonb_pretty(data) FROM users;
</pre>
</div>

<!-- CTE -->
<div class="section">
<h2>16. WITH (CTE) & Recursive CTE</h2>

<h3>Simple CTE</h3>
<pre>
WITH temp AS (
   SELECT * FROM customers WHERE city='Chennai'
)
SELECT * FROM temp;
</pre>

<h3>Recursive</h3>
<pre>
WITH RECURSIVE nums(n) AS (
   SELECT 1
   UNION ALL
   SELECT n+1 FROM nums WHERE n < 5
)
SELECT * FROM nums;
</pre>
</div>

<!-- Index Types -->
<div class="section">
<h2>17. Index Types</h2>
<ul>
  <li><b>B-tree</b> – default, best for comparisons</li>
  <li><b>Hash</b> – equality only</li>
  <li><b>GIN</b> – JSONB, arrays, full text search</li>
  <li><b>GiST</b> – geometric, ranges</li>
  <li><b>BRIN</b> – huge tables (1M+ rows)</li>
</ul>

<pre>
CREATE INDEX idx1 ON customers(name);
CREATE INDEX idx_json ON users USING GIN(data);
</pre>
</div>

<!-- Partitioning -->
<div class="section">
<h2>18. Table Partitioning</h2>

<h3>Range Partition</h3>
<pre>
CREATE TABLE sales (
    id INT,
    sale_date DATE
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_2024 PARTITION OF sales
FOR VALUES FROM ('2024-01-01') TO ('2024-12-31');
</pre>
</div>

<!-- Constraints -->
<div class="section">
<h2>19. Constraints</h2>

<pre>
PRIMARY KEY
UNIQUE
CHECK
NOT NULL
FOREIGN KEY
</pre>
</div>

<!-- Transactions -->
<div class="section">
<h2>20. Transactions</h2>

<pre>
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id=1;
UPDATE accounts SET balance = balance + 100 WHERE id=2;
COMMIT;
</pre>
</div>


<hr>



<section id="dynamic-sql">
  <h2>🚀 Dynamic SQL in PostgreSQL — format() & EXECUTE</h2>

  <!-- Format Variables -->
  <h3>🧩 1. format() Placeholders (%I, %L, %s, %%)</h3>
  <p>The <code>format()</code> function is used to build dynamic SQL safely. PostgreSQL provides special placeholders for identifiers, values, and plain strings.</p>

  <table border="1" cellpadding="10" cellspacing="0">
    <tr>
      <th>Placeholder</th>
      <th>Meaning</th>
      <th>Use For</th>
    </tr>
    <tr>
      <td><code>%I</code></td>
      <td>Identifier</td>
      <td>Table name, Column name, Schema name</td>
    </tr>
    <tr>
      <td><code>%L</code></td>
      <td>Literal Value</td>
      <td>Strings, Text, Numeric values</td>
    </tr>
    <tr>
      <td><code>%s</code></td>
      <td>Plain String</td>
      <td>Simple text, not escaped</td>
    </tr>
    <tr>
      <td><code>%%</code></td>
      <td>Escaped % symbol</td>
      <td>To print the % character</td>
    </tr>
  </table>

  <h4>✔ Example Using All Placeholders</h4>
  <pre>
DO $$
DECLARE
    t text := 'customers';
    c text := 'city';
    v text := 'Chennai';
BEGIN
    RAISE NOTICE '%', format(
        'SELECT %I FROM %I WHERE %I = %L AND discount > 10%%',
        c, t, c, v
    );
END $$;
  </pre>

  <h3>📌 Summary of When to Use What</h3>
  <ul>
    <li><b>Dynamic table name →</b> use <code>%I</code></li>
    <li><b>Dynamic column name →</b> use <code>%I</code></li>
    <li><b>Dynamic string/numeric value →</b> use <code>%L</code></li>
    <li><b>Static text →</b> use <code>%s</code></li>
    <li><b>To print % →</b> use <code>%%</code></li>
  </ul>

  <!-- EXECUTE Details -->
  <h2>⚡ 2. EXECUTE — Complete Detailed Notes</h2>

  <h3>📘 What is EXECUTE?</h3>
  <p><code>EXECUTE</code> runs a SQL query that is created at runtime (Dynamic SQL). It is used inside:</p>
  <ul>
    <li>FUNCTIONS</li>
    <li>PROCEDURES</li>
    <li>TRIGGERS</li>
    <li>DO $$ blocks</li>
  </ul>

  <pre>
EXECUTE 'SQL query here...';
  </pre>

  <h3>🔥 Why Use EXECUTE?</h3>
  <p>Use <code>EXECUTE</code> only when something in the SQL query cannot be hardcoded.</p>

  <h3>🎯 MUST Use EXECUTE in These Situations</h3>
  <ol>
    <li><b>Dynamic table name</b></li>
    <pre>EXECUTE format('SELECT * FROM %I', table_name);</pre>

    <li><b>Dynamic column name</b></li>
    <pre>EXECUTE format('SELECT %I FROM customers', col_name);</pre>

    <li><b>Dynamic WHERE condition</b></li>
    <pre>EXECUTE format('SELECT * FROM customers WHERE city = %L', city);</pre>

    <li><b>Dynamic ORDER BY / LIMIT / OFFSET</b></li>
    <pre>EXECUTE format('SELECT * FROM customers ORDER BY %I', sort_col);</pre>

    <li><b>Dynamic INSERT</b></li>
    <pre>
EXECUTE format(
  'INSERT INTO %I(name, city) VALUES(%L, %L)',
  tname, name, city
);
    </pre>

    <li><b>Dynamic UPDATE</b></li>
    <pre>
EXECUTE format(
  'UPDATE %I SET %I = %L WHERE id = %L',
  tname, col, val, id
);
    </pre>

    <li><b>Dynamic DELETE</b></li>
    <pre>
EXECUTE format('DELETE FROM %I WHERE id = %L', tname, id);
    </pre>

    <li><b>Dynamic ALTER TABLE / CREATE TABLE</b></li>
    <pre>EXECUTE format('CREATE TABLE %I(id INT)', new_table);</pre>

    <li><b>Dynamic INDEX creation</b></li>
    <pre>EXECUTE format('CREATE INDEX %I ON %I(%I)', idx, table, col);</pre>

    <li><b>Dynamic queries inside loops</b></li>
  </ol>

  <!-- Rules -->
  <h3>⚠ IMPORTANT RULES for EXECUTE</h3>
  <ul>
    <li><b>Always use <code>format()</code></b> to avoid SQL injection.</li>
    <li><b>Use <code>%I</code> for table & column names</b>.</li>
    <li><b>Use <code>%L</code> for values</b>.</li>
    <li><b>Must be inside a PL/pgSQL block.</b></li>
    <li><b>Cannot use EXECUTE directly in psql prompt.</b></li>
  </ul>

  <h3>❌ Wrong Usage</h3>
  <pre>
EXECUTE 'SELECT * FROM ' || table_name;   -- unsafe SQL injection!
  </pre>

  <h3>✔ Correct Usage</h3>
  <pre>
EXECUTE format('SELECT * FROM %I', table_name);
  </pre>

  <!-- Real World Examples -->
  <h2>💡 3. Real World EXECUTE Examples</h2>

  <h3>Example 1 — Selecting a Dynamic Column</h3>
  <pre>
DO $$
DECLARE col text := 'price';
BEGIN
  EXECUTE format('SELECT %I FROM products', col);
END $$;
  </pre>

  <h3>Example 2 — Updating Dynamic Column</h3>
  <pre>
EXECUTE format(
  'UPDATE %I SET %I = %L WHERE id = %L',
  'customers', 'city', 'Chennai', 3
);
  </pre>

  <h3>Example 3 — Inserting into Dynamic Table</h3>
  <pre>
EXECUTE format(
  'INSERT INTO %I(name, city) VALUES (%L, %L)',
  'customers', 'Aathi', 'Chennai'
);
  </pre>

  <h3>Example 4 — Dynamic ORDER BY</h3>
  <pre>
EXECUTE format(
  'SELECT * FROM customers ORDER BY %I',
  'name'
);
  </pre>

  <h3>Example 5 — Creating a Dynamic Table</h3>
  <pre>
EXECUTE format('CREATE TABLE %I (id SERIAL, name TEXT)', 'temp_table');
  </pre>

</section>

<hr>

<section id="composite-types">
  <h2>🧩 Composite Types in PostgreSQL</h2>

  <h3>📘 Description</h3>
  <p>
    A <b>composite type</b> is a user-defined datatype that can contain multiple fields.
    It acts like a custom structure (similar to structs in C or objects in OOP).
  </p>

  <h3>🛠️ Syntax</h3>
  <pre><code>CREATE TYPE type_name AS (
    column1 datatype,
    column2 datatype,
    ...
);</code></pre>

  <h3>📝 Example</h3>
  <pre><code>CREATE TYPE person_type AS (
    name TEXT,
    age INT,
    city TEXT
);</code></pre>

  <h3>🧪 Using Composite Type in a Function</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_person()
RETURNS person_type AS $$
DECLARE
    p person_type;
BEGIN
    p.name := 'Aathi';
    p.age := 22;
    p.city := 'Chennai';
    RETURN p;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_person();
</code></pre>
</section>

<!-- ========================================================= -->

<section id="multiple-values">
  <h2>🎯 Ways to Return Multiple Values in PostgreSQL</h2>

  <p>PostgreSQL supports returning multiple values using:</p>

  <ul>
    <li>Composite types</li>
    <li><code>RETURNS TABLE (...)</code></li>
    <li><code>RETURNS SETOF</code></li>
    <li><code>RETURNS RECORD</code></li>
    <li><code>%ROWTYPE</code></li>
  </ul>

  <hr>

  <h3>1️⃣ <code>RETURNS TABLE</code> (Most Common)</h3>
  <p>Used when you want to return multiple columns in a tabular format.</p>

  <pre><code>CREATE OR REPLACE FUNCTION get_emp_data()
RETURNS TABLE(id INT, name TEXT, salary INT) AS $$
BEGIN
    RETURN QUERY
    SELECT emp_id, emp_name, emp_salary FROM employees;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_emp_data();
</code></pre>

  <hr>

  <h3>2️⃣ <code>RETURNS SETOF table_name</code></h3>
  <p>Returns the entire rows of a table.</p>

  <pre><code>CREATE OR REPLACE FUNCTION get_all_customers()
RETURNS SETOF customers AS $$
BEGIN
    RETURN QUERY SELECT * FROM customers;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_all_customers();
</code></pre>

  <h3>Difference?</h3>
  <p><code>RETURNS SETOF</code> returns rows of an existing table, while <code>RETURNS TABLE</code> defines structure inside the function.</p>

  <hr>

  <h3>3️⃣ <code>RETURNS RECORD</code></h3>
  <p>Used when return structure is dynamic or unknown at function creation time.</p>

  <pre><code>CREATE OR REPLACE FUNCTION get_dynamic()
RETURNS RECORD AS $$
DECLARE
    rec RECORD;
BEGIN
    SELECT id, name INTO rec FROM employees WHERE id = 1;
    RETURN rec;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_dynamic() AS (id INT, name TEXT);
</code></pre>

  <p><b>Note:</b> When using RECORD, you must specify structure at SELECT time.</p>

  <hr>

  <h3>4️⃣ Returning Using <code>%ROWTYPE</code></h3>
  <p>Uses the row structure of an existing table.</p>

  <pre><code>CREATE OR REPLACE FUNCTION get_customer_row(cid INT)
RETURNS customers%ROWTYPE AS $$
DECLARE
    result customers%ROWTYPE;
BEGIN
    SELECT * INTO result FROM customers WHERE customerid = cid;
    RETURN result;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_customer_row(1);
</code></pre>

  <hr>

  <h3>5️⃣ Passing Multiple Values as Parameters</h3>

  <h4>🟦 Method 1: Normal Parameters</h4>
  <pre><code>CREATE FUNCTION add_nums(a INT, b INT) RETURNS INT AS $$
BEGIN
  RETURN a + b;
END;
$$ LANGUAGE plpgsql;
</code></pre>

  <h4>🟦 Method 2: Passing Composite Type</h4>
  <pre><code>CREATE FUNCTION insert_person(p person_type) RETURNS VOID AS $$
BEGIN
  INSERT INTO people VALUES (p.name, p.age, p.city);
END;
$$ LANGUAGE plpgsql;
</code></pre>

  <h4>🟦 Method 3: Variadic Parameters (multiple inputs)</h4>
  <pre><code>CREATE FUNCTION sum_all(VARIADIC nums INT[]) RETURNS INT AS $$
DECLARE total INT := 0;
BEGIN
  SELECT SUM(n) INTO total FROM unnest(nums) AS n;
  RETURN total;
END;
$$ LANGUAGE plpgsql;

SELECT sum_all(10, 20, 30, 40);
</code></pre>
</section>

<!-- ========================================================= -->

<section id="setof-table">
  <h2>📦 <code>RETURNS SETOF TABLE</code></h2>

  <p>
    Used when a function must return <b>multiple rows (set)</b> and each row 
    contains <b>multiple columns</b>.
  </p>

  <h3>🧪 Example</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_orders()
RETURNS SETOF orders AS $$
BEGIN
    RETURN QUERY SELECT * FROM orders WHERE totalamount > 500;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_orders();
</code></pre>
</section>

<!-- ========================================================= -->

<section id="returns-rowtype">
  <h2>🟩 <code>RETURNS col%ROWTYPE</code> & <code>table%ROWTYPE</code></h2>

  <p>Used when the function returns the exact structure of a table.</p>

  <pre><code>CREATE OR REPLACE FUNCTION get_last_order()
RETURNS orders%ROWTYPE AS $$
DECLARE
   row_data orders%ROWTYPE;
BEGIN
   SELECT * INTO row_data FROM orders ORDER BY orderid DESC LIMIT 1;
   RETURN row_data;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_last_order();
</code></pre>
</section>

<!-- ========================================================= -->

<section id="returns-record">
  <h2>🟨 <code>RETURNS RECORD</code> (Flexible Return Structure)</h2>

  <p>
    RECORD is useful when the return structure is not fixed or depends on logic.
    You must define the output column structure at call time.
  </p>

  <h3>🧪 Example</h3>
  <pre><code>CREATE OR REPLACE FUNCTION get_emp_dynamic(eid INT)
RETURNS RECORD AS $$
DECLARE
    rec RECORD;
BEGIN
    SELECT emp_id, emp_name, emp_salary INTO rec
    FROM employees WHERE emp_id = eid;
    RETURN rec;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_emp_dynamic(1) 
       AS (id INT, name TEXT, salary INT);
</code></pre>
</section>

<!-- ========================================================= -->

<section id="conclusion">
  <h2>🎉 Summary</h2>

  <ul>
    <li><b>Composite Type</b> → create your own structure</li>
    <li><b>RETURNS TABLE</b> → best for structured multi-column output</li>
    <li><b>RETURNS SETOF</b> → return multiple rows</li>
    <li><b>RETURNS RECORD</b> → return dynamic structure</li>
    <li><b>%ROWTYPE</b> → return entire table row</li>
  </ul>
</section>

<hr>

<section id="nth-max">
  <h2>🏆 Find Nth Maximum Value (Pure SQL Logic)</h2>

  <h3>📘 Description</h3>
  <p>
    This method finds the <b>1st max</b>, <b>2nd max</b>, <b>3rd max</b>, or 
    <b>Nth maximum</b> value from any column without using 
    <code>MAX()</code>, <code>ORDER BY</code>, <code>LIMIT</code>, or window functions.
    It uses mathematical logic based on how many values are greater than the current value.
  </p>

  <h3>🧮 Formula for Nth Maximum</h3>
  <pre><code>SELECT t1.col
FROM the_table t1
WHERE (n - 1) = (
    SELECT COUNT(DISTINCT t2.col)
    FROM the_table t2
    WHERE t2.col > t1.col
);</code></pre>

  <h3>🧠 How It Works</h3>
  <ul>
    <li>The maximum value has <b>0 values greater</b>.</li>
    <li>The second maximum has <b>1 value greater</b>.</li>
    <li>The third maximum has <b>2 values greater</b>.</li>
  </ul>

  <p>So the condition for the Nth maximum is:</p>

  <pre><code>(n - 1) = COUNT(DISTINCT values &gt; current)</code></pre>

  <h3>🔥 Examples</h3>

  <h4>1️⃣ First Maximum (n = 1)</h4>
  <pre><code>SELECT t1.col
FROM the_table t1
WHERE 1 - 1 = (
    SELECT COUNT(DISTINCT t2.col) 
    FROM the_table t2
    WHERE t2.col > t1.col
);</code></pre>
  <p>Gives the largest value.</p>

  <h4>2️⃣ Second Maximum (n = 2)</h4>
  <pre><code>SELECT t1.col
FROM the_table t1
WHERE 2 - 1 = (
    SELECT COUNT(DISTINCT t2.col) 
    FROM the_table t2
    WHERE t2.col > t1.col
);</code></pre>

  <h4>3️⃣ Third Maximum (n = 3)</h4>
  <pre><code>SELECT t1.col
FROM the_table t1
WHERE 3 - 1 = (
    SELECT COUNT(DISTINCT t2.col) 
    FROM the_table t2
    WHERE t2.col > t1.col
);</code></pre>

  <h3>✔ Works With Any Table & Column</h3>
  <p>Just replace:</p>
  <ul>
    <li><code>the_table</code> → your table name</li>
    <li><code>col</code> → your column name</li>
    <li><code>n</code> → which maximum you want</li>
  </ul>
</section>


<hr>

<section id="function-nth-max">
  <h2>🧠 Dynamic Function to Find Nth Maximum Value</h2>

  <p>
    This PostgreSQL function finds the <b>Nth maximum</b> value of any column 
    in any table using pure mathematical logic:
    <code>(n - 1) = COUNT(DISTINCT values greater)</code>.
    No <code>MAX()</code>, <code>ORDER BY</code>, or window functions are used.
  </p>

  <h3>📌 Function Definition</h3>
  <pre><code>CREATE OR REPLACE FUNCTION find_nth_max(
    tablename text,
    columnname text,
    n int
)
RETURNS numeric AS $$
DECLARE
    result numeric;
    query text;
BEGIN
    query := format(
        'SELECT t1.%I
         FROM %I t1
         WHERE (%s - 1) = (
             SELECT COUNT(DISTINCT t2.%I)
             FROM %I t2
             WHERE t2.%I > t1.%I
         )',
         columnname, tablename,
         n,
         columnname, tablename, columnname, columnname
    );

    EXECUTE query INTO result;
    RETURN result;
END;
$$ LANGUAGE plpgsql;</code></pre>

  <h3>🔍 How to Use</h3>

  <p><b>1st Maximum:</b></p>
  <pre><code>SELECT find_nth_max('employees', 'salary', 1);</code></pre>

  <p><b>2nd Maximum:</b></p>
  <pre><code>SELECT find_nth_max('employees', 'salary', 2);</code></pre>

  <p><b>3rd Maximum:</b></p>
  <pre><code>SELECT find_nth_max('products', 'price', 3);</code></pre>

  <h3>✔ Features</h3>
  <ul>
    <li>Works with any table</li>
    <li>Works with any numeric column</li>
    <li>Uses dynamic SQL (<code>EXECUTE</code> + <code>format()</code>)</li>
    <li>Uses pure math logic instead of ordering</li>
    <li>Safe for SQL injection (uses %I and %L correctly)</li>
  </ul>
</section>

<hr>

<section id="pg-shortcuts">
  <h2>🚀 PostgreSQL Hidden Tricks & Powerful Shortcuts</h2>
  <p>These are advanced functions and features that simplify real-time development work in PostgreSQL.</p>

  <!-- 1 -->
  <h3>1️⃣ <code>COALESCE()</code> — Replace NULL Values</h3>
  <pre><code>SELECT COALESCE(phone, 'No Phone') FROM customers;</code></pre>
  <p>Useful for avoiding multiple CASE expressions.</p>

  <!-- 2 -->
  <h3>2️⃣ <code>NULLIF()</code> — Avoid Divide-by-Zero Errors</h3>
  <pre><code>SELECT amount / NULLIF(quantity, 0) FROM orders;</code></pre>
  <p>Prevents runtime errors by returning NULL when the denominator is zero.</p>

  <!-- 3 -->
  <h3>3️⃣ Generated Columns — Auto-Calculated</h3>
  <pre><code>discounted_price INT GENERATED ALWAYS AS (price - 10) STORED;</code></pre>
  <p>Keeps computed values stored automatically.</p>

  <!-- 4 -->
  <h3>4️⃣ <code>RETURNING</code> — Get Inserted ID Instantly</h3>
  <pre><code>INSERT INTO customers(name, email)
VALUES ('Aathi', 'a@a.com')
RETURNING customerid;</code></pre>
  <p>No need to run an extra query to fetch the last inserted ID.</p>

  <!-- 5 -->
  <h3>5️⃣ <code>unnest()</code> — Convert Array to Rows</h3>
  <pre><code>SELECT unnest(ARRAY[10, 20, 30]);</code></pre>

  <!-- 6 -->
  <h3>6️⃣ <code>string_agg()</code> — Concatenate Values in Groups</h3>
  <pre><code>SELECT dept, string_agg(name, ', ')
FROM employees
GROUP BY dept;</code></pre>

  <!-- 7 -->
  <h3>7️⃣ Convert Rows to JSON — <code>row_to_json()</code></h3>
  <pre><code>SELECT row_to_json(r)
FROM (SELECT id, name FROM customers) r;</code></pre>

  <!-- 8 -->
  <h3>8️⃣ <code>jsonb_set()</code> — Update JSON Field</h3>
  <pre><code>UPDATE users
SET details = jsonb_set(details, '{age}', '25'::jsonb)
WHERE id = 1;</code></pre>

  <!-- 9 -->
  <h3>9️⃣ <code>IS DISTINCT FROM</code> — NULL-Safe Comparison</h3>
  <pre><code>SELECT *
FROM emp
WHERE salary IS DISTINCT FROM previous_salary;</code></pre>

  <!-- 10 -->
  <h3>🔟 <code>generate_series()</code> — Auto Generate Numbers & Dates</h3>

  <h4>Numbers</h4>
  <pre><code>SELECT * FROM generate_series(1, 10);</code></pre>

  <h4>Dates</h4>
  <pre><code>SELECT * FROM generate_series('2024-01-01', '2024-01-10', '1 day');</code></pre>

  <!-- 11 -->
  <h3>1️⃣1️⃣ View Definition — <code>pg_get_viewdef()</code></h3>
  <pre><code>SELECT pg_get_viewdef('myview', true);</code></pre>

  <!-- 12 -->
  <h3>1️⃣2️⃣ Debug SQL in Functions — <code>RAISE NOTICE</code></h3>
  <pre><code>RAISE NOTICE 'Row value: %', val;</code></pre>

  <!-- 13 -->
  <h3>1️⃣3️⃣ Safe Dynamic SQL — <code>EXECUTE ... USING</code></h3>
  <pre><code>EXECUTE 'SELECT * FROM ' || quote_ident(tab)
USING var1;</code></pre>

  <!-- 14 -->
  <h3>1️⃣4️⃣ <code>DISTINCT ON()</code> — Pick First Row Per Group</h3>
  <pre><code>SELECT DISTINCT ON (dept) *
FROM employees
ORDER BY dept, salary DESC;</code></pre>

  <!-- 15 -->
  <h3>1️⃣5️⃣ Conditional Aggregation — <code>FILTER()</code></h3>
  <pre><code>SELECT
  dept,
  COUNT(*) FILTER (WHERE gender='F') AS females,
  COUNT(*) FILTER (WHERE gender='M') AS males
FROM employees
GROUP BY dept;</code></pre>

  <!-- 16 -->
  <h3>1️⃣6️⃣ UPSERT — <code>ON CONFLICT</code></h3>
  <pre><code>INSERT INTO customers(id, name)
VALUES (1, 'Aathi')
ON CONFLICT (id)
DO UPDATE SET name = EXCLUDED.name;</code></pre>

</section>

<hr>

<section id="pg-advanced-procedures">
  <h2>🔥 Advanced PostgreSQL Functions, Procedures & Triggers</h2>
  <p>This section covers complex real-world PL/pgSQL usage with multiple <code>DECLARE</code> variables, nested <code>BEGIN</code>-<code>END</code>, error handling, transactions, dynamic SQL, composite returns, SETOF records, auditing, and multi-step logic.</p>


  <!-- ====================================================== -->
  <!-- 1. TRANSACTIONAL PROCEDURE (BANK TRANSFER) -->
  <!-- ====================================================== -->
  <h3>1️⃣ Bank Transaction Procedure (WITH Transaction, Checks & Errors)</h3>

  <pre><code>
CREATE OR REPLACE PROCEDURE transfer_money(
    p_from INT,
    p_to INT,
    p_amount NUMERIC
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_from_balance NUMERIC;
BEGIN
    -- Lock accounts to prevent race conditions
    SELECT balance INTO v_from_balance
    FROM accounts
    WHERE acc_id = p_from
    FOR UPDATE;

    IF v_from_balance &lt; p_amount THEN
        RAISE EXCEPTION 'Insufficient balance in account %', p_from;
    END IF;

    -- Debit sender
    UPDATE accounts
    SET balance = balance - p_amount
    WHERE acc_id = p_from;

    -- Credit receiver
    UPDATE accounts
    SET balance = balance + p_amount
    WHERE acc_id = p_to;

    -- Log transaction
    INSERT INTO transactions(from_acc, to_acc, amount, ts)
    VALUES (p_from, p_to, p_amount, NOW());

    RAISE NOTICE 'Transfer completed successfully.';
END;
$$;
  </code></pre>


  <!-- ====================================================== -->
  <!-- 2. COMPLEX FUNCTION RETURNING MULTIPLE TYPES -->
  <!-- ====================================================== -->
  <h3>2️⃣ Function Returning <code>SETOF RECORD</code> (Flexible Multi-Column Output)</h3>

  <pre><code>
CREATE OR REPLACE FUNCTION get_employee_details(p_dept TEXT)
RETURNS SETOF RECORD
LANGUAGE plpgsql
AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN 
        SELECT id, name, salary, position
        FROM employees
        WHERE department = p_dept
    LOOP
        RETURN NEXT rec;
    END LOOP;
END;
$$;
  </code></pre>

  <p>Usage:</p>
  <pre><code>
SELECT * FROM get_employee_details('HR') 
AS t(id INT, name TEXT, salary NUMERIC, position TEXT);
  </code></pre>


  <!-- ====================================================== -->
  <!-- 3. RETURNING %ROWTYPE -->
  <!-- ====================================================== -->
  <h3>3️⃣ Function Returning <code>table_name%ROWTYPE</code></h3>

  <pre><code>
CREATE OR REPLACE FUNCTION get_customer(p_id INT)
RETURNS customers%ROWTYPE
LANGUAGE plpgsql
AS $$
DECLARE
    result customers%ROWTYPE;
BEGIN
    SELECT * INTO result
    FROM customers
    WHERE customerid = p_id;

    RETURN result;
END;
$$;
  </code></pre>


  <!-- ====================================================== -->
  <!-- 4. COMPOSITE TYPE + RETURN TYPE -->
  <!-- ====================================================== -->
  <h3>4️⃣ Returning a Custom Composite Type</h3>

  <pre><code>
CREATE TYPE order_summary AS (
    total_orders INT,
    total_amount NUMERIC,
    last_order TIMESTAMP
);
  </code></pre>

  <pre><code>
CREATE OR REPLACE FUNCTION summarize_customer(p_id INT)
RETURNS order_summary
LANGUAGE plpgsql
AS $$
DECLARE
    result order_summary;
BEGIN
    SELECT
        COUNT(*),
        SUM(amount),
        MAX(orderdate)
    INTO result
    FROM orders
    WHERE customerid = p_id;

    RETURN result;
END;
$$;
  </code></pre>


  <!-- ====================================================== -->
  <!-- 5. DYNAMIC SQL + FORMAT + EXECUTE + USING -->
  <!-- ====================================================== -->
  <h3>5️⃣ Dynamic SQL with <code>EXECUTE</code>, <code>FORMAT</code> &amp; <code>USING</code></h3>

  <pre><code>
CREATE OR REPLACE FUNCTION get_max_value(p_table TEXT, p_column TEXT)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
    result NUMERIC;
    sql TEXT;
BEGIN
    sql := format(
        'SELECT MAX(%I) FROM %I',
        p_column, p_table
    );

    EXECUTE sql INTO result;
    RETURN result;
END;
$$;
  </code></pre>


  <!-- ====================================================== -->
  <!-- 6. ERROR HANDLING + EXCEPTION BLOCK -->
  <!-- ====================================================== -->
  <h3>6️⃣ Error Handling Using <code>EXCEPTION</code></h3>

  <pre><code>
CREATE OR REPLACE FUNCTION safe_division(a NUMERIC, b NUMERIC)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
    result NUMERIC;
BEGIN
    result := a / b;
    RETURN result;

EXCEPTION WHEN division_by_zero THEN
    RAISE NOTICE 'Error: divide by zero!';
    RETURN NULL;
END;
$$;
  </code></pre>


  <!-- ====================================================== -->
  <!-- 7. MULTI-LEVEL BEGIN BLOCKS -->
  <!-- ====================================================== -->
  <h3>7️⃣ Nested <code>BEGIN</code> Blocks (Local Scopes)</h3>

  <pre><code>
CREATE OR REPLACE FUNCTION nested_example()
RETURNS TEXT
AS $$
DECLARE
    x INT := 10;
BEGIN
    BEGIN
        DECLARE x INT := 20;
        RAISE NOTICE 'Inner x = %', x;
    END;

    RAISE NOTICE 'Outer x = %', x;
    RETURN 'Done';
END;
$$ LANGUAGE plpgsql;
  </code></pre>


  <!-- ====================================================== -->
  <!-- 8. COMPLEX TRIGGER (AUDIT LOGGING + PREVENT UPDATES) -->
  <!-- ====================================================== -->
  <h3>8️⃣ Before Update Trigger with Audit &amp; Validation</h3>

  <pre><code>
CREATE TABLE emp_audit(
    emp_id INT,
    old_salary NUMERIC,
    new_salary NUMERIC,
    changed_on TIMESTAMP
);
  </code></pre>

  <pre><code>
CREATE OR REPLACE FUNCTION audit_salary()
RETURNS TRIGGER
AS $$
BEGIN
    IF NEW.salary &lt; OLD.salary THEN
        RAISE EXCEPTION 'Salary cannot be reduced!';
    END IF;

    INSERT INTO emp_audit(emp_id, old_salary, new_salary, changed_on)
    VALUES (OLD.id, OLD.salary, NEW.salary, NOW());

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <pre><code>
CREATE TRIGGER trg_salary_update
BEFORE UPDATE ON employees
FOR EACH ROW
EXECUTE FUNCTION audit_salary();
  </code></pre>


  <!-- ====================================================== -->
  <!-- 9. TRIGGER FOR BALANCE VALIDATION ON EVERY TRANSACTION -->
  <!-- ====================================================== -->
  <h3>9️⃣ Trigger to Prevent Account Going Negative</h3>

  <pre><code>
CREATE OR REPLACE FUNCTION prevent_negative_balance()
RETURNS TRIGGER
AS $$
BEGIN
    IF NEW.balance &lt; 0 THEN
        RAISE EXCEPTION 'Account balance cannot be negative!';
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_balance
BEFORE UPDATE ON accounts
FOR EACH ROW
EXECUTE FUNCTION prevent_negative_balance();
  </code></pre>


  <!-- ====================================================== -->
  <!-- 10. TRIGGER FOR AUTO-STOCK REDUCTION -->
  <!-- ====================================================== -->
  <h3>🔟 After-Insert Trigger to Reduce Stock Automatically</h3>

  <pre><code>
CREATE OR REPLACE FUNCTION reduce_stock()
RETURNS TRIGGER
AS $$
BEGIN
    UPDATE products
    SET stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_reduce_stock
AFTER INSERT ON orderitems
FOR EACH ROW
EXECUTE FUNCTION reduce_stock();
  </code></pre>

</section>

<hr>

<section id="banking-complex">
  <h2>🏦 Complex Banking Schema — Table, Functions, Procedures & Triggers</h2>

  <p>This section creates a realistic <code>bank_accounts</code> table and related tables, then adds functions, procedures and triggers for full lifecycle handling (insert, update, delete, transfer, audit, history, validation).</p>

  <pre><code>-- =========================================================
-- 0. NOTE: run as a superuser/DB owner and create necessary tables
-- =========================================================

-- Customers (minimal)
CREATE TABLE IF NOT EXISTS customers (
  customer_id SERIAL PRIMARY KEY,
  full_name TEXT NOT NULL,
  dob DATE,
  email TEXT UNIQUE,
  phone TEXT,
  kyc_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Branches
CREATE TABLE IF NOT EXISTS branches (
  branch_id SERIAL PRIMARY KEY,
  branch_name TEXT,
  branch_code TEXT UNIQUE,
  address TEXT
);

-- Main Bank Accounts table (complex)
CREATE TABLE IF NOT EXISTS bank_accounts (
  acc_id BIGSERIAL PRIMARY KEY,
  customer_id INT REFERENCES customers(customer_id) ON DELETE RESTRICT,
  acc_number TEXT UNIQUE NOT NULL,
  acc_type TEXT NOT NULL,               -- e.g. savings, current, loan
  currency TEXT DEFAULT 'INR',
  balance NUMERIC(18,2) DEFAULT 0,
  overdraft_limit NUMERIC(18,2) DEFAULT 0,
  interest_rate NUMERIC(5,3) DEFAULT 0, -- percent e.g. 3.500
  daily_withdrawal_limit NUMERIC(18,2) DEFAULT 50000,
  status TEXT DEFAULT 'active',         -- active, blocked, closed
  kyc_required BOOLEAN DEFAULT TRUE,
  kyc_verified BOOLEAN DEFAULT FALSE,
  branch_id INT REFERENCES branches(branch_id),
  opened_on DATE DEFAULT CURRENT_DATE,
  closed_on DATE,
  last_tx_id BIGINT,
  metadata JSONB DEFAULT '{}'::jsonb,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Transactions table (ledger)
CREATE TABLE IF NOT EXISTS transactions (
  tx_id BIGSERIAL PRIMARY KEY,
  acc_id BIGINT REFERENCES bank_accounts(acc_id) ON DELETE CASCADE,
  tx_type TEXT NOT NULL,    -- credit, debit, fee, interest
  amount NUMERIC(18,2) NOT NULL,
  balance_after NUMERIC(18,2),
  related_acc BIGINT,       -- other account for transfer, nullable
  remark TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Accounts history (versioning)
CREATE TABLE IF NOT EXISTS accounts_history (
  hist_id BIGSERIAL PRIMARY KEY,
  acc_id BIGINT,
  changed_by TEXT,
  change_type TEXT,        -- insert, update, delete
  old_data JSONB,
  new_data JSONB,
  changed_at TIMESTAMP DEFAULT NOW()
);

-- Audit logs
CREATE TABLE IF NOT EXISTS audit_logs (
  audit_id BIGSERIAL PRIMARY KEY,
  source_table TEXT,
  source_id BIGINT,
  action TEXT,
  details JSONB,
  created_at TIMESTAMP DEFAULT NOW()
);

-- =========================================================
-- 1. Helper functions
-- =========================================================

-- Function: upsert_accounts_updated_at (trigger helper)
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Function: log_audit (generic audit insertion)
CREATE OR REPLACE FUNCTION log_audit(p_table TEXT, p_id BIGINT, p_action TEXT, p_details JSONB)
RETURNS VOID AS $$
BEGIN
  INSERT INTO audit_logs(source_table, source_id, action, details)
  VALUES (p_table, p_id, p_action, p_details);
END;
$$ LANGUAGE plpgsql;

-- =========================================================
-- 2. Triggers: BEFORE INSERT validations, AFTER INSERT actions
-- =========================================================

-- BEFORE INSERT: validate KYC and generate acc_number if missing
CREATE OR REPLACE FUNCTION trg_before_insert_bank_account()
RETURNS TRIGGER AS $$
DECLARE
  gen_acc TEXT;
BEGIN
  -- If KYC required but customer not verified, raise exception
  IF NEW.kyc_required AND NOT (SELECT kyc_verified FROM customers WHERE customer_id = NEW.customer_id) THEN
    RAISE EXCEPTION 'KYC not completed for customer %', NEW.customer_id;
  END IF;

  -- Generate account number if not provided: BRANCHCODE-YYYYMMDD-XXXX
  IF NEW.acc_number IS NULL OR trim(NEW.acc_number) = '' THEN
    gen_acc := concat(
      COALESCE((SELECT branch_code FROM branches WHERE branch_id = NEW.branch_id), 'BR'),
      '-', to_char(NOW(), 'YYYYMMDD'),
      '-', lpad((nextval('bank_acc_number_seq')::text), 6, '0')
    );
    NEW.acc_number := gen_acc;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create sequence for acc numbers
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'bank_acc_number_seq') THEN
    CREATE SEQUENCE bank_acc_number_seq START 1;
  END IF;
END$$;

CREATE TRIGGER bank_account_before_insert
BEFORE INSERT ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_before_insert_bank_account();

-- AFTER INSERT: create initial opening transaction & history & audit
CREATE OR REPLACE FUNCTION trg_after_insert_bank_account()
RETURNS TRIGGER AS $$
DECLARE
  opening_amount NUMERIC := COALESCE(NEW.balance, 0);
  txid BIGINT;
BEGIN
  -- Create opening transaction if balance > 0
  IF opening_amount > 0 THEN
    INSERT INTO transactions(acc_id, tx_type, amount, balance_after, remark)
    VALUES (NEW.acc_id, 'credit', opening_amount, opening_amount, 'Opening balance')
    RETURNING tx_id INTO txid;

    -- attach last_tx_id
    UPDATE bank_accounts SET last_tx_id = txid WHERE acc_id = NEW.acc_id;
  END IF;

  -- Insert into accounts_history
  INSERT INTO accounts_history(acc_id, changed_by, change_type, old_data, new_data)
  VALUES (NEW.acc_id, 'system', 'insert', NULL, row_to_json(NEW));

  -- Audit log
  PERFORM log_audit('bank_accounts', NEW.acc_id, 'insert', row_to_json(NEW));

  RETURN NULL; -- AFTER ROW trigger return value ignored
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bank_account_after_insert
AFTER INSERT ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_after_insert_bank_account();

-- =========================================================
-- 3. BEFORE UPDATE: prevent negative balance (unless overdraft)
--    and record history & audit AFTER update
-- =========================================================

CREATE OR REPLACE FUNCTION trg_before_update_bank_account()
RETURNS TRIGGER AS $$
BEGIN
  -- prevent turning active -> closed without clearing balance
  IF NEW.status = 'closed' AND COALESCE(NEW.balance,0) > 0 THEN
    RAISE EXCEPTION 'Cannot close account % with positive balance %', NEW.acc_id, NEW.balance;
  END IF;

  -- prevent negative balance beyond overdraft_limit
  IF NEW.balance < -COALESCE(NEW.overdraft_limit, 0) THEN
    RAISE EXCEPTION 'Balance % violates overdraft limit for account %', NEW.balance, NEW.acc_id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bank_account_before_update
BEFORE UPDATE ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_before_update_bank_account();

-- AFTER UPDATE: save history and audit, update updated_at via set_updated_at trigger (BEFORE)
CREATE OR REPLACE FUNCTION trg_after_update_bank_account()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO accounts_history(acc_id, changed_by, change_type, old_data, new_data)
  VALUES (NEW.acc_id, COALESCE(current_setting('app.current_user', true), 'unknown'), 'update', row_to_json(OLD), row_to_json(NEW));

  PERFORM log_audit('bank_accounts', NEW.acc_id, 'update', json_build_object('old', row_to_json(OLD), 'new', row_to_json(NEW)));

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bank_account_after_update
AFTER UPDATE ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_after_update_bank_account();

-- Attach set_updated_at BEFORE trigger (to maintain updated_at automatically)
CREATE TRIGGER set_updated_at_before_update
BEFORE UPDATE ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION set_updated_at();

-- =========================================================
-- 4. BEFORE DELETE: prevent hard delete if balance non-zero; use soft-delete instead
--    AFTER DELETE: log deletion to history & audit (if allowed)
-- =========================================================

CREATE OR REPLACE FUNCTION trg_before_delete_bank_account()
RETURNS TRIGGER AS $$
BEGIN
  IF COALESCE(OLD.balance,0) <> 0 THEN
    RAISE EXCEPTION 'Cannot delete account % with non-zero balance %', OLD.acc_id, OLD.balance;
  END IF;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bank_account_before_delete
BEFORE DELETE ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_before_delete_bank_account();

CREATE OR REPLACE FUNCTION trg_after_delete_bank_account()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO accounts_history(acc_id, changed_by, change_type, old_data, new_data)
  VALUES (OLD.acc_id, COALESCE(current_setting('app.current_user', true), 'unknown'), 'delete', row_to_json(OLD), NULL);

  PERFORM log_audit('bank_accounts', OLD.acc_id, 'delete', row_to_json(OLD));

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER bank_account_after_delete
AFTER DELETE ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_after_delete_bank_account();

-- =========================================================
-- 5. PROCEDURE: Transfer Money (transactional, locks, audit)
-- =========================================================

CREATE OR REPLACE PROCEDURE proc_transfer_money(p_from BIGINT, p_to BIGINT, p_amount NUMERIC, p_by TEXT)
LANGUAGE plpgsql
AS $$
DECLARE
  v_from_balance NUMERIC;
  v_to_balance NUMERIC;
  v_from_acc RECORD;
  v_to_acc RECORD;
  v_tx_from BIGINT;
  v_tx_to BIGINT;
BEGIN
  IF p_from = p_to THEN
    RAISE EXCEPTION 'Source and destination accounts cannot be the same';
  END IF;

  -- Lock both account rows in a fixed order to avoid deadlocks
  IF p_from < p_to THEN
    SELECT * INTO v_from_acc FROM bank_accounts WHERE acc_id = p_from FOR UPDATE;
    SELECT * INTO v_to_acc FROM bank_accounts WHERE acc_id = p_to FOR UPDATE;
  ELSE
    SELECT * INTO v_to_acc FROM bank_accounts WHERE acc_id = p_to FOR UPDATE;
    SELECT * INTO v_from_acc FROM bank_accounts WHERE acc_id = p_from FOR UPDATE;
  END IF;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Account not found';
  END IF;

  v_from_balance := COALESCE(v_from_acc.balance,0);
  v_to_balance := COALESCE(v_to_acc.balance,0);

  IF v_from_balance + COALESCE(v_from_acc.overdraft_limit,0) < p_amount THEN
    RAISE EXCEPTION 'Insufficient funds (including overdraft) in account %', p_from;
  END IF;

  -- Debit
  UPDATE bank_accounts
  SET balance = balance - p_amount
  WHERE acc_id = p_from
  RETURNING balance INTO v_from_balance;

  -- Credit
  UPDATE bank_accounts
  SET balance = balance + p_amount
  WHERE acc_id = p_to
  RETURNING balance INTO v_to_balance;

  -- Insert transaction records
  INSERT INTO transactions(acc_id, tx_type, amount, balance_after, related_acc, remark)
  VALUES (p_from, 'debit', p_amount, v_from_balance, p_to, concat('Transfer to ', p_to, ' by ', p_by))
  RETURNING tx_id INTO v_tx_from;

  INSERT INTO transactions(acc_id, tx_type, amount, balance_after, related_acc, remark)
  VALUES (p_to, 'credit', p_amount, v_to_balance, p_from, concat('Transfer from ', p_from, ' by ', p_by))
  RETURNING tx_id INTO v_tx_to;

  -- Update last_tx_id for both accounts
  UPDATE bank_accounts SET last_tx_id = v_tx_from WHERE acc_id = p_from;
  UPDATE bank_accounts SET last_tx_id = v_tx_to WHERE acc_id = p_to;

  -- History & Audit
  INSERT INTO accounts_history(acc_id, changed_by, change_type, old_data, new_data)
  VALUES (p_from, p_by, 'transfer-debit', NULL, json_build_object('amount', p_amount, 'to', p_to, 'balance_after', v_from_balance));

  INSERT INTO accounts_history(acc_id, changed_by, change_type, old_data, new_data)
  VALUES (p_to, p_by, 'transfer-credit', NULL, json_build_object('amount', p_amount, 'from', p_from, 'balance_after', v_to_balance));

  PERFORM log_audit('transactions', v_tx_from, 'insert', json_build_object('from', p_from,'to', p_to,'amount', p_amount, 'by', p_by));

  RAISE NOTICE 'Transfer of % completed from % to %', p_amount, p_from, p_to;
END;
$$;

-- =========================================================
-- 6. FUNCTION: adjust_balance (for fees, interest, admin)
-- =========================================================

CREATE OR REPLACE FUNCTION fn_adjust_balance(p_acc BIGINT, p_delta NUMERIC, p_type TEXT, p_remark TEXT)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
  v_new_balance NUMERIC;
BEGIN
  UPDATE bank_accounts
  SET balance = balance + p_delta
  WHERE acc_id = p_acc
  RETURNING balance INTO v_new_balance;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Account % not found', p_acc;
  END IF;

  INSERT INTO transactions(acc_id, tx_type, amount, balance_after, remark)
  VALUES (p_acc, p_type, p_delta, v_new_balance, p_remark);

  PERFORM log_audit('bank_accounts', p_acc, 'adjust_balance', json_build_object('delta', p_delta, 'remark', p_remark));

  RETURN v_new_balance;
END;
$$;

-- =========================================================
-- 7. UTILITY: function to fetch nth max balance (user asked earlier)
-- =========================================================

CREATE OR REPLACE FUNCTION find_nth_max_balance(p_n INT)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
  res NUMERIC;
  q TEXT;
BEGIN
  q := format($f$SELECT t1.balance
               FROM bank_accounts t1
               WHERE (%s - 1) = (
                 SELECT COUNT(DISTINCT t2.balance)
                 FROM bank_accounts t2
                 WHERE t2.balance > t1.balance
               )$f$, p_n);

  EXECUTE q INTO res;
  RETURN res;
END;
$$;

-- =========================================================
-- 8. EXAMPLE: set current app user (optional)
-- =========================================================
-- You can set a session variable to capture who performed the change,
-- e.g. SELECT set_config('app.current_user','alice', true);

-- =========================================================
-- 9. INDEXES (performance)
-- =========================================================
CREATE INDEX IF NOT EXISTS idx_bank_acc_customer ON bank_accounts(customer_id);
CREATE INDEX IF NOT EXISTS idx_bank_acc_accnumber ON bank_accounts(acc_number);
CREATE INDEX IF NOT EXISTS idx_transactions_acc ON transactions(acc_id);
CREATE INDEX IF NOT EXISTS idx_accounts_history_acc ON accounts_history(acc_id);

-- =========================================================
-- 10. SAMPLE USAGE (examples)
-- =========================================================
-- Insert customer
-- INSERT INTO customers(full_name, dob, email, kyc_verified) VALUES ('Aathi P', '1998-01-01', 'a@a.com', true);

-- Create account
-- INSERT INTO bank_accounts(customer_id, branch_id, acc_type, balance) VALUES (1, 1, 'savings', 10000);

-- Transfer (call procedure)
-- CALL proc_transfer_money(1,2,500,'admin_user');

-- Adjust balance (fees)
-- SELECT fn_adjust_balance(1, -100, 'fee', 'ATM withdrawal fee');

</code></pre>

  <p>Notes:</p>
  <ul>
    <li>This design uses row-level triggers and an accounts history table to keep audit/version history.</li>
    <li>Procedures use explicit row locking (<code>FOR UPDATE</code>) to avoid race conditions.</li>
    <li>Exceptions prevent invalid operations (e.g., closing account with positive balance, overdraft violations).</li>
    <li>You can set a session variable <code>app.current_user</code> to track actor names in history/audit entries.</li>
  </ul>
</section>


<hr>


<section id="complex-cursor">
  <h2>🌀 Complex Cursor Example – Fix Negative Balances</h2>

  <p>
    This example uses a real-world banking scenario. Some accounts may become temporarily 
    negative due to incorrect entries or system errors. The cursor automatically:
  </p>

  <ul>
    <li>Finds all negative-balance accounts</li>
    <li>Applies a penalty fee</li>
    <li>Updates the balance</li>
    <li>Inserts a correction transaction</li>
    <li>Logs the change in <code>accounts_history</code></li>
    <li>Creates an entry in <code>audit_logs</code></li>
  </ul>

  <h3>📌 Function with Complex Cursor</h3>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION fix_negative_balances()
RETURNS void AS $$
DECLARE
    -- Cursor to fetch accounts with negative balance
    cur_negative_accounts CURSOR FOR 
        SELECT account_id, customer_id, balance
        FROM bank_accounts
        WHERE balance &lt; 0;

    -- Variables to hold cursor data
    v_acc_id INT;
    v_cust_id INT;
    v_balance NUMERIC;

    -- Penalty fee
    v_penalty NUMERIC := 250.00;

    -- New calculated balance
    v_new_balance NUMERIC;

BEGIN
    RAISE NOTICE 'Starting negative balance fix process...';

    -- Open cursor
    OPEN cur_negative_accounts;

    LOOP
        -- Fetch row into variables
        FETCH cur_negative_accounts INTO v_acc_id, v_cust_id, v_balance;

        EXIT WHEN NOT FOUND;  -- stop when no more rows

        RAISE NOTICE 'Processing account: %, balance: %', v_acc_id, v_balance;

        -- Calculate corrected balance
        v_new_balance := v_balance - v_penalty;

        -- Step 1: Update account balance
        UPDATE bank_accounts
        SET balance = v_new_balance,
            updated_at = NOW()
        WHERE account_id = v_acc_id;

        -- Step 2: Insert transaction entry
        INSERT INTO transactions(account_id, amount, type, remarks)
        VALUES (v_acc_id, -v_penalty, 'penalty', 'Auto penalty for negative balance correction');

        -- Step 3: Insert into account_history
        INSERT INTO accounts_history(account_id, old_balance, new_balance)
        VALUES (v_acc_id, v_balance, v_new_balance);

        -- Step 4: Audit log entry
        INSERT INTO audit_logs(account_id, action, old_balance, new_balance)
        VALUES (v_acc_id, 'NEGATIVE_BALANCE_FIXED', v_balance, v_new_balance);

        RAISE NOTICE 'Updated account %, Old Balance %, New Balance %',
            v_acc_id, v_balance, v_new_balance;

    END LOOP;

    -- Close cursor
    CLOSE cur_negative_accounts;

    RAISE NOTICE 'Negative balance corrections completed.';
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <h3>🧪 Testing the Cursor</h3>

  <pre><code class="language-sql">
-- Check negative accounts
SELECT * FROM bank_accounts WHERE balance &lt; 0;

-- Run cursor function
SELECT fix_negative_balances();

-- Verify updates
SELECT * FROM bank_accounts;
SELECT * FROM transactions WHERE type = 'penalty';
SELECT * FROM accounts_history;
SELECT * FROM audit_logs WHERE action = 'NEGATIVE_BALANCE_FIXED';
  </code></pre>

  <h3>📘 Summary</h3>
  <p>This example demonstrates:</p>

  <ul>
    <li>Advanced use of <strong>CURSOR</strong></li>
    <li>Multiple-table updates inside the loop</li>
    <li>Real-world banking automation</li>
    <li>Logging and history tracking</li>
  </ul>

</section>

<hr>

<section id="psql-cursors">
  <h1>🌀 PostgreSQL Cursors — Complete Guide (Beginner to Advanced)</h1>

  <p>
    A <strong>cursor</strong> in PostgreSQL is a database mechanism that allows you to 
    <strong>fetch rows one-by-one</strong> from a query instead of getting all rows at once.
    This is useful for:
  </p>

  <ul>
    <li>Processing data row-by-row</li>
    <li>Complex business logic</li>
    <li>Multi-step calculations</li>
    <li>Large datasets that cannot be loaded in memory</li>
    <li>Triggers and batch jobs</li>
  </ul>

  <hr/>

  <h2>📌 1. Cursor Basic Concepts</h2>

  <ul>
    <li><strong>DECLARE</strong>: create cursor</li>
    <li><strong>OPEN</strong>: open cursor and execute query</li>
    <li><strong>FETCH</strong>: get next row into variables</li>
    <li><strong>LOOP</strong> with <strong>EXIT WHEN NOT FOUND</strong>: break when done</li>
    <li><strong>CLOSE</strong>: release cursor</li>
  </ul>

  <pre><code class="language-sql">
DECLARE
   cursor_name CURSOR FOR SQL_QUERY;
BEGIN
   OPEN cursor_name;
   FETCH cursor_name INTO variables;
   CLOSE cursor_name;
END;
  </code></pre>

  <hr/>

  <h2>📌 2. Simple Cursor Example</h2>

  <p>This cursor prints all customer names.</p>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION print_customers()
RETURNS void AS $$
DECLARE
    cur CURSOR FOR SELECT name FROM customers;
    v_name TEXT;
BEGIN
    OPEN cur;

    LOOP
        FETCH cur INTO v_name;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Customer: %', v_name;
    END LOOP;

    CLOSE cur;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <h3>🔍 Explanation (line-by-line)</h3>

  <ul>
    <li><strong>DECLARE cur CURSOR FOR</strong> → defines cursor</li>
    <li><strong>OPEN cur</strong> → runs the SELECT query</li>
    <li><strong>FETCH</strong> → retrieves 1 row to <code>v_name</code></li>
    <li><strong>EXIT WHEN NOT FOUND</strong> → stop loop when no more rows</li>
    <li><strong>CLOSE cur</strong> → releases memory</li>
  </ul>

  <hr/>

  <h2>📌 3. Medium-Level Cursor — Process Data</h2>

  <p>This cursor increases all customer credit score by +5.</p>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION increase_credit_score()
RETURNS void AS $$
DECLARE
    cur CURSOR FOR SELECT customer_id, credit_score FROM customers;
    v_id INT;
    v_score INT;
BEGIN
    OPEN cur;

    LOOP
        FETCH cur INTO v_id, v_score;
        EXIT WHEN NOT FOUND;

        UPDATE customers
        SET credit_score = v_score + 5
        WHERE customer_id = v_id;

        RAISE NOTICE 'Updated %, New Score = %', v_id, v_score + 5;
    END LOOP;

    CLOSE cur;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <hr/>

  <h2>📌 4. Complex Cursor (Banking Example)</h2>

  <p>This cursor finds all accounts with negative balance and applies a penalty.</p>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION fix_negative_balances()
RETURNS void AS $$
DECLARE
    cur_negative CURSOR FOR 
        SELECT account_id, balance FROM bank_accounts WHERE balance &lt; 0;

    v_acc INT;
    v_bal NUMERIC;
    v_penalty NUMERIC := 250;
    v_new NUMERIC;
BEGIN
    OPEN cur_negative;

    LOOP
        FETCH cur_negative INTO v_acc, v_bal;
        EXIT WHEN NOT FOUND;

        v_new := v_bal - v_penalty;

        UPDATE bank_accounts
        SET balance = v_new
        WHERE account_id = v_acc;

        INSERT INTO transactions(account_id, amount, type)
        VALUES (v_acc, -v_penalty, 'penalty');

        INSERT INTO audit_logs(account_id, action, old_balance, new_balance)
        VALUES (v_acc, 'NEGATIVE_BALANCE_FIXED', v_bal, v_new);

        RAISE NOTICE 'Account % fixed from % to %', v_acc, v_bal, v_new;
    END LOOP;

    CLOSE cur_negative;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <hr/>

  <h2>📌 5. Cursor with <code>FOR record IN cursor</code> Loop</h2>

  <p>This cursor type is cleaner and does not require OPEN, FETCH, or CLOSE manually.</p>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION print_large_accounts()
RETURNS void AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN SELECT account_id, balance FROM bank_accounts WHERE balance &gt; 100000 LOOP
        RAISE NOTICE 'Account %, Balance %', rec.account_id, rec.balance;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <h3>✨ No OPEN/FETCH/CLOSE needed.</h3>

  <hr/>

  <h2>📌 6. Dynamic SQL Cursor (Advanced)</h2>

  <p>This cursor receives table and column names as parameters.</p>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION dynamic_cursor(tab TEXT, col TEXT)
RETURNS void AS $$
DECLARE
    sql_query TEXT;
    cur REFCURSOR;
    v_val TEXT;
BEGIN
    sql_query := format('SELECT %I FROM %I', col, tab);

    OPEN cur FOR EXECUTE sql_query;

    LOOP
        FETCH cur INTO v_val;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Value: %', v_val;
    END LOOP;

    CLOSE cur;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <h3>🎯 Explanation</h3>

  <ul>
    <li><strong>REFCURSOR</strong> = a runtime-created cursor</li>
    <li><code>format()</code> with <strong>%I</strong> escapes identifiers safely</li>
    <li><code>EXECUTE</code> runs dynamic SQL</li>
  </ul>

  <hr/>

  <h2>📌 7. Cursor With Conditions</h2>

  <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION warn_large_withdrawals()
RETURNS void AS $$
DECLARE
    cur CURSOR FOR SELECT account_id, amount FROM transactions WHERE type = 'withdraw';
    v_id INT;
    v_amt NUMERIC;
BEGIN
    OPEN cur;

    LOOP
        FETCH cur INTO v_id, v_amt;
        EXIT WHEN NOT FOUND;

        IF v_amt > 20000 THEN
            RAISE NOTICE 'WARNING: Account %, withdrew %', v_id, v_amt;
        END IF;
    END LOOP;

    CLOSE cur;
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <hr/>

  <h2>📘 Summary — Cursor Types</h2>

  <table border="1" cellpadding="6">
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><strong>Explicit Cursor</strong></td>
      <td>Needs OPEN, FETCH, CLOSE</td>
    </tr>
    <tr>
      <td><strong>Implicit Cursor (FOR IN)</strong></td>
      <td>Automatically loops through rows</td>
    </tr>
    <tr>
      <td><strong>Dynamic Cursor</strong></td>
      <td>Uses EXECUTE for dynamic table/column names</td>
    </tr>
    <tr>
      <td><strong>REFCURSOR</strong></td>
      <td>Cursor returned to the caller</td>
    </tr>
  </table>
</section>

<hr>

<!-- 1. Parameterized Cursors -->
<h2>1. Parameterized Cursors</h2>
<p>Declare a cursor that accepts parameters (available inside DECLARE block). Useful when you want the same cursor shape but different filter values.</p>
<pre><code>CREATE OR REPLACE FUNCTION cur_with_param(min_bal NUMERIC)
RETURNS VOID AS $$
DECLARE
  cur CURSOR (m NUMERIC) FOR
    SELECT acc_id, balance FROM bank_accounts WHERE balance &gt; m;
  v_id BIGINT;
  v_bal NUMERIC;
BEGIN
  OPEN cur(min_bal);
  LOOP
    FETCH cur INTO v_id, v_bal;
    EXIT WHEN NOT FOUND;
    RAISE NOTICE 'Acc % has %', v_id, v_bal;
  END LOOP;
  CLOSE cur;
END;
$$ LANGUAGE plpgsql;

-- Usage: SELECT cur_with_param(10000);</code></pre>
<p class="note">Note: The parameter name in DECLARE (m) is bound when OPEN cur(value) is called.</p>

<!-- 2. SCROLL and NO SCROLL -->
<h2>2. SCROLL / NO SCROLL Cursors (Random access)</h2>
<p>SCROLL cursors allow FETCH PRIOR, FIRST, LAST, ABSOLUTE, RELATIVE. NO SCROLL is default and only supports NEXT/FORWARD. SCROLL needs extra resources (materialization).</p>
<pre><code>-- SCROLL cursor example
CREATE OR REPLACE FUNCTION demo_scroll()
RETURNS VOID AS $$
DECLARE
  cur SCROLL CURSOR FOR SELECT acc_id, balance FROM bank_accounts ORDER BY acc_id;
  v_id BIGINT; v_bal NUMERIC;
BEGIN
  OPEN cur;
  FETCH ABSOLUTE 1 FROM cur INTO v_id, v_bal;  -- first row
  RAISE NOTICE 'First: % %', v_id, v_bal;
  FETCH LAST FROM cur INTO v_id, v_bal;         -- last row
  RAISE NOTICE 'Last: % %', v_id, v_bal;
  CLOSE cur;
END;
$$ LANGUAGE plpgsql;</code></pre>
<p class="note">Use SCROLL only when you need random access; it may spill to disk for very large cursors.</p>

<!-- 3. FETCH Variations -->
<h2>3. FETCH Variations (NEXT, PRIOR, ABSOLUTE, RELATIVE, FORWARD n)</h2>
<p>List of common fetch forms with examples.</p>
<pre><code>-- FETCH NEXT (default)
FETCH NEXT FROM cur INTO ...;

-- FETCH PRIOR
FETCH PRIOR FROM cur INTO ...;

-- FETCH ABSOLUTE n
FETCH ABSOLUTE 5 FROM cur INTO ...;   -- 5th row

-- FETCH RELATIVE -2
FETCH RELATIVE -2 FROM cur INTO ...;  -- move backward 2 rows

-- FETCH FORWARD 10
FETCH FORWARD 10 FROM cur INTO ...;   -- fetch next 10 rows at once</code></pre>
<p class="note">When using FORWARD n you get up to n rows; for large volumes prefer batch fetch sizes (e.g., 1000).</p>

<!-- 4. REFCURSOR -->
<h2>4. REFCURSOR (Return cursor to client/app)</h2>
<p>REFCURSOR lets a function open a cursor and return the cursor name to the client application which can then FETCH from it. Useful for client-side paging or streaming.</p>
<pre><code>CREATE OR REPLACE FUNCTION get_accounts_refcursor(min_bal NUMERIC)
RETURNS REFCURSOR AS $$
DECLARE
  ref REFCURSOR;
BEGIN
  OPEN ref FOR SELECT acc_id, acc_number, balance FROM bank_accounts WHERE balance &gt; min_bal;
  RETURN ref; -- client must FETCH from the returned cursor
END;
$$ LANGUAGE plpgsql;

-- Usage from psql:
-- BEGIN; 
-- SELECT get_accounts_refcursor(1000) AS curname; 
-- FETCH 50 FROM "<cursor name returned>"; 
-- CLOSE "<cursor name>"; 
-- COMMIT;</code></pre>
<p class="note">REFCURSORs are session-scoped; open transaction and close cursor when done. Useful with server-side drivers (libpq).</p>

<!-- 5. Dynamic Cursor with Parameters -->
<h2>5. Dynamic Cursor with Parameters (dynamic SQL + REFCURSOR)</h2>
<p>Combine dynamic SQL and refcursor to let caller choose table/column and filters.</p>
<pre><code>CREATE OR REPLACE FUNCTION dynamic_refcursor(p_table TEXT, p_col TEXT, p_min NUMERIC)
RETURNS REFCURSOR AS $$
DECLARE
  ref REFCURSOR;
  sql TEXT;
BEGIN
  sql := format('SELECT %I, %I FROM %I WHERE %I &gt; %s', 'acc_id', p_col, p_table, p_col, p_min);
  OPEN ref FOR EXECUTE sql;
  RETURN ref;
END;
$$ LANGUAGE plpgsql;

-- Example: SELECT dynamic_refcursor('bank_accounts','balance',1000);</code></pre>
<p class="note">Use %I for identifiers and %s for numeric; avoid %L when building numeric expressions.</p>

<!-- 6. Cursor with Exception Handling -->
<h2>6. Cursor with Exception Handling (robust loops)</h2>
<p>Wrap OPEN/FETCH loop in BEGIN...EXCEPTION to handle errors, ensure cursor is closed on failure.</p>
<pre><code>CREATE OR REPLACE FUNCTION safe_cursor_fix()
RETURNS VOID AS $$
DECLARE
  cur CURSOR FOR SELECT acc_id, balance FROM bank_accounts WHERE balance &lt; 0;
  v_id BIGINT; v_bal NUMERIC;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_id, v_bal;
    EXIT WHEN NOT FOUND;
    -- risky operation
    BEGIN
      UPDATE bank_accounts SET balance = balance - 100 WHERE acc_id = v_id;
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'Failed update for % : %', v_id, SQLERRM;
      -- continue with next row
    END;
  END LOOP;
  CLOSE cur;
EXCEPTION WHEN OTHERS THEN
  -- ensure close on unexpected failure
  IF FOUND THEN CLOSE cur; END IF;
  RAISE;
END;
$$ LANGUAGE plpgsql;</code></pre>
<p class="note">Always ensure cursors are closed in EXCEPTION path to avoid leaks.</p>

<!-- 7. SAVEPOINT / ROLLBACK inside Cursor -->
<h2>7. SAVEPOINT / ROLLBACK in Cursor Loops (partial rollback)</h2>
<p>Use SAVEPOINT to rollback changes for a single row while continuing the loop for others.</p>
<pre><code>CREATE OR REPLACE PROCEDURE process_with_savepoint()
LANGUAGE plpgsql
AS $$
DECLARE
  cur CURSOR FOR SELECT acc_id, balance FROM bank_accounts;
  v_id BIGINT; v_bal NUMERIC;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_id, v_bal;
    EXIT WHEN NOT FOUND;
    SAVEPOINT sp;
    BEGIN
      -- attempt potentially failing operation
      PERFORM some_risky_operation(v_id);
      RELEASE SAVEPOINT sp;
    EXCEPTION WHEN OTHERS THEN
      ROLLBACK TO SAVEPOINT sp; -- undo this row's changes only
      RAISE NOTICE 'Rolled back for % due to %', v_id, SQLERRM;
    END;
  END LOOP;
  CLOSE cur;
END;
$$;</code></pre>
<p class="note">SAVEPOINTs are available inside procedures (not functions) where you can manage transactions.</p>

<!-- 8. Nested Cursors -->
<h2>8. Nested Cursors (Cursor inside Cursor)</h2>
<p>Use nested cursors when you need to process parent-child relationships (e.g., customer → accounts → transactions).</p>
<pre><code>CREATE OR REPLACE FUNCTION nested_cursor_example()
RETURNS VOID AS $$
DECLARE
  cur_cust CURSOR FOR SELECT customer_id FROM customers;
  cur_acc CURSOR (c_id INT) FOR SELECT acc_id, balance FROM bank_accounts WHERE customer_id = c_id;
  v_cust INT; v_acc BIGINT; v_bal NUMERIC;
BEGIN
  OPEN cur_cust;
  LOOP
    FETCH cur_cust INTO v_cust;
    EXIT WHEN NOT FOUND;
    OPEN cur_acc(v_cust);
    LOOP
      FETCH cur_acc INTO v_acc, v_bal;
      EXIT WHEN NOT FOUND;
      RAISE NOTICE 'Cust % -> Acc % Balance %', v_cust, v_acc, v_bal;
    END LOOP;
    CLOSE cur_acc;
  END LOOP;
  CLOSE cur_cust;
END;
$$ LANGUAGE plpgsql;</code></pre>
<p class="note">Be careful with performance—nested cursors can be heavy; prefer JOINs when possible.</p>

<!-- 9. Cursor + Trigger -->
<h2>9. Cursor inside Trigger</h2>
<p>Triggers can open cursors (usually FOR EACH STATEMENT triggers) to perform batch checks. Avoid long-running operations inside triggers—keep them short.</p>
<pre><code>-- Example: AFTER DELETE ON customers, check orphan accounts
CREATE OR REPLACE FUNCTION trg_check_orphan_accounts()
RETURNS TRIGGER AS $$
DECLARE
  cur CURSOR FOR SELECT acc_id FROM bank_accounts WHERE customer_id = OLD.customer_id;
  v_acc BIGINT;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_acc; EXIT WHEN NOT FOUND;
    -- take action (send notification or mark account)
    INSERT INTO audit_logs(source_table, source_id, action, details)
      VALUES('bank_accounts', v_acc, 'orphan_check', json_build_object('customer_deleted', OLD.customer_id));
  END LOOP;
  CLOSE cur;
  RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_customer_delete
AFTER DELETE ON customers
FOR EACH ROW
EXECUTE FUNCTION trg_check_orphan_accounts();</code></pre>
<p class="note">Keep trigger actions idempotent and fast; heavy work is better offloaded to background jobs.</p>

<!-- 10. Cursor inside Procedure (transactions allowed) -->
<h2>10. Cursor inside PROCEDURE (useful for transaction control)</h2>
<p>Procedures (CREATE PROCEDURE) allow COMMIT/ROLLBACK inside; functions do not. Use procedures for long-running batch work requiring partial commits.</p>
<pre><code>CREATE OR REPLACE PROCEDURE proc_batch_fix()
LANGUAGE plpgsql
AS $$
DECLARE
  cur CURSOR FOR SELECT acc_id FROM bank_accounts WHERE flag_needs_fix = true;
  v_acc BIGINT;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_acc; EXIT WHEN NOT FOUND;
    BEGIN
      -- start sub-transaction
      SAVEPOINT s1;
      PERFORM fn_fix_account(v_acc);
      RELEASE SAVEPOINT s1;
    EXCEPTION WHEN OTHERS THEN
      ROLLBACK TO SAVEPOINT s1; -- continue next
    END;
  END LOOP;
  CLOSE cur;
END;
$$;</code></pre>
<p class="note">Procedures give more control—use them for ETL or maintenance tasks.</p>

<!-- 11. Cursor returning composite or setof -->
<h2>11. Cursor Returning Composite Types / SETOF</h2>
<p>CURSOR can be used to return a SETOF composite type by looping and RETURN NEXT.</p>
<pre><code>CREATE TYPE acc_summary AS (acc_id BIGINT, balance NUMERIC, tx_count INT);

CREATE OR REPLACE FUNCTION get_accounts_summary()
RETURNS SETOF acc_summary AS $$
DECLARE
  cur CURSOR FOR SELECT acc_id, balance FROM bank_accounts;
  v_acc BIGINT; v_bal NUMERIC; v_cnt INT;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_acc, v_bal; EXIT WHEN NOT FOUND;
    SELECT COUNT(*) INTO v_cnt FROM transactions WHERE acc_id = v_acc;
    RETURN NEXT (v_acc, v_bal, v_cnt);
  END LOOP;
  CLOSE cur;
  RETURN;
END;
$$ LANGUAGE plpgsql;

-- Usage: SELECT * FROM get_accounts_summary();</code></pre>
<p class="note">Returning SETOF lets callers treat function result like a table.</p>

<!-- 12. Cursor + Temporary Tables (staging) -->
<h2>12. Cursor + TEMP Tables for ETL / Staging</h2>
<p>Use temporary tables to collect work results, then swap or bulk apply.</p>
<pre><code>CREATE OR REPLACE PROCEDURE etl_with_cursor()
LANGUAGE plpgsql
AS $$
DECLARE
  cur CURSOR FOR SELECT * FROM external_feed;
  rec RECORD;
BEGIN
  CREATE TEMP TABLE tmp_feed AS SELECT * FROM external_feed LIMIT 0;
  OPEN cur;
  LOOP
    FETCH cur INTO rec; EXIT WHEN NOT FOUND;
    INSERT INTO tmp_feed VALUES (rec.*);
  END LOOP;
  CLOSE cur;

  -- bulk merge from tmp_feed
  INSERT INTO bank_accounts(acc_number, balance)
  SELECT feed_acc, feed_bal FROM tmp_feed
  ON CONFLICT (acc_number) DO UPDATE SET balance = EXCLUDED.balance;
END;
$$;</code></pre>
<p class="note">Temp tables reduce locks on production tables and allow batch processing.</p>

<!-- 13. Cursor + Bulk Operations (batch updates) -->
<h2>13. Cursor + Bulk Operations (FETCH FORWARD n)</h2>
<p>Fetch rows in batches and perform bulk updates/inserts to improve performance.</p>
<pre><code>CREATE OR REPLACE FUNCTION batch_update_balances()
RETURNS VOID AS $$
DECLARE
  cur CURSOR FOR SELECT acc_id, balance FROM bank_accounts WHERE needs_update = true;
  rec RECORD;
  batch_size INT := 500;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur FORWARD batch_size INTO rec;
    EXIT WHEN NOT FOUND;
    -- process batch: collect ids and do UPDATE ... WHERE acc_id IN (...)
    -- example is conceptual: use arrays to collect batch values then update
  END LOOP;
  CLOSE cur;
END;
$$ LANGUAGE plpgsql;</code></pre>
<p class="note">Batch size tuning (100-1000) depends on work_mem and I/O; larger batches reduce round-trips but increase memory.</p>

<!-- 14. Cursor with Locking (FOR UPDATE / SKIP LOCKED) -->
<h2>14. Cursor + Row Locking (FOR UPDATE, SKIP LOCKED)</h2>
<p>Use SKIP LOCKED for worker queues where multiple workers process rows concurrently without conflicts.</p>
<pre><code>CREATE OR REPLACE FUNCTION worker_process_jobs(worker_name TEXT)
RETURNS VOID AS $$
DECLARE
  cur CURSOR FOR
    SELECT job_id FROM jobs WHERE status = 'pending' FOR UPDATE SKIP LOCKED;
  v_job INT;
BEGIN
  OPEN cur;
  LOOP
    FETCH cur INTO v_job; EXIT WHEN NOT FOUND;
    -- process job v_job
    UPDATE jobs SET status='done', processed_by = worker_name WHERE job_id = v_job;
  END LOOP;
  CLOSE cur;
END;
$$ LANGUAGE plpgsql;</code></pre>
<p class="note">FOR UPDATE SKIP LOCKED is ideal for parallel workers and prevents deadlocks.</p>

<!-- 15. Cursor for Streaming Large Data (client-side) -->
<h2>15. Cursor for Streaming Data to Client</h2>
<p>Use REFCURSOR and fetch in small chunks from client library to stream large results without loading all rows into memory.</p>
<pre><code>-- Server: return refcursor
CREATE OR REPLACE FUNCTION stream_accounts()
RETURNS REFCURSOR AS $$
DECLARE ref REFCURSOR;
BEGIN
  OPEN ref FOR SELECT * FROM bank_accounts ORDER BY acc_id;
  RETURN ref;
END;
$$ LANGUAGE plpgsql;

-- Client: FETCH 100 FROM cursor repeatedly until exhausted.</code></pre>
<p class="note">Client libraries (libpq, psql, python psycopg2) support fetching from server-side cursor.</p>

<!-- 16. Portal Cursors (brief) -->
<h2>16. Portal Cursors (internal concept)</h2>
<p>A portal is PostgreSQL's internal name for a cursor execution context. You rarely need to interact with portals directly; client libraries manage them. Knowledge is useful for debugging resource usage.</p>

<!-- 17. Performance, work_mem, and holdability -->
<h2>17. Performance &amp; Tuning</h2>
<ul>
  <li><b>work_mem</b>: large cursors that sort or materialize may use work_mem; increase carefully.</li>
  <li><b>Holdable cursors</b>: Opened inside transaction, can be made HOLDABLE to survive commit (BUT may materialize results).</li>
  <li><b>Materialized cursors</b>: SCROLL or holdable may store results in a temp file if too big.</li>
  <li><b>Avoid long transactions</b>: keep cursor transaction short to reduce lock retention.</li>
</ul>

<pre><code>-- Example setting a holdable cursor
CREATE OR REPLACE FUNCTION ref_hold_example()
RETURNS REFCURSOR AS $$
DECLARE ref REFCURSOR;
BEGIN
  OPEN ref FOR SELECT * FROM bank_accounts; -- default not holdable
  -- to make holdable, open in a transaction and use DECLARE ref CURSOR WITH HOLD FOR ... (psql syntax)
  RETURN ref;
END;
$$ LANGUAGE plpgsql;</code></pre>

<p class="note">Long-running open transactions with cursors can block VACUUM and other operations—use carefully.</p>

<!-- 18. Memory leak & cleanup best practices -->
<h2>18. Best Practices &amp; Pitfalls</h2>
<ul>
  <li>Always CLOSE cursors in normal and exception paths.</li>
  <li>Prefer explicit batch sizes (FETCH FORWARD n) for large sets.</li>
  <li>Use SKIP LOCKED for worker queues to avoid contention.</li>
  <li>Avoid nested cursors over millions of rows; prefer set-based SQL when possible.</li>
  <li>Use procedures if you need SAVEPOINTs and partial commits.</li>
</ul>

<!-- 19. Real-world Banking Use Cases -->
<h2>19. Real-World Banking Use Cases (where advanced cursor features fit)</h2>
<ul>
  <li><b>ETL &amp; Reconciliation:</b> cursor + temp tables to reconcile ledger vs core system.</li>
  <li><b>Worker Queues:</b> FOR UPDATE SKIP LOCKED for parallel transaction processors.</li>
  <li><b>Interest Calculation:</b> batch cursor FORWARD N to compute interest and post transactions.</li>
  <li><b>Fraud Scanning:</b> nested cursors to check customer &amp; account patterns.</li>
  <li><b>Streaming Reports:</b> REFCURSOR to stream large account extracts to reporting system.</li>
</ul>

<!-- 20. Quick Reference Table -->
<h2>20. Quick Reference — Cursor Commands</h2>
<table>
  <tr><th>Command</th><th>Meaning</th></tr>
  <tr><td>DECLARE name CURSOR FOR &lt;query&gt;</td><td>Define a cursor</td></tr>
  <tr><td>OPEN name</td><td>Open cursor and execute query</td></tr>
  <tr><td>FETCH NEXT / FORWARD n / ABSOLUTE n</td><td>Retrieve rows</td></tr>
  <tr><td>CLOSE name</td><td>Close &amp; free resources</td></tr>
  <tr><td>FOR ... IN &lt;query&gt; LOOP</td><td>Implicit cursor loop</td></tr>
  <tr><td>REFCURSOR</td><td>Return cursor to client</td></tr>
</table>

<hr>

<!-- ================= TRIGGER CONTEXT VARIABLES ================= -->
<h1>Trigger Context Variables (TG_*) — Complete Guide</h1>

<p>
PostgreSQL provides <strong>special system variables</strong> inside trigger functions.
These variables start with <code>TG_</code> and give information about:
</p>
<ul>
  <li>Which operation happened (INSERT / UPDATE / DELETE)</li>
  <li>Which table and schema fired the trigger</li>
  <li>Trigger name, timing, and level</li>
  <li>Arguments passed to the trigger</li>
</ul>

<h2>1. List of All Trigger Variables</h2>

<table>
  <tr><th>Variable</th><th>Description</th></tr>
  <tr><td><code>TG_OP</code></td><td>Operation type: INSERT, UPDATE, DELETE, TRUNCATE</td></tr>
  <tr><td><code>TG_TABLE_NAME</code></td><td>Name of the table</td></tr>
  <tr><td><code>TG_TABLE_SCHEMA</code></td><td>Schema name</td></tr>
  <tr><td><code>TG_NAME</code></td><td>Trigger name</td></tr>
  <tr><td><code>TG_WHEN</code></td><td>BEFORE / AFTER / INSTEAD OF</td></tr>
  <tr><td><code>TG_LEVEL</code></td><td>ROW or STATEMENT</td></tr>
  <tr><td><code>TG_NARGS</code></td><td>Number of arguments passed</td></tr>
  <tr><td><code>TG_ARGV[]</code></td><td>Trigger arguments array</td></tr>
  <tr><td><code>OLD</code></td><td>Row before change</td></tr>
  <tr><td><code>NEW</code></td><td>Row after change</td></tr>
</table>

<h2>2. Example Table (Banking)</h2>

<pre><code>CREATE TABLE bank_accounts (
  acc_id SERIAL PRIMARY KEY,
  acc_name TEXT,
  balance NUMERIC
);
</code></pre>

<h2>3. Trigger Function Using ALL TG Variables</h2>

<pre><code>CREATE OR REPLACE FUNCTION trg_audit_all_vars()
RETURNS TRIGGER AS $$
BEGIN
  RAISE NOTICE 'Trigger Name       : %', TG_NAME;
  RAISE NOTICE 'Operation          : %', TG_OP;
  RAISE NOTICE 'Table Name         : %', TG_TABLE_NAME;
  RAISE NOTICE 'Table Schema       : %', TG_TABLE_SCHEMA;
  RAISE NOTICE 'Trigger Timing     : %', TG_WHEN;
  RAISE NOTICE 'Trigger Level      : %', TG_LEVEL;
  RAISE NOTICE 'Arguments Count    : %', TG_NARGS;

  IF TG_NARGS > 0 THEN
    RAISE NOTICE 'First Argument     : %', TG_ARGV[0];
  END IF;

  IF TG_OP = 'INSERT' THEN
    RAISE NOTICE 'NEW Balance        : %', NEW.balance;
    RETURN NEW;

  ELSIF TG_OP = 'UPDATE' THEN
    RAISE NOTICE 'OLD Balance        : %', OLD.balance;
    RAISE NOTICE 'NEW Balance        : %', NEW.balance;
    RETURN NEW;

  ELSIF TG_OP = 'DELETE' THEN
    RAISE NOTICE 'Deleted Balance   : %', OLD.balance;
    RETURN OLD;
  END IF;

  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
</code></pre>

<h2>4. Create Trigger</h2>

<pre><code>CREATE TRIGGER trg_bank_accounts_audit
AFTER INSERT OR UPDATE OR DELETE
ON bank_accounts
FOR EACH ROW
EXECUTE FUNCTION trg_audit_all_vars('BANK_AUDIT');
</code></pre>

<h2>5. Test Operations</h2>

<h3>INSERT</h3>
<pre><code>INSERT INTO bank_accounts(acc_name, balance)
VALUES ('Aathi', 5000);
</code></pre>

<h3>UPDATE</h3>
<pre><code>UPDATE bank_accounts
SET balance = 8000
WHERE acc_id = 1;
</code></pre>

<h3>DELETE</h3>
<pre><code>DELETE FROM bank_accounts
WHERE acc_id = 1;
</code></pre>

<h2>6. Sample Output (NOTICE)</h2>

<pre><code>NOTICE: Trigger Name       : trg_bank_accounts_audit
NOTICE: Operation          : INSERT
NOTICE: Table Name         : bank_accounts
NOTICE: Table Schema       : public
NOTICE: Trigger Timing     : AFTER
NOTICE: Trigger Level      : ROW
NOTICE: Arguments Count    : 1
NOTICE: First Argument     : BANK_AUDIT
NOTICE: NEW Balance        : 5000
</code></pre>

<h2>7. Exam Notes (Very Important)</h2>
<ul>
  <li><code>TG_OP</code> is the MOST asked variable in exams</li>
  <li><code>TG_ARGV[]</code> is used to pass dynamic values to trigger</li>
  <li><code>RETURN NULL</code> is NOT allowed in AFTER triggers</li>
  <li>One trigger can handle INSERT, UPDATE, DELETE using <code>TG_OP</code></li>
</ul>

<h2>8. One-Line Memory Trick</h2>
<p><strong>TG_OP</strong> = What happened<br/>
<strong>TG_TABLE_NAME</strong> = Where it happened<br/>
<strong>OLD / NEW</strong> = Before and after values</p>

</body>
</html>



