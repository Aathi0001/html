<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PSQL</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background-color: #0d1117;
    color: #e6edf3;
    line-height: 1.6;
    padding: 20px;
    max-width: 100%;
  }
  /* Existing styles remain unchanged */
  pre{background: #21262d;color:#aaffaa;padding:12px;border-radius:8px;overflow:auto}
  h1, h2, h3, h4, h5, h6 {
      margin-top: 30px;
      border-left: 5px solid #ff4747;
      padding-left: 12px;
      color: #333;
    }

  h1 {
    color: #f0f6fc;
    font-size: 2em;
    text-align: center;
    margin-top: 40px;
    margin-bottom: 20px;
    border-bottom: 3px solid #30363d;
    padding-bottom: 8px;
  }

  h3 {
    color: #79c0ff;
    font-size: 1.4em;
    margin-top: 25px;
    border-left: 4px solid #30363d;
    padding-left: 10px;
  }

  h4 {
    color: #4bffe7;
    font-size: 1.2em;
    margin-top: 20px;
  }

  h5 {
    color: #a5d6ff;
    font-size: 1.1em;
    margin-top: 15px;
    font-weight: normal;
  }

  h6 {
    color: #8b949e;
    font-size: 1em;
    margin-top: 10px;
    font-weight: normal;
    font-style: italic;
  }
  h2 {
    color: #58a6ff;
    border-bottom: 2px solid #30363d;
    padding-bottom: 4px;
  }
  a {
    color: #79c0ff;
    text-decoration: none;
  }
  a:hover {
    color: #fff;
    text-decoration: underline;
  }
  .index {
    background-color: #161b22;
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 30px;
  }
  .index ul {
    columns: 2;
    list-style-type: none;
    padding-left: 0;
  }
  .index li {
    margin: 6px 0;
  }
  section {
    margin-bottom: 50px;
  }
  code {
    background-color: #21262d;
    padding: 4px 8px;
    border-radius: 6px;
    color: #ffa657;
  }
  table {
    max-width: 100%;
    overflow-x: auto;
    display: block;
    word-wrap: break-word;
}
table { 
    width: 100%; 
    border-collapse: collapse; 
    margin: 15px 0; 
}

th, td { 
    border: 1px solid #ccc; 
    padding: 8px; 
    text-align: left; 
}

th { 
    background: #34495e; 
    color: white; 
}
</style>
</head>
<body>

<section id="introduction">

    <h1>Introduction to PostgreSQL</h1>

    <!-- 1.1 What is PostgreSQL? -->
    <div class="topic">
        <h2>1.1 What is PostgreSQL?</h2>

        <p>
            PostgreSQL (often called <b>Postgres</b>) is an advanced, open-source
            <b>object-relational database management system (ORDBMS)</b>.
            It supports both SQL (relational) and JSON (non-relational) querying.
        </p>

        <ul>
            <li>Free and open-source</li>
            <li>Supports complex queries & advanced data types</li>
            <li>Highly reliable and ACID-compliant</li>
            <li>Used in enterprise applications and production systems</li>
        </ul>
    </div>


    <!-- 1.2 Features -->
    <div class="topic">
        <h2>1.2 Features of PostgreSQL</h2>

        <ul>
            <li><b>Strong ACID compliance</b></li>
            <li><b>Supports JSON, Arrays, HSTORE, UUID</b></li>
            <li><b>Highly extensible</b> (you can create custom functions, data types, operators)</li>
            <li><b>MVCC (Multi-Version Concurrency Control)</b> for fast reads</li>
            <li><b>Full-text search support</b></li>
            <li><b>Advanced indexing</b> (B-tree, Hash, GiST, GIN, BRIN)</li>
            <li><b>Replication support</b></li>
            <li><b>Cross-platform</b> (Windows, Linux, macOS)</li>
        </ul>
    </div>


    <!-- 1.3 Installation and psql -->
    <div class="topic">
        <h2>1.3 Installation & psql Command Line</h2>

        <h3>Install on Windows:</h3>
        <pre>
1. Download installer from: https://www.postgresql.org/download
2. Run installer and select:
   ✔ PostgreSQL Server
   ✔ pgAdmin
   ✔ Command Line Tools (psql)
3. Set a password for the postgres superuser
4. Complete installation
        </pre>

        <h3>Open psql (Command Line):</h3>
        <pre>
Open CMD and type:
psql -U postgres
        </pre>

        <p><b>Common psql commands:</b></p>
        <pre>
\l         -- list databases
\c dbname  -- connect to a database
\dt        -- list tables
\du        -- list users/roles
\q         -- quit psql
        </pre>
    </div>


    <!-- 1.4 Basic commands -->
    <div class="topic">
        <h2>1.4 Basic Database Commands</h2>

        <h3>Create a Database</h3>
        <pre>
CREATE DATABASE company;
        </pre>

        <h3>Connect to Database</h3>
        <pre>
\c company;
        </pre>

        <h3>Create a Table</h3>
        <pre>
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    salary NUMERIC
);
        </pre>

        <h3>Insert Record</h3>
        <pre>
INSERT INTO employees (name, age, salary) 
VALUES ('John', 25, 45000);
        </pre>

        <h3>Fetch Data</h3>
        <pre>
SELECT * FROM employees;
        </pre>

        <h3>Update Record</h3>
        <pre>
UPDATE employees SET salary = 50000 WHERE id = 1;
        </pre>

        <h3>Delete Record</h3>
        <pre>
DELETE FROM employees WHERE id = 1;
        </pre>
    </div>

</section>

<hr>

<section id="data-types">

    <h1>Data Types in PostgreSQL</h1>

    <p>
        PostgreSQL supports a wide range of data types including numbers,
        text, dates, JSON, arrays, geometric values, network types and more.
        Below is the complete list of commonly used and advanced data types.
    </p>

    <!-- ===============================
         1. NUMERIC DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>1. Numeric Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>SMALLINT</td><td>2-byte integer (-32,768 to 32,767)</td></tr>
            <tr><td>INTEGER / INT</td><td>4-byte integer</td></tr>
            <tr><td>BIGINT</td><td>8-byte integer</td></tr>

            <tr><td>DECIMAL(p, s)</td><td>Exact numeric with precision & scale</td></tr>
            <tr><td>NUMERIC(p, s)</td><td>Same as DECIMAL (unlimited precision)</td></tr>

            <tr><td>REAL</td><td>4-byte floating point</td></tr>
            <tr><td>DOUBLE PRECISION</td><td>8-byte floating point</td></tr>

            <tr><td>SERIAL</td><td>Auto increment integer (INT)</td></tr>
            <tr><td>BIGSERIAL</td><td>Auto increment (BIGINT)</td></tr>
            <tr><td>SMALLSERIAL</td><td>Auto increment (SMALLINT)</td></tr>
        </table>
    </div>

    <!-- ===============================
         2. TEXT DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>2. Text / Character Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>CHAR(n)</td><td>Fixed-length string</td></tr>
            <tr><td>VARCHAR(n)</td><td>Variable-length string</td></tr>
            <tr><td>TEXT</td><td>Unlimited-length text</td></tr>
            <tr><td>CITEXT</td><td>Case-insensitive text</td></tr>
            <tr><td>UUID</td><td>Universal Unique Identifier</td></tr>
            <tr><td>BYTEA</td><td>Binary data (images, files)</td></tr>
        </table>
    </div>

    <!-- ===============================
         3. BOOLEAN DATA TYPE
    ================================== -->
    <div class="topic">
        <h2>3. Boolean Data Type</h2>

        <p><b>BOOLEAN</b> → TRUE / FALSE values.</p>
        <pre>
CREATE TABLE sample (
    active BOOLEAN
);
        </pre>
    </div>

    <!-- ===============================
         4. DATE/TIME DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>4. Date & Time Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>DATE</td><td>Calendar date (YYYY-MM-DD)</td></tr>
            <tr><td>TIME</td><td>Time only (HH:MM:SS)</td></tr>
            <tr><td>TIMESTAMP</td><td>Date & Time</td></tr>
            <tr><td>TIMESTAMPTZ</td><td>Timestamp with timezone</td></tr>
            <tr><td>INTERVAL</td><td>Time duration (1 day, 2 hours, etc.)</td></tr>
        </table>
    </div>

    <!-- ===============================
         5. JSON DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>5. JSON Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>JSON</td><td>Text-based JSON (stored as plain text)</td></tr>
            <tr><td>JSONB</td><td>Binary JSON (faster indexing & search)</td></tr>
        </table>
    </div>

    <!-- ===============================
         6. ARRAY DATA TYPE
    ================================== -->
    <div class="topic">
        <h2>6. Arrays</h2>

        <p>You can store arrays of any data type.</p>

        <pre>
CREATE TABLE students (
    id SERIAL,
    marks INT[]
);
        </pre>
    </div>

    <!-- ===============================
         7. ENUM DATA TYPE
    ================================== -->
    <div class="topic">
        <h2>7. ENUM Data Type</h2>

        <p>Enum stores a set of predefined values.</p>

        <h3>Create ENUM type:</h3>
        <pre>
CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral');
        </pre>

        <h3>Use ENUM in a table:</h3>
        <pre>
CREATE TABLE person (
    id SERIAL,
    name TEXT,
    current_mood mood
);
        </pre>
    </div>

    <!-- ===============================
         8. NETWORK DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>8. Network Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>INET</td><td>IPv4/IPv6 address</td></tr>
            <tr><td>CIDR</td><td>Network block</td></tr>
            <tr><td>MACADDR</td><td>MAC address</td></tr>
        </table>
    </div>

    <!-- ===============================
         9. GEOMETRIC DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>9. Geometric Data Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>POINT</td><td>(x, y)</td></tr>
            <tr><td>LINE</td><td>Infinite line</td></tr>
            <tr><td>LSEG</td><td>Line segment</td></tr>
            <tr><td>BOX</td><td>Rectangular box</td></tr>
            <tr><td>PATH</td><td>Closed/open path</td></tr>
            <tr><td>POLYGON</td><td>Polygon</td></tr>
            <tr><td>CIRCLE</td><td>Circle (center, radius)</td></tr>
        </table>
    </div>

    <!-- ===============================
         10. MONEY TYPE
    ================================== -->
    <div class="topic">
        <h2>10. Money Data Type</h2>

        <p>MONEY → Stores currency values</p>

        <pre>
CREATE TABLE accounts (
    id SERIAL,
    balance MONEY
);
        </pre>
    </div>

    <!-- ===============================
         11. HSTORE
    ================================== -->
    <div class="topic">
        <h2>11. HSTORE (Key-Value Store)</h2>
        <p>Stores collections of key → value pairs.</p>

        <pre>
CREATE EXTENSION hstore;

CREATE TABLE products (
    id SERIAL,
    attributes hstore
);
        </pre>
    </div>

    <!-- ===============================
         12. XML TYPE
    ================================== -->
    <div class="topic">
        <h2>12. XML Data Type</h2>
        <pre>
CREATE TABLE docs (
    id SERIAL,
    data XML
);
        </pre>
    </div>

    <!-- ===============================
         13. BIT STRING TYPE
    ================================== -->
    <div class="topic">
        <h2>13. Bit String Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Data Type</th><th>Description</th></tr>

            <tr><td>BIT(n)</td><td>Fixed-length bit string</td></tr>
            <tr><td>VARBIT(n)</td><td>Variable-length bit string</td></tr>
        </table>
    </div>

    <!-- ===============================
         14. CUSTOM DATA TYPES
    ================================== -->
    <div class="topic">
        <h2>14. Creating Custom Data Types</h2>

        <h3>A. Composite Type</h3>
        <pre>
CREATE TYPE address AS (
    street TEXT,
    city TEXT,
    pincode INT
);

CREATE TABLE employee (
    id SERIAL,
    name TEXT,
    home_address address
);
        </pre>

        <h3>B. DOMAIN Type</h3>
        <p>Domain = custom type + constraints</p>

        <pre>
CREATE DOMAIN positive_int AS INT
CHECK (VALUE > 0);

CREATE TABLE items (
    item_id positive_int,
    quantity positive_int
);
        </pre>

        <h3>C. ENUM Type (Already shown)</h3>
        <pre>
CREATE TYPE status AS ENUM ('pending', 'completed', 'cancelled');
        </pre>
    </div>

</section>

<section id="remaining-data-types">

    <h1>Additional PostgreSQL Data Types</h1>

    <p>
        PostgreSQL includes several advanced and internal data types used for ranges,
        object identifiers, text search, internal system functions, and more.
    </p>

    <!-- ===============================
         1. RANGE TYPES
    ================================== -->
    <div class="topic">
        <h2>1. Range Types</h2>

        <p>Range types store <b>start and end</b> values (example: 10–20).</p>
        
        <table cellpadding="5" cellspacing="0">
            <tr><th>Range Type</th><th>Description</th></tr>

            <tr><td>int4range</td><td>Range of INTEGER</td></tr>
            <tr><td>int8range</td><td>Range of BIGINT</td></tr>
            <tr><td>numrange</td><td>Range of NUMERIC values</td></tr>
            <tr><td>tsrange</td><td>Range of TIMESTAMP (no timezone)</td></tr>
            <tr><td>tstzrange</td><td>Range of TIMESTAMP WITH TIMEZONE</td></tr>
            <tr><td>daterange</td><td>Range of DATE values</td></tr>
        </table>

        <h3>Example Table Using Range</h3>
        <pre>
CREATE TABLE reservation (
    room INT,
    booked daterange
);
        </pre>

        <h3>Insert a Range</h3>
        <pre>
INSERT INTO reservation VALUES (101, '[2025-01-01, 2025-01-10]');
        </pre>

        <h3>Range Operators</h3>
        <pre>
@>   -- contains element
<@   -- element inside range
&&   -- overlap
-|-  -- adjacent
        </pre>
    </div>

    <!-- ===============================
         2. FULL TEXT SEARCH TYPES
    ================================== -->
    <div class="topic">
        <h2>2. Full-Text Search Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Type</th><th>Description</th></tr>

            <tr><td>tsvector</td><td>Document converted to searchable terms</td></tr>
            <tr><td>tsquery</td><td>Search query type</td></tr>
        </table>

        <h3>Example:</h3>
        <pre>
SELECT to_tsvector('english', 'PostgreSQL database system');
SELECT to_tsquery('english', 'database & system');
        </pre>
    </div>

    <!-- ===============================
         3. OBJECT IDENTIFIER (OID) TYPES
    ================================== -->
    <div class="topic">
        <h2>3. Object Identifier (OID) Types</h2>

        <p>
            PostgreSQL internally uses OIDs to identify rows, tables, indexes and internal objects.
        </p>

        <table cellpadding="5" cellspacing="0">
            <tr><th>OID Type</th><th>Description</th></tr>

            <tr><td>oid</td><td>Object identifier</td></tr>
            <tr><td>regclass</td><td>Reference to table</td></tr>
            <tr><td>regtype</td><td>Reference to type</td></tr>
            <tr><td>regproc</td><td>Reference to function</td></tr>
            <tr><td>regrole</td><td>Reference to role</td></tr>
            <tr><td>regnamespace</td><td>Reference to schema</td></tr>
        </table>

        <h3>Example</h3>
        <pre>
SELECT 'employees'::regclass;
        </pre>
    </div>

    <!-- ===============================
         4. INTERNAL / PSEUDO TYPES
    ================================== -->
    <div class="topic">
        <h2>4. Pseudo Types</h2>

        <p>
            Pseudo types cannot be used as table columns.  
            They are used in **functions, casting, and internal operations**.
        </p>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Pseudo Type</th><th>Description</th></tr>

            <tr><td>ANY</td><td>Accept any type</td></tr>
            <tr><td>ANYELEMENT</td><td>Any element type</td></tr>
            <tr><td>ANYARRAY</td><td>Any array type</td></tr>
            <tr><td>CSTRING</td><td>Null-terminated C string</td></tr>
            <tr><td>VOID</td><td>No value</td></tr>
            <tr><td>TRIGGER</td><td>Return type for trigger functions</td></tr>
            <tr><td>RECORD</td><td>Row type with unknown structure</td></tr>
            <tr><td>INTERNAL</td><td>Used only internally by PostgreSQL</td></tr>
            <tr><td>OPAQUE</td><td>Historical, still accepted</td></tr>
        </table>

        <h3>Example: Function using VOID</h3>
        <pre>
CREATE FUNCTION log_action()
RETURNS void AS $$
BEGIN
  RAISE NOTICE 'Action logged!';
END;
$$ LANGUAGE plpgsql;
        </pre>
    </div>

    <!-- ===============================
         5. SYSTEM IDENTIFIER TYPES
    ================================== -->
    <div class="topic">
        <h2>5. System Types</h2>

        <table cellpadding="5" cellspacing="0">
            <tr><th>Type</th><th>Description</th></tr>

            <tr><td>txid_snapshot</td><td>Transaction snapshot data</td></tr>
            <tr><td>pg_lsn</td><td>Log sequence number</td></tr>
            <tr><td>pg_snapshot</td><td>Snapshot for logical decoding</td></tr>
        </table>
    </div>

    <!-- ===============================
         6. ENUM + CUSTOM TYPE (SUMMARY)
    ================================== -->
    <div class="topic">
        <h2>6. ENUM + Custom Types (Summary)</h2>

        <h3>A. ENUM Type</h3>
        <pre>
CREATE TYPE mood AS ENUM ('happy', 'sad', 'neutral');
        </pre>

        <h3>B. Composite Type</h3>
        <pre>
CREATE TYPE address AS (street TEXT, city TEXT, pin INT);
        </pre>

        <h3>C. DOMAIN Type</h3>
        <pre>
CREATE DOMAIN positive_num AS INT CHECK (VALUE > 0);
        </pre>
    </div>

</section>

<hr>
<br>
<h1> Functions in PostgreSQL</h1>
<section id="string-functions">

    <h2>String Functions in PostgreSQL</h2>

    <p>String functions help manipulate and process text data in PostgreSQL.</p>

    <!-- 1. LENGTH -->
    <div class="topic">
        <h2>1. LENGTH()</h2>
        <p>Returns the number of characters in a string.</p>
        <pre>
SELECT LENGTH('PostgreSQL');
        </pre>
        <p><b>Output:</b> 10</p>
    </div>

    <!-- 2. UPPER -->
    <div class="topic">
        <h2>2. UPPER()</h2>
        <p>Converts text to uppercase.</p>
        <pre>
SELECT UPPER('postgres');
        </pre>
        <p><b>Output:</b> POSTGRES</p>
    </div>

    <!-- 3. LOWER -->
    <div class="topic">
        <h2>3. LOWER()</h2>
        <p>Converts text to lowercase.</p>
        <pre>
SELECT LOWER('HELLO');
        </pre>
        <p><b>Output:</b> hello</p>
    </div>

    <!-- 4. INITCAP -->
    <div class="topic">
        <h2>4. INITCAP()</h2>
        <p>Capitalizes the first letter of each word.</p>
        <pre>
SELECT INITCAP('postgres sql database');
        </pre>
        <p><b>Output:</b> Postgres Sql Database</p>
    </div>

    <!-- 5. CONCAT -->
    <div class="topic">
        <h2>5. CONCAT()</h2>
        <p>Joins multiple strings.</p>
        <pre>
SELECT CONCAT('Postgre', 'SQL');
        </pre>
        <p><b>Output:</b> PostgreSQL</p>
    </div>

    <!-- 6. CONCAT_WS -->
    <div class="topic">
        <h2>6. CONCAT_WS()</h2>
        <p>Concatenate with a separator.</p>
        <pre>
SELECT CONCAT_WS('-', '2025', '01', '20');
        </pre>
        <p><b>Output:</b> 2025-01-20</p>
    </div>

    <!-- 7. SUBSTRING -->
    <div class="topic">
        <h2>7. SUBSTRING()</h2>
        <p>Extract part of a string.</p>
        <pre>
SELECT SUBSTRING('PostgreSQL' FROM 1 FOR 4);
        </pre>
        <p><b>Output:</b> Post</p>
    </div>

    <!-- 8. LEFT -->
    <div class="topic">
        <h2>8. LEFT()</h2>
        <p>Get N characters from the left.</p>
        <pre>
SELECT LEFT('PostgreSQL', 4);
        </pre>
        <p><b>Output:</b> Post</p>
    </div>

    <!-- 9. RIGHT -->
    <div class="topic">
        <h2>9. RIGHT()</h2>
        <p>Get N characters from the right.</p>
        <pre>
SELECT RIGHT('PostgreSQL', 3);
        </pre>
        <p><b>Output:</b> SQL</p>
    </div>

    <!-- 10. REPLACE -->
    <div class="topic">
        <h2>10. REPLACE()</h2>
        <p>Replace substring in a string.</p>
        <pre>
SELECT REPLACE('Hello World', 'World', 'PostgreSQL');
        </pre>
        <p><b>Output:</b> Hello PostgreSQL</p>
    </div>

    <!-- 11. POSITION -->
    <div class="topic">
        <h2>11. POSITION()</h2>
        <p>Find position of substring.</p>
        <pre>
SELECT POSITION('SQL' IN 'PostgreSQL');
        </pre>
        <p><b>Output:</b> 8</p>
    </div>

    <!-- 12. TRIM -->
    <div class="topic">
        <h2>12. TRIM()</h2>
        <p>Remove spaces from both sides.</p>
        <pre>
SELECT TRIM('   hello   ');
        </pre>
        <p><b>Output:</b> hello</p>
    </div>

    <!-- 13. LTRIM / RTRIM -->
    <div class="topic">
        <h2>13. LTRIM() / RTRIM()</h2>
        <pre>
SELECT LTRIM('   data');
SELECT RTRIM('data   ');
        </pre>
        <p><b>Output:</b> data</p>
    </div>

    <!-- 14. LPAD / RPAD -->
    <div class="topic">
        <h2>14. LPAD() / RPAD()</h2>
        <p>Pad a string to a fixed length.</p>
        <pre>
SELECT LPAD('45', 5, '0');  
SELECT RPAD('Hi', 5, '.');
        </pre>
        <p><b>Output:</b> 00045, Hi...</p>
    </div>

    <!-- 15. SPLIT_PART -->
    <div class="topic">
        <h2>15. SPLIT_PART()</h2>
        <p>Split string and return part by index.</p>
        <pre>
SELECT SPLIT_PART('2025-01-20', '-', 2);
        </pre>
        <p><b>Output:</b> 01</p>
    </div>

    <!-- 16. REVERSE -->
    <div class="topic">
        <h2>16. REVERSE()</h2>
        <p>Reverse a string.</p>
        <pre>
SELECT REVERSE('PostgreSQL');
        </pre>
        <p><b>Output:</b> LQSergtsoP</p>
    </div>

    <!-- 17. STRING_AGG -->
    <div class="topic">
        <h2>17. STRING_AGG()</h2>
        <p>Aggregate strings into one value with a separator.</p>
        <pre>
SELECT STRING_AGG(name, ', ') FROM users;
        </pre>
        <p><b>Output:</b> John, Alex, Mary</p>
    </div>

    <!-- 18. REGEXP Functions Overview -->
    <div class="topic">
        <h2>18. Regular Expression String Functions (Summary)</h2>

        <ul>
            <li><b>regexp_matches()</b> – return matched text</li>
            <li><b>regexp_replace()</b> – replace using regex</li>
            <li><b>regexp_split_to_array()</b></li>
            <li><b>regexp_split_to_table()</b></li>
            <li><b>regexp_count()</b> – count matches</li>
        </ul>

        <h3>18.1 regexp_matches()</h3>
        <pre>
SELECT regexp_matches('abc123xyz', '\d+');
-- Output: {123}
        </pre>
    </div>

    <div class="topic">
        <h3>18.2 regexp_replace()</h3>
        <pre>
SELECT regexp_replace('a1b2c3', '\d', '#', 'g');
-- Output: a#b#c#
        </pre>
    </div>

    <div class="topic">
        <h3>18.3 regexp_split_to_array()</h3>
        <pre>
SELECT regexp_split_to_array('a,b,c', ',');
-- Output: {a,b,c}
        </pre>
    </div>

    <div class="topic">
        <h3>18.4 regexp_split_to_table()</h3>
        <pre>
SELECT regexp_split_to_table('a,b,c', ',');
-- Output (rows):
a
b
c
        </pre>
    </div>

    <div class="topic">
        <h3>18.5 regexp_count()  (PostgreSQL 15+)</h3>
        <pre>
SELECT regexp_count('a1b2c3', '\d');
-- Output: 3
        </pre>
    </div>

    <!-- FORMAT -->
    <div class="topic">
        <h2>19. FORMAT()</h2>
        <pre>
SELECT FORMAT('Name: %s, Age: %s', 'Aathi', 21);
-- Output: Name: Aathi, Age: 21
        </pre>
    </div>

</section>

<hr>

<section id="numeric-functions">

    <h2>Numeric Functions in PostgreSQL</h2>

    <!-- ABS -->
    <div class="topic">
        <h2>1. ABS()</h2>
        <p>Returns absolute value.</p>
        <pre>
SELECT ABS(-25);
-- Output: 25
        </pre>
    </div>

    <!-- CEIL / CEILING -->
    <div class="topic">
        <h2>2. CEIL() / CEILING()</h2>
        <p>Rounds a number up.</p>
        <pre>
SELECT CEIL(4.2);
-- Output: 5
        </pre>
    </div>

    <!-- FLOOR -->
    <div class="topic">
        <h2>3. FLOOR()</h2>
        <p>Rounds a number down.</p>
        <pre>
SELECT FLOOR(4.8);
-- Output: 4
        </pre>
    </div>

    <!-- ROUND -->
    <div class="topic">
        <h2>4. ROUND()</h2>
        <p>Rounds number to nearest integer or decimal position.</p>
        <pre>
SELECT ROUND(3.567, 2);
-- Output: 3.57
        </pre>
    </div>

    <!-- TRUNC -->
    <div class="topic">
        <h2>5. TRUNC()</h2>
        <p>Truncates without rounding.</p>
        <pre>
SELECT TRUNC(8.999);
-- Output: 8
        </pre>
    </div>

    <!-- POWER -->
    <div class="topic">
        <h2>6. POWER()</h2>
        <pre>
SELECT POWER(2, 4);
-- Output: 16
        </pre>
    </div>

    <!-- SQRT -->
    <div class="topic">
        <h2>7. SQRT()</h2>
        <pre>
SELECT SQRT(49);
-- Output: 7
        </pre>
    </div>

    <!-- CBRT -->
    <div class="topic">
        <h2>8. CBRT()</h2>
        <p>Cube root.</p>
        <pre>
SELECT CBRT(27);
-- Output: 3
        </pre>
    </div>

    <!-- MOD -->
    <div class="topic">
        <h2>9. MOD()</h2>
        <p>Returns remainder.</p>
        <pre>
SELECT MOD(17, 5);
-- Output: 2
        </pre>
    </div>

    <!-- PI -->
    <div class="topic">
        <h2>10. PI()</h2>
        <pre>
SELECT PI();
-- Output: 3.14159265358979
        </pre>
    </div>

    <!-- DEGREES -->
    <div class="topic">
        <h2>11. DEGREES()</h2>
        <p>Convert radians → degrees.</p>
        <pre>
SELECT DEGREES(PI());
-- Output: 180
        </pre>
    </div>

    <!-- RADIANS -->
    <div class="topic">
        <h2>12. RADIANS()</h2>
        <p>Convert degrees → radians.</p>
        <pre>
SELECT RADIANS(180);
-- Output: 3.14159
        </pre>
    </div>

    <!-- RANDOM -->
    <div class="topic">
        <h2>13. RANDOM()</h2>
        <p>Generates random number (0 to 1).</p>
        <pre>
SELECT RANDOM();
-- Output: (varies) e.g., 0.89234
        </pre>
    </div>

    <!-- SETSEED -->
    <div class="topic">
        <h2>14. SETSEED()</h2>
        <p>Sets seed for RANDOM().</p>
        <pre>
SELECT SETSEED(0.5);
SELECT RANDOM();
-- Output: (deterministic based on seed)
        </pre>
    </div>

    <!-- EXP -->
    <div class="topic">
        <h2>15. EXP()</h2>
        <pre>
SELECT EXP(1);
-- Output: 2.718281828
        </pre>
    </div>

    <!-- LN -->
    <div class="topic">
        <h2>16. LN()</h2>
        <p>Natural log.</p>
        <pre>
SELECT LN(10);
-- Output: 2.302585093
        </pre>
    </div>

    <!-- LOG -->
    <div class="topic">
        <h2>17. LOG()</h2>
        <p>Log base n.</p>
        <pre>
SELECT LOG(10, 1000);
-- Output: 3
        </pre>
    </div>

    <!-- SIGN -->
    <div class="topic">
        <h2>18. SIGN()</h2>
        <p>Returns -1, 0, or 1.</p>
        <pre>
SELECT SIGN(-50);
-- Output: -1
        </pre>
    </div>

    <!-- WIDTH_BUCKET -->
    <div class="topic">
        <h2>19. WIDTH_BUCKET()</h2>
        <p>Histogram bucket function.</p>
        <pre>
SELECT WIDTH_BUCKET(15, 0, 30, 3);
-- Range 0–30 split into 3 buckets:
-- Output: 2   (because 15 is in 2nd bucket)
        </pre>
    </div>

    <!-- SCALE -->
    <div class="topic">
        <h2>20. SCALE()</h2>
        <p>Number of decimal digits in the fractional part.</p>
        <pre>
SELECT SCALE(123.456);
-- Output: 3
        </pre>
    </div>

    <!-- Numeric Aggregate Functions -->
    <h2>21. Aggregate Numeric Functions</h2>

    <div class="topic">
        <h3>21.1 SUM()</h3>
        <pre>
SELECT SUM(salary) FROM employees;
-- Output example: 150000
        </pre>
    </div>

    <div class="topic">
        <h3>21.2 AVG()</h3>
        <pre>
SELECT AVG(age) FROM employees;
-- Output example: 27.5
        </pre>
    </div>

    <div class="topic">
        <h3>21.3 MIN(), MAX()</h3>
        <pre>
SELECT MIN(age), MAX(age) FROM employees;
-- Output: 21 | 35
        </pre>
    </div>

    <div class="topic">
        <h3>21.4 COUNT()</h3>
        <pre>
SELECT COUNT(*) FROM employees;
-- Output: 8
        </pre>
    </div>

    <div class="topic">
        <h3>21.5 STDDEV(), VARIANCE()</h3>
        <pre>
SELECT STDDEV(salary), VARIANCE(salary) FROM employees;
-- Output: e.g., 4500 | 20250000
        </pre>
    </div>

</section>

<hr>

<section id="date-time-functions">

    <h2>Date & Time Functions in PostgreSQL</h2>

    <!-- CURRENT_DATE -->
    <div class="topic">
        <h2>1. CURRENT_DATE</h2>
        <p>Returns today’s date.</p>
        <pre>
SELECT CURRENT_DATE;
-- Output: 2025-11-30
        </pre>
    </div>

    <!-- CURRENT_TIME -->
    <div class="topic">
        <h2>2. CURRENT_TIME</h2>
        <pre>
SELECT CURRENT_TIME;
-- Output: 10:45:23.123+05:30
        </pre>
    </div>

    <!-- CURRENT_TIMESTAMP -->
    <div class="topic">
        <h2>3. CURRENT_TIMESTAMP</h2>
        <pre>
SELECT CURRENT_TIMESTAMP;
-- Output: 2025-11-30 10:45:23.123+05:30
        </pre>
    </div>

    <!-- NOW() -->
    <div class="topic">
        <h2>4. NOW()</h2>
        <p>Same as CURRENT_TIMESTAMP.</p>
        <pre>
SELECT NOW();
        </pre>
    </div>

    <!-- TIMEOFDAY -->
    <div class="topic">
        <h2>5. TIMEOFDAY()</h2>
        <p>Human-readable system time.</p>
        <pre>
SELECT TIMEOFDAY();
-- Output: Sun Nov 30 10:45:23.123 IST 2025
        </pre>
    </div>

    <!-- AGE -->
    <div class="topic">
        <h2>6. AGE()</h2>
        <p>Difference between two dates.</p>
        <pre>
SELECT AGE('2025-11-30', '2001-04-10');
-- Output: 24 years 7 mons 20 days
        </pre>
    </div>

    <!-- EXTRACT -->
    <div class="topic">
        <h2>7. EXTRACT()</h2>
        <p>Extract part of date/time.</p>
        <pre>
SELECT EXTRACT(YEAR FROM DATE '2025-11-30');
-- Output: 2025

SELECT EXTRACT(MONTH FROM CURRENT_DATE);
-- Output: 11
        </pre>
    </div>

    <!-- DATE_PART -->
    <div class="topic">
        <h2>8. DATE_PART()</h2>
        <pre>
SELECT DATE_PART('dow', DATE '2025-11-30');
-- Output: 0   (Sunday)
        </pre>
    </div>

    <!-- DATE_TRUNC -->
    <div class="topic">
        <h2>9. DATE_TRUNC()</h2>
        <p>Truncate date to specific unit.</p>
        <pre>
SELECT DATE_TRUNC('month', TIMESTAMP '2025-11-30 10:45:00');
-- Output: 2025-11-01 00:00:00
        </pre>
    </div>

    <!-- JUSTIFY_INTERVAL -->
    <div class="topic">
        <h2>10. JUSTIFY_INTERVAL()</h2>
        <p>Fix oversized units (convert 30 days → 1 month etc.).</p>
        <pre>
SELECT JUSTIFY_INTERVAL('30 days');
-- Output: 1 mon
        </pre>
    </div>

    <!-- INTERVAL -->
    <div class="topic">
        <h2>11. INTERVAL</h2>
        <p>Duration representation.</p>
        <pre>
SELECT INTERVAL '2 hours 30 minutes';
-- Output: 02:30:00
        </pre>
    </div>

    <!-- ADD / SUBTRACT -->
    <div class="topic">
        <h2>12. ADD / SUBTRACT Dates</h2>
        <pre>
SELECT DATE '2025-11-30' + INTERVAL '5 days';
-- Output: 2025-12-05

SELECT DATE '2025-11-30' - INTERVAL '1 month';
-- Output: 2025-10-30
        </pre>
    </div>

    <!-- AGE() with now -->
    <div class="topic">
        <h2>13. AGE(timestamp)</h2>
        <pre>
SELECT AGE(NOW());
-- Output: 0 mons 0 days 00:00:00  (age from now to now)
        </pre>
    </div>

    <!-- OVERLAPS -->
    <div class="topic">
        <h2>14. OVERLAPS</h2>
        <p>Check if two time periods overlap.</p>
        <pre>
SELECT (DATE '2025-11-01', DATE '2025-11-10')
     OVERLAPS
       (DATE '2025-11-05', DATE '2025-11-20');

-- Output: true
        </pre>
    </div>

    <!-- MAKE_DATE -->
    <div class="topic">
        <h2>15. MAKE_DATE()</h2>
        <pre>
SELECT MAKE_DATE(2025, 11, 30);
-- Output: 2025-11-30
        </pre>
    </div>

    <!-- MAKE_TIME -->
    <div class="topic">
        <h2>16. MAKE_TIME()</h2>
        <pre>
SELECT MAKE_TIME(10, 45, 30);
-- Output: 10:45:30
        </pre>
    </div>

    <!-- MAKE_TIMESTAMP -->
    <div class="topic">
        <h2>17. MAKE_TIMESTAMP()</h2>
        <pre>
SELECT MAKE_TIMESTAMP(2025, 11, 30, 10, 45, 30);
-- Output: 2025-11-30 10:45:30
        </pre>
    </div>

    <!-- TO_CHAR -->
    <div class="topic">
        <h2>18. TO_CHAR()</h2>
        <p>Format date/time.</p>
        <pre>
SELECT TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI');
-- Output: 2025-11-30 10:45
        </pre>
    </div>

    <!-- TO_DATE -->
    <div class="topic">
        <h2>19. TO_DATE()</h2>
        <pre>
SELECT TO_DATE('30-11-2025', 'DD-MM-YYYY');
-- Output: 2025-11-30
        </pre>
    </div>

    <!-- TO_TIMESTAMP -->
    <div class="topic">
        <h2>20. TO_TIMESTAMP()</h2>
        <pre>
SELECT TO_TIMESTAMP('2025-11-30 10:45', 'YYYY-MM-DD HH24:MI');
-- Output: 2025-11-30 10:45:00
        </pre>
    </div>

    <!-- EXTRACT Time zone -->
    <div class="topic">
        <h2>21. Time Zone Functions</h2>

        <pre>
SELECT NOW() AT TIME ZONE 'UTC';
-- Output: 2025-11-30 05:15:00

SELECT NOW() AT TIME ZONE 'America/New_York';
-- Output: 2025-11-30 00:15:00
        </pre>
    </div>

</section>

<hr>

<section id="conditional-expressions">

    <h2>Conditional Expressions (CASE WHEN)</h2>

    <p>CASE is used to apply conditional logic in SQL queries.</p>

    <!-- SIMPLE CASE -->
    <div class="topic">
        <h2>1. Simple CASE Expression</h2>
        <p>Checks equality only.</p>

        <pre>
SELECT 
    marks,
    CASE marks
        WHEN 100 THEN 'Perfect'
        WHEN 90 THEN 'Excellent'
        WHEN 75 THEN 'Good'
        ELSE 'Average'
    END AS result
FROM students;

-- Output:
-- marks | result
-- 90    | Excellent
-- 72    | Average
        </pre>
    </div>

    <!-- SEARCHED CASE -->
    <div class="topic">
        <h2>2. Searched CASE Expression</h2>
        <p>Checks conditions using &lt;, &gt;, BETWEEN etc.</p>

        <pre>
SELECT 
    marks,
    CASE
        WHEN marks >= 90 THEN 'A'
        WHEN marks >= 80 THEN 'B'
        WHEN marks >= 70 THEN 'C'
        ELSE 'D'
    END AS grade
FROM students;

-- Output:
-- marks | grade
-- 95    | A
-- 76    | C
        </pre>
    </div>

    <!-- CASE with ORDER BY -->
    <div class="topic">
        <h2>3. CASE in ORDER BY (Custom Sorting)</h2>

        <pre>
SELECT name, role FROM employees
ORDER BY
    CASE role
        WHEN 'Manager' THEN 1
        WHEN 'Team Lead' THEN 2
        ELSE 3
    END;

-- Output sorted by custom rank
        </pre>
    </div>

    <!-- CASE as IF-ELSE -->
    <div class="topic">
        <h2>4. CASE as IF-ELSE Logic</h2>

        <pre>
SELECT
    salary,
    CASE 
        WHEN salary &gt; 50000 THEN salary * 0.10
        ELSE salary * 0.05
    END AS bonus
FROM employees;

-- Output:
-- salary | bonus
-- 60000  | 6000
-- 40000  | 2000
        </pre>
    </div>

    <!-- CASE inside AGGREGATES -->
    <div class="topic">
        <h2>5. CASE Inside Aggregate Functions</h2>

        <pre>
SELECT
    SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_count,
    SUM(CASE WHEN gender = 'F' THEN 1 ELSE 0 END) AS female_count
FROM students;

-- Output:
-- male_count | female_count
--     10     |     12
        </pre>
    </div>

    <!-- NULL Handling -->
    <div class="topic">
        <h2>6. CASE for NULL Handling</h2>

        <pre>
SELECT 
    name,
    CASE 
        WHEN phone IS NULL THEN 'No Number'
        ELSE phone
    END AS phone_info
FROM customers;

-- Output:
-- Ram     | 9876543210
-- Kumar   | No Number
        </pre>
    </div>

    <!-- CASE inside UPDATE -->
    <div class="topic">
        <h2>7. CASE in UPDATE Statement</h2>

        <pre>
UPDATE products
SET price = CASE
                WHEN category = 'Electronics' THEN price * 1.10
                WHEN category = 'Clothes' THEN price * 1.05
                ELSE price
            END;

-- Output:
-- Prices updated based on category
        </pre>
    </div>

</section>

<hr>

<section id="null-handling">
    <h2>Null Handling & Type Conversion Functions</h2>

    <!-- COALESCE -->
    <section>
        <h3>COALESCE()</h3>
        <p>Returns the first non-NULL value in the list.</p>

        <h4>Syntax:</h4>
        <pre><code>COALESCE(value1, value2, value3, ...)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT COALESCE(NULL, NULL, 'Hello', 'World');</code></pre>

        <h4>Output:</h4>
        <pre><code>Hello</code></pre>
    </section>

    <!-- NULLIF -->
    <section>
        <h3>NULLIF()</h3>
        <p>Returns NULL if both values are equal; otherwise returns the first value.</p>

        <h4>Syntax:</h4>
        <pre><code>NULLIF(value1, value2)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT NULLIF(10, 10);</code></pre>

        <h4>Output:</h4>
        <pre><code>NULL</code></pre>

        <h4>Another Example:</h4>
        <pre><code>SELECT NULLIF(10, 5);</code></pre>

        <h4>Output:</h4>
        <pre><code>10</code></pre>
    </section>

    <!-- GREATEST / LEAST -->
    <section>
        <h3>GREATEST() / LEAST()</h3>
        <p>GREATEST returns the maximum. LEAST returns the minimum.</p>

        <h4>Syntax:</h4>
        <pre><code>GREATEST(value1, value2, ...)
LEAST(value1, value2, ...)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT GREATEST(10, 20, 5), LEAST(10, 20, 5);</code></pre>

        <h4>Output:</h4>
        <pre><code> greatest | least
----------+-------
    20    |   5
</code></pre>
    </section>

    <!-- TYPE CASTING -->
    <section>
        <h2>Type Conversion</h2>

        <h3>1. CAST()</h3>
        <p>Converts a value from one data type to another.</p>

        <h4>Syntax:</h4>
        <pre><code>CAST(value AS datatype)</code></pre>

        <h4>Example:</h4>
        <pre><code>SELECT CAST('123' AS INTEGER);</code></pre>

        <h4>Output:</h4>
        <pre><code>123</code></pre>

        <hr>

        <h3>2. Shorthand Casting (::)</h3>
        <p>PostgreSQL allows a shorter syntax for casting.</p>

        <h4>Syntax:</h4>
        <pre><code>value::datatype</code></pre>

        <h4>Examples:</h4>

        <pre><code>SELECT '123'::int;</code></pre>
        <pre><code>SELECT 100::text;</code></pre>
        <pre><code>SELECT '12.50'::numeric;</code></pre>

        <h4>Output:</h4>
        <pre><code>123
100
12.50
</code></pre>

        <h3>3. Common Conversions</h3>
        <pre><code>
SELECT '2024-01-01'::date;
SELECT '10:30'::time;
SELECT 'true'::boolean;
SELECT 99.9::int;       -- result: 100 (rounds)
SELECT '123abc'::int;   -- ERROR (invalid cast)
        </code></pre>
    </section>
</section>

<hr>

<section id="json-array-window-math">
    <h2>JSON, Array, Window & Math Functions</h2>

    <!-- JSON FUNCTIONS -->
    <section id="json-functions">
        <h3>JSON Functions</h3>

        <!-- json_extract_path -->
        <section>
            <h4>json_extract_path()</h4>
            <p>Extracts a value from a JSON object using a path.</p>

            <h4>Syntax:</h4>
            <pre><code>json_extract_path(json, VARIADIC path_elements)</code></pre>

            <h4>Example:</h4>
            <pre><code>
SELECT json_extract_path('{"name":"Aathi","details":{"age":21}}', 'details', 'age');
            </code></pre>

            <h4>Output:</h4>
            <pre><code>21</code></pre>
        </section>

        <!-- jsonb_set -->
        <section>
            <h4>jsonb_set()</h4>
            <p>Updates a value inside a JSONB object.</p>

            <h4>Syntax:</h4>
            <pre><code>jsonb_set(target_jsonb, path, new_value_jsonb)</code></pre>

            <h4>Example:</h4>
            <pre><code>
SELECT jsonb_set('{"name":"Aathi","age":21}'::jsonb,
                 '{age}',
                 '22'::jsonb);
            </code></pre>

            <h4>Output:</h4>
            <pre><code>{"name": "Aathi", "age": 22}</code></pre>
        </section>

        <!-- jsonb_array_elements -->
        <section>
            <h4>jsonb_array_elements()</h4>
            <p>Expands a JSON array into a set of rows.</p>

            <h4>Syntax:</h4>
            <pre><code>jsonb_array_elements(jsonb_array)</code></pre>

            <h4>Example:</h4>
            <pre><code>
SELECT jsonb_array_elements('["java","python","sql"]'::jsonb);
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 jsonb_array_elements
-----------------------
 "java"
 "python"
 "sql"
</code></pre>
        </section>
    </section>

    <hr>

    <!-- ARRAY FUNCTIONS -->
    <section id="array-functions">
        <h3>Array Functions</h3>

        <!-- array_length -->
        <section>
            <h4>array_length()</h4>
            <p>Returns length of array dimension.</p>

            <h4>Example:</h4>
            <pre><code>SELECT array_length(ARRAY[10, 20, 30], 1);</code></pre>

            <h4>Output:</h4>
            <pre><code>3</code></pre>
        </section>

        <!-- array_append -->
        <section>
            <h4>array_append()</h4>
            <p>Adds an element to the end of an array.</p>

            <h4>Example:</h4>
            <pre><code>SELECT array_append(ARRAY[1, 2, 3], 4);</code></pre>

            <h4>Output:</h4>
            <pre><code>{1,2,3,4}</code></pre>
        </section>

        <!-- array_remove -->
        <section>
            <h4>array_remove()</h4>
            <p>Removes all matching values from an array.</p>

            <h4>Example:</h4>
            <pre><code>SELECT array_remove(ARRAY[1, 2, 3, 2], 2);</code></pre>

            <h4>Output:</h4>
            <pre><code>{1,3}</code></pre>
        </section>
    </section>

    <hr>

    <!-- WINDOW FUNCTIONS -->
    <section id="window-functions">
        <h3>Window Functions</h3>

        <!-- row_number -->
        <section>
            <h4>row_number()</h4>
            <p>Gives a unique row number within the partition.</p>

            <h4>Example:</h4>
            <pre><code>
SELECT name, marks,
       row_number() OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 name   | marks | row_number
--------+-------+------------
 Aathi  |   99  |     1
 John   |   90  |     2
 Kiran  |   75  |     3
</code></pre>
        </section>

        <!-- rank -->
        <section>
            <h4>rank()</h4>
            <p>Gives rank with gaps for ties.</p>

            <pre><code>
SELECT name, marks,
       rank() OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 marks | rank
-------+------
  99   | 1
  90   | 2
  90   | 2
  75   | 4   <-- gap
</code></pre>
        </section>

        <!-- dense_rank -->
        <section>
            <h4>dense_rank()</h4>
            <p>No gaps in ranking.</p>

            <pre><code>
SELECT name, marks,
       dense_rank() OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 marks | dense_rank
-------+------------
  99   | 1
  90   | 2
  90   | 2
  75   | 3
</code></pre>
        </section>

        <!-- lag / lead -->
        <section>
            <h4>lag() / lead()</h4>
            <p>lag → previous row, lead → next row.</p>

            <pre><code>
SELECT name, marks,
       lag(marks) OVER (ORDER BY marks),
       lead(marks) OVER (ORDER BY marks)
FROM students;
            </code></pre>

            <h4>Output:</h4>
            <pre><code>
 name  | marks | lag | lead
-------+-------+-----+------
 Kiran |   75  | NULL| 90
 John  |   90  | 75  | 99
 Aathi |   99  | 90  | NULL
</code></pre>
        </section>

        <!-- ntile -->
        <section>
            <h4>ntile(n)</h4>
            <p>Divides rows into n equal groups.</p>

            <pre><code>
SELECT name, marks,
       ntile(3) OVER (ORDER BY marks DESC)
FROM students;
            </code></pre>
        </section>
    </section>

    <hr>

    <!-- MATH FUNCTIONS -->
    <section id="math-functions">
        <h3>Math Functions</h3>

        <h4>Common Math Functions:</h4>
        <pre><code>
SELECT sin(1.0);
SELECT cos(1.0);
SELECT tan(1.0);
SELECT sqrt(25);
SELECT abs(-10);
SELECT ceil(4.2);
SELECT floor(4.8);
SELECT round(4.567, 2);
        </code></pre>

        <h4>Output (example):</h4>
        <pre><code>
 sin     = 0.84
 cos     = 0.54
 tan     = 1.55
 sqrt    = 5
 abs     = 10
 ceil    = 5
 floor   = 4
 round   = 4.57
</code></pre>
    </section>
</section>

<hr>

<section id="system-functions">
    <h2>System Functions</h2>
    <p>These functions return information about the database, user, session, server, and timestamps.</p>

    <!-- current_database -->
    <section>
        <h3>current_database()</h3>
        <p>Returns the name of the current database.</p>

        <h4>Example:</h4>
        <pre><code>SELECT current_database();</code></pre>

        <h4>Output:</h4>
        <pre><code>mydb</code></pre>
    </section>

    <!-- version -->
    <section>
        <h3>version()</h3>
        <p>Returns PostgreSQL version and build details.</p>

        <h4>Example:</h4>
        <pre><code>SELECT version();</code></pre>

        <h4>Output:</h4>
        <pre><code>
PostgreSQL 15.3 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu) 12.2.0, 64-bit
</code></pre>
    </section>

    <!-- current_user -->
    <section>
        <h3>current_user</h3>
        <p>Returns the user currently executing the query.</p>

        <h4>Example:</h4>
        <pre><code>SELECT current_user;</code></pre>

        <h4>Output:</h4>
        <pre><code>postgres</code></pre>
    </section>

    <!-- now -->
    <section>
        <h3>now()</h3>
        <p>Returns current date and time at query start.</p>

        <h4>Example:</h4>
        <pre><code>SELECT now();</code></pre>

        <h4>Output:</h4>
        <pre><code>2025-11-30 10:15:22.123+05:30</code></pre>
    </section>

    <hr>

    <!-- current_schema -->
    <section>
        <h3>current_schema()</h3>
        <p>Returns the name of the active schema.</p>

        <h4>Example:</h4>
        <pre><code>SELECT current_schema();</code></pre>

        <h4>Output:</h4>
        <pre><code>public</code></pre>
    </section>

    <!-- session_user -->
    <section>
        <h3>session_user</h3>
        <p>The session's login role (may differ from current_user after SET ROLE).</p>

        <h4>Example:</h4>
        <pre><code>SELECT session_user;</code></pre>

        <h4>Output:</h4>
        <pre><code>postgres</code></pre>
    </section>

    <!-- inet_server_addr -->
    <section>
        <h3>inet_server_addr()</h3>
        <p>Returns server IP address.</p>

        <h4>Example:</h4>
        <pre><code>SELECT inet_server_addr();</code></pre>

        <h4>Output:</h4>
        <pre><code>127.0.0.1</code></pre>
    </section>

    <!-- pg_backend_pid -->
    <section>
        <h3>pg_backend_pid()</h3>
        <p>Returns the process ID of your PostgreSQL backend session.</p>

        <h4>Example:</h4>
        <pre><code>SELECT pg_backend_pid();</code></pre>

        <h4>Output:</h4>
        <pre><code>9284</code></pre>
    </section>

    <hr>

    <!-- Timestamp comparision -->
    <section>
        <h3>Timestamp System Functions</h3>

        <h4>1. clock_timestamp()</h4>
        <p>Returns the actual current time (keeps changing during query).</p>

        <pre><code>SELECT clock_timestamp();</code></pre>

        <h4>2. statement_timestamp()</h4>
        <p>Returns timestamp at the start of the current SQL statement.</p>

        <pre><code>SELECT statement_timestamp();</code></pre>

        <h4>3. transaction_timestamp()</h4>
        <p>Returns timestamp at the start of the transaction.</p>

        <pre><code>SELECT transaction_timestamp();</code></pre>

        <h4>Difference Example:</h4>
        <pre><code>
SELECT now(),
       clock_timestamp(),
       statement_timestamp(),
       transaction_timestamp();
        </code></pre>
    </section>
</section>

<hr>

<section id="ddl-create">
    <h2>DDL Commands — CREATE</h2>
    <p>CREATE commands are used to create databases, schemas, tables, views, indexes, sequences, types, functions, and triggers.</p>

    <!-- CREATE DATABASE -->
    <section>
        <h3>1. CREATE DATABASE</h3>

        <pre><code>CREATE DATABASE dbname;</code></pre>

        <h4>With options:</h4>
        <pre><code>
CREATE DATABASE mydb
    WITH OWNER = postgres
         ENCODING = 'UTF8'
         CONNECTION LIMIT = -1
         IS_TEMPLATE = false;
        </code></pre>
    </section>

    <!-- CREATE SCHEMA -->
    <section>
        <h3>2. CREATE SCHEMA</h3>

        <pre><code>CREATE SCHEMA sales;</code></pre>

        <h4>Create with owner:</h4>
        <pre><code>CREATE SCHEMA auth AUTHORIZATION aathi;</code></pre>
    </section>

    <!-- CREATE TABLE -->
    <section>
        <h3>3. CREATE TABLE</h3>

        <h4>Basic Syntax:</h4>
        <pre><code>
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    age  INT,
    salary NUMERIC(10,2),
    active BOOLEAN DEFAULT true
);
        </code></pre>

        <h4>Column Constraints:</h4>
        <ul>
            <li>PRIMARY KEY</li>
            <li>FOREIGN KEY</li>
            <li>UNIQUE</li>
            <li>CHECK</li>
            <li>NOT NULL</li>
            <li>DEFAULT</li>
        </ul>

        <pre><code>
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    amount NUMERIC CHECK (amount > 0),
    status TEXT DEFAULT 'pending',
    cust_id INT REFERENCES customers(id)
);
        </code></pre>

        <h4>Table Constraints:</h4>
        <pre><code>
CREATE TABLE student (
    id INT,
    name TEXT,
    age INT,
    CONSTRAINT age_check CHECK (age > 0),
    CONSTRAINT pk PRIMARY KEY (id)
);
        </code></pre>

        <h4>WITH Options:</h4>
        <pre><code>
CREATE TABLE logs (
    id SERIAL,
    message TEXT
) WITH (fillfactor = 70);
        </code></pre>
    </section>

    <!-- CREATE TABLE AS -->
    <section>
        <h3>4. CREATE TABLE AS</h3>
        <p>Create a table from SELECT result.</p>

        <pre><code>
CREATE TABLE backup_emp AS
SELECT * FROM employees WHERE active = true;
        </code></pre>
    </section>

    <!-- CREATE VIEW -->
    <section>
        <h3>5. CREATE VIEW</h3>

        <pre><code>
CREATE VIEW active_employees AS
SELECT id, name FROM employees WHERE active = true;
        </code></pre>
    </section>

    <!-- CREATE MATERIALIZED VIEW -->
    <section>
        <h3>6. CREATE MATERIALIZED VIEW</h3>

        <pre><code>
CREATE MATERIALIZED VIEW emp_summary AS
SELECT active, count(*) FROM employees GROUP BY active;
        </code></pre>
    </section>

    <!-- CREATE INDEX (basic intro only) -->
    <section>
        <h3>7. CREATE INDEX (Intro)</h3>

        <pre><code>
CREATE INDEX idx_emp_name ON employees(name);
        </code></pre>

        <p>A detailed INDEX section will come later.</p>
    </section>

    <!-- CREATE SEQUENCE -->
    <section>
        <h3>8. CREATE SEQUENCE</h3>

        <pre><code>
CREATE SEQUENCE invoice_seq
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    NO MAXVALUE
    CACHE 1;
        </code></pre>
    </section>

    <!-- CREATE TYPE -->
    <section>
        <h3>9. CREATE TYPE</h3>

        <h4>ENUM Type:</h4>
        <pre><code>
CREATE TYPE status_enum AS ENUM ('pending', 'approved', 'rejected');
        </code></pre>

        <h4>Composite Type:</h4>
        <pre><code>
CREATE TYPE address_type AS (
    city TEXT,
    pincode INT
);
        </code></pre>

        <h4>Range Type:</h4>
        <pre><code>
CREATE TYPE price_range AS RANGE (
    subtype = numeric
);
        </code></pre>
    </section>

    <!-- CREATE FUNCTION -->
    <section>
        <h3>10. CREATE FUNCTION (Simple)</h3>

        <pre><code>
CREATE FUNCTION add_two(a INT, b INT)
RETURNS INT AS $$
BEGIN
    RETURN a + b;
END;
$$ LANGUAGE plpgsql;
        </code></pre>
    </section>

    <!-- CREATE TRIGGER (header only) -->
    <section>
        <h3>11. CREATE TRIGGER (Short form)</h3>

        <pre><code>
CREATE TRIGGER log_changes
AFTER INSERT ON employees
FOR EACH ROW EXECUTE FUNCTION log_employee();
        </code></pre>

        <p>A full TRIGGER section will come later.</p>
    </section>
</section>

<hr>


<h2>DDL Commands - ALTER</h2>

<hr>
<section>
<h2>1. ALTER TABLE</h2>

<h3>1.1 Add Column</h3>
<pre><code>ALTER TABLE table_name 
ADD COLUMN column_name datatype;
</code></pre>

<h3>1.2 Add Multiple Columns</h3>
<pre><code>ALTER TABLE table_name 
ADD COLUMN c1 int,
ADD COLUMN c2 text;
</code></pre>

<h3>1.3 Drop Column</h3>
<pre><code>ALTER TABLE table_name 
DROP COLUMN column_name;
</code></pre>

<h3>Drop Column with CASCADE</h3>
<pre><code>ALTER TABLE table_name 
DROP COLUMN column_name CASCADE;
</code></pre>

<h3>1.4 Rename Column</h3>
<pre><code>ALTER TABLE table_name 
RENAME COLUMN old_name TO new_name;
</code></pre>

<h3>1.5 Change Data Type</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name TYPE new_datatype;
</code></pre>

<h4>With USING</h4>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN price TYPE int USING price::int;
</code></pre>

<h3>1.6 Set Default</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name SET DEFAULT 100;
</code></pre>

<h3>1.7 Drop Default</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name DROP DEFAULT;
</code></pre>

<h3>1.8 Set NOT NULL</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name SET NOT NULL;
</code></pre>

<h3>1.9 Drop NOT NULL</h3>
<pre><code>ALTER TABLE table_name 
ALTER COLUMN column_name DROP NOT NULL;
</code></pre>

<h3>1.10 Rename Table</h3>
<pre><code>ALTER TABLE old_table 
RENAME TO new_table;
</code></pre>

<h3>1.11 Add Constraint</h3>

<h4>Primary Key</h4>
<pre><code>ALTER TABLE table_name 
ADD CONSTRAINT pk_name PRIMARY KEY (column_name);
</code></pre>

<h4>Unique</h4>
<pre><code>ALTER TABLE table_name 
ADD CONSTRAINT u_name UNIQUE (column_name);
</code></pre>

<h4>Foreign Key</h4>
<pre><code>ALTER TABLE child_table 
ADD CONSTRAINT fk_name FOREIGN KEY (column_name)
REFERENCES parent_table(parent_col);
</code></pre>

<h4>Check</h4>
<pre><code>ALTER TABLE table_name 
ADD CONSTRAINT chk_age CHECK (age > 0);
</code></pre>

<h3>1.12 Drop Constraint</h3>

<h4>Primary Key</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT pk_name;
</code></pre>

<h4>Unique</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT u_name;
</code></pre>

<h4>Foreign Key</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT fk_name;
</code></pre>

<h4>Check</h4>
<pre><code>ALTER TABLE table_name 
DROP CONSTRAINT chk_age;
</code></pre>

<h3>1.13 Add Auto-Increment Column</h3>

<h4>SERIAL</h4>
<pre><code>ALTER TABLE table_name 
ADD COLUMN id SERIAL;
</code></pre>

<h4>IDENTITY</h4>
<pre><code>ALTER TABLE table_name 
ADD COLUMN id INT GENERATED ALWAYS AS IDENTITY;
</code></pre>

<h3>1.14 Column Comment</h3>
<pre><code>COMMENT ON COLUMN table_name.column IS 'description';
</code></pre>

<h3>1.15 Table Comment</h3>
<pre><code>COMMENT ON TABLE table_name IS 'This is the employee table';
</code></pre>

<hr>

<h2>2. ALTER DATABASE</h2>

<h3>Rename Database</h3>
<pre><code>ALTER DATABASE old_name RENAME TO new_name;
</code></pre>

<h3>Change Owner</h3>
<pre><code>ALTER DATABASE db_name OWNER TO new_user;
</code></pre>

<h3>Change Collation</h3>
<pre><code>ALTER DATABASE db_name SET lc_collate TO 'en_US.utf8';
</code></pre>

<hr>

<h2>3. ALTER SCHEMA</h2>

<h3>Rename Schema</h3>
<pre><code>ALTER SCHEMA old_schema RENAME TO new_schema;
</code></pre>

<h3>Change Owner</h3>
<pre><code>ALTER SCHEMA schema_name OWNER TO user_name;
</code></pre>

<hr>

<h2>4. ALTER VIEW</h2>

<h3>Rename View</h3>
<pre><code>ALTER VIEW old_view RENAME TO new_view;
</code></pre>

<h3>Rename Column in View</h3>
<pre><code>ALTER VIEW view_name RENAME COLUMN old TO new;
</code></pre>

<hr>

<h2>5. ALTER FUNCTION</h2>

<h3>Rename Function</h3>
<pre><code>ALTER FUNCTION func_name(args) RENAME TO new_name;
</code></pre>

<h3>Change Owner</h3>
<pre><code>ALTER FUNCTION func_name(args) OWNER TO new_user;
</code></pre>

<hr>

<h2>6. ALTER INDEX</h2>

<h3>Rename Index</h3>
<pre><code>ALTER INDEX old_index RENAME TO new_index;
</code></pre>

<h3>Rebuild Index</h3>
<pre><code>ALTER INDEX index_name REBUILD;
</code></pre>

<hr>

<h2>7. ALTER SEQUENCE</h2>

<h3>Restart Sequence</h3>
<pre><code>ALTER SEQUENCE seq_name RESTART WITH 1;
</code></pre>

<h3>Change Increment</h3>
<pre><code>ALTER SEQUENCE seq_name INCREMENT BY 5;
</code></pre>
</section>

<hr>

<section id="ddl-part-3">
    <h2>DDL : DROP / TRUNCATE / RENAME / COMMENT</h2>
    <hr>

    <!-- DROP SECTION -->
    <h2>1. DROP Commands</h2>

    <h3>1.1 DROP TABLE</h3>
    <pre><code>DROP TABLE table_name;</code></pre>

    <h3>1.2 DROP TABLE IF EXISTS</h3>
    <pre><code>DROP TABLE IF EXISTS table_name;</code></pre>

    <h3>1.3 DROP TABLE CASCADE</h3>
    <pre><code>DROP TABLE table_name CASCADE;
-- Removes table + objects depending on it
</code></pre>

    <h3>1.4 DROP DATABASE</h3>
    <pre><code>DROP DATABASE db_name;</code></pre>

    <h3>1.5 DROP DATABASE IF EXISTS</h3>
    <pre><code>DROP DATABASE IF EXISTS db_name;</code></pre>

    <h3>1.6 DROP SCHEMA</h3>
    <pre><code>DROP SCHEMA schema_name;</code></pre>

    <h3>1.7 DROP SCHEMA CASCADE</h3>
    <pre><code>DROP SCHEMA schema_name CASCADE;
-- Removes schema + all objects inside
</code></pre>

    <h3>1.8 DROP VIEW</h3>
    <pre><code>DROP VIEW view_name;</code></pre>

    <h3>1.9 DROP MATERIALIZED VIEW</h3>
    <pre><code>DROP MATERIALIZED VIEW mv_name;</code></pre>

    <h3>1.10 DROP INDEX</h3>
    <pre><code>DROP INDEX index_name;</code></pre>

    <h3>1.11 DROP SEQUENCE</h3>
    <pre><code>DROP SEQUENCE seq_name;</code></pre>

    <h3>1.12 DROP FUNCTION</h3>
    <pre><code>DROP FUNCTION function_name(args);</code></pre>

    <h3>1.13 DROP TRIGGER</h3>
    <pre><code>DROP TRIGGER trigger_name ON table_name;</code></pre>

    <h3>1.14 DROP TYPE</h3>
    <pre><code>DROP TYPE custom_type;</code></pre>

    <hr>

    <!-- TRUNCATE SECTION -->
    <h2>2. TRUNCATE</h2>

    <h3>2.1 Basic Truncate</h3>
    <pre><code>TRUNCATE TABLE table_name;
-- Removes all rows, keeps structure
</code></pre>

    <h3>2.2 Truncate Multiple Tables</h3>
    <pre><code>TRUNCATE TABLE table1, table2;</code></pre>

    <h3>2.3 TRUNCATE CASCADE</h3>
    <pre><code>TRUNCATE TABLE table_name CASCADE;
-- Removes dependent table rows
</code></pre>

    <h3>2.4 Restart Identity</h3>
    <pre><code>TRUNCATE TABLE table_name RESTART IDENTITY;
-- Resets serial/identity values
</code></pre>

    <h3>2.5 Continue Identity</h3>
    <pre><code>TRUNCATE TABLE table_name CONTINUE IDENTITY;
-- Does not reset serial values
</code></pre>

    <hr>

    <!-- RENAME SECTION -->
    <h2>3. RENAME</h2>

    <h3>3.1 Rename Table</h3>
    <pre><code>ALTER TABLE old_name RENAME TO new_name;</code></pre>

    <h3>3.2 Rename Column</h3>
    <pre><code>ALTER TABLE table_name 
RENAME COLUMN old_col TO new_col;</code></pre>

    <h3>3.3 Rename View</h3>
    <pre><code>ALTER VIEW old_view RENAME TO new_view;</code></pre>

    <h3>3.4 Rename Index</h3>
    <pre><code>ALTER INDEX old_index RENAME TO new_index;</code></pre>

    <h3>3.5 Rename Sequence</h3>
    <pre><code>ALTER SEQUENCE old_seq RENAME TO new_seq;</code></pre>

    <h3>3.6 Rename Database</h3>
    <pre><code>ALTER DATABASE old_name RENAME TO new_name;</code></pre>

    <h3>3.7 Rename Schema</h3>
    <pre><code>ALTER SCHEMA old_schema RENAME TO new_schema;</code></pre>

    <hr>

    <!-- COMMENT SECTION -->
    <h2>4. COMMENT</h2>

    <h3>4.1 Comment on Table</h3>
    <pre><code>COMMENT ON TABLE employees 
IS 'Employee master table';</code></pre>

    <h3>4.2 Comment on Column</h3>
    <pre><code>COMMENT ON COLUMN employees.salary 
IS 'Salary stored in INR';</code></pre>

    <h3>4.3 Comment on Database</h3>
    <pre><code>COMMENT ON DATABASE mydb 
IS 'Production database';</code></pre>

    <h3>4.4 Comment on Schema</h3>
    <pre><code>COMMENT ON SCHEMA sales 
IS 'Contains sales-related tables';</code></pre>

    <h3>4.5 Comment on Function</h3>
    <pre><code>COMMENT ON FUNCTION calculate_bonus(int) 
IS 'Calculates employee bonus';</code></pre>

    <h3>4.6 Comment on View</h3>
    <pre><code>COMMENT ON VIEW emp_view 
IS 'View for employee details';</code></pre>

    <h3>4.7 Comment on Sequence</h3>
    <pre><code>COMMENT ON SEQUENCE emp_seq 
IS 'Employee ID sequence';</code></pre>

</section>

<hr>

<section id="dml">
    <h1>DML (Data Manipulation Language)</h1>
    <hr>

    <!-- INSERT -->
    <h2>1. INSERT</h2>

    <h3>1.1 Insert into all columns</h3>
    <pre><code>INSERT INTO employees
VALUES (1, 'Rahul', 50000, 'IT');</code></pre>

    <h3>1.2 Insert into specific columns</h3>
    <pre><code>INSERT INTO employees (id, name)
VALUES (2, 'Karan');</code></pre>

    <h3>1.3 Insert multiple rows</h3>
    <pre><code>INSERT INTO employees (id, name, salary, dept)
VALUES 
(3, 'Meena', 45000, 'HR'),
(4, 'Arjun', 55000, 'IT');</code></pre>

    <h3>1.4 Insert using SELECT</h3>
    <pre><code>INSERT INTO backup_employees
SELECT * FROM employees;</code></pre>

    <h3>1.5 Insert with DEFAULT</h3>
    <pre><code>INSERT INTO employees (id, name, salary)
VALUES (5, 'Anu', DEFAULT);</code></pre>

    <h3>1.6 Insert JSON values</h3>
    <pre><code>INSERT INTO products (id, details)
VALUES (1, '{"color":"red","size":"L"}');</code></pre>

    <hr>

    <!-- UPDATE -->
    <h2>2. UPDATE</h2>

    <h3>2.1 Basic Update</h3>
    <pre><code>UPDATE employees
SET salary = 60000
WHERE id = 1;</code></pre>

    <h3>2.2 Update multiple columns</h3>
    <pre><code>UPDATE employees
SET salary = 70000, dept = 'Finance'
WHERE id = 2;</code></pre>

    <h3>2.3 Update all rows</h3>
    <pre><code>UPDATE employees
SET dept = 'General';</code></pre>

    <h3>2.4 Update using subquery</h3>
    <pre><code>UPDATE employees e
SET salary = salary + 5000
WHERE e.dept IN (
    SELECT dept FROM high_performance
);</code></pre>

    <h3>2.5 Update with RETURNING (PostgreSQL)</h3>
    <pre><code>UPDATE employees
SET salary = salary + 1000
WHERE id = 3
RETURNING *;</code></pre>

    <hr>

    <!-- DELETE -->
    <h2>3. DELETE</h2>

    <h3>3.1 Delete specific rows</h3>
    <pre><code>DELETE FROM employees
WHERE id = 4;</code></pre>

    <h3>3.2 Delete all rows</h3>
    <pre><code>DELETE FROM employees;</code></pre>

    <h3>3.3 Delete using subquery</h3>
    <pre><code>DELETE FROM employees
WHERE id IN (
    SELECT emp_id FROM inactive_employees
);</code></pre>

    <h3>3.4 DELETE with RETURNING</h3>
    <pre><code>DELETE FROM employees
WHERE id = 5
RETURNING *;</code></pre>

    <hr>

    <!-- SELECT -->
    <h2>4. SELECT (Most Important DML)</h2>

    <h3>4.1 Select all rows</h3>
    <pre><code>SELECT * FROM employees;</code></pre>

    <h3>4.2 Select specific columns</h3>
    <pre><code>SELECT name, salary FROM employees;</code></pre>

    <h3>4.3 DISTINCT values</h3>
    <pre><code>SELECT DISTINCT dept FROM employees;</code></pre>

    <h3>4.4 WHERE condition</h3>
    <pre><code>SELECT * FROM employees
WHERE salary > 50000;</code></pre>

    <h3>4.5 AND / OR</h3>
    <pre><code>SELECT * FROM employees
WHERE dept = 'IT' AND salary > 40000;</code></pre>

    <h3>4.6 ORDER BY</h3>
    <pre><code>SELECT * FROM employees
ORDER BY salary DESC;</code></pre>

    <h3>4.7 LIMIT</h3>
    <pre><code>SELECT * FROM employees
LIMIT 5;</code></pre>

    <h3>4.8 OFFSET</h3>
    <pre><code>SELECT * FROM employees
LIMIT 10 OFFSET 20;</code></pre>

    <h3>4.9 BETWEEN</h3>
    <pre><code>SELECT * FROM employees
WHERE salary BETWEEN 30000 AND 70000;</code></pre>

    <h3>4.10 IN</h3>
    <pre><code>SELECT * FROM employees
WHERE dept IN ('IT','HR');</code></pre>

    <h3>4.11 LIKE</h3>
    <pre><code>SELECT * FROM employees
WHERE name LIKE 'A%';</code></pre>

    <h3>4.12 ILIKE (Case-insensitive)</h3>
    <pre><code>SELECT * FROM employees
WHERE name ILIKE '%an%';</code></pre>

    <h3>4.13 Aggregates</h3>
    <pre><code>SELECT COUNT(*), AVG(salary), SUM(salary)
FROM employees;</code></pre>

    <h3>4.14 GROUP BY</h3>
    <pre><code>SELECT dept, COUNT(*)
FROM employees
GROUP BY dept;</code></pre>

    <h3>4.15 HAVING</h3>
    <pre><code>SELECT dept, COUNT(*)
FROM employees
GROUP BY dept
HAVING COUNT(*) > 2;</code></pre>

    <h3>4.16 Subquery</h3>
    <pre><code>SELECT name FROM employees
WHERE salary > (
    SELECT AVG(salary) FROM employees
);</code></pre>

    <h3>4.17 JOIN (basic)</h3>
    <pre><code>SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept = d.id;</code></pre>

</section>


<hr>

<section id="dql">
    <h1>DQL (Data Query Language)</h1>
    <p>DQL is used to retrieve data from the database. The primary command is <b>SELECT</b>.</p>
    <hr>

    <!-- SELECT -->
    <h2>1. SELECT</h2>

    <h3>1.1 Select all columns</h3>
    <pre><code>SELECT * FROM employees;</code></pre>

    <h3>1.2 Select specific columns</h3>
    <pre><code>SELECT name, salary FROM employees;</code></pre>

    <h3>1.3 Select with expressions</h3>
    <pre><code>SELECT name, salary * 12 AS yearly_salary
FROM employees;</code></pre>

    <h3>1.4 Select with column alias</h3>
    <pre><code>SELECT name AS employee_name, dept AS department
FROM employees;</code></pre>

    <h3>1.5 Select with table alias</h3>
    <pre><code>SELECT e.name, e.salary
FROM employees e;</code></pre>

    <hr>

    <!-- WHERE -->
    <h2>2. WHERE</h2>

    <h3>2.1 Basic condition</h3>
    <pre><code>SELECT * FROM employees
WHERE salary > 50000;</code></pre>

    <h3>2.2 AND / OR</h3>
    <pre><code>SELECT * FROM employees
WHERE dept = 'IT' AND salary > 45000;</code></pre>

    <h3>2.3 BETWEEN</h3>
    <pre><code>SELECT * FROM employees
WHERE salary BETWEEN 30000 AND 60000;</code></pre>

    <h3>2.4 IN</h3>
    <pre><code>SELECT * FROM employees
WHERE dept IN ('IT', 'HR');</code></pre>

    <h3>2.5 LIKE</h3>
    <pre><code>SELECT * FROM employees
WHERE name LIKE 'A%';</code></pre>

    <h3>2.6 ILIKE (case-insensitive)</h3>
    <pre><code>SELECT * FROM employees
WHERE name ILIKE '%an%';</code></pre>

    <h3>2.7 IS NULL / IS NOT NULL</h3>
    <pre><code>SELECT * FROM employees
WHERE salary IS NULL;</code></pre>

    <hr>

    <!-- ORDER BY -->
    <h2>3. ORDER BY</h2>

    <h3>3.1 Ascending</h3>
    <pre><code>SELECT * FROM employees
ORDER BY salary ASC;</code></pre>

    <h3>3.2 Descending</h3>
    <pre><code>SELECT * FROM employees
ORDER BY salary DESC;</code></pre>

    <h3>3.3 Multiple columns</h3>
    <pre><code>SELECT * FROM employees
ORDER BY dept ASC, salary DESC;</code></pre>

    <hr>

    <!-- LIMIT & OFFSET -->
    <h2>4. LIMIT & OFFSET</h2>

    <h3>4.1 LIMIT</h3>
    <pre><code>SELECT * FROM employees
LIMIT 5;</code></pre>

    <h3>4.2 OFFSET</h3>
    <pre><code>SELECT * FROM employees
OFFSET 10;</code></pre>

    <h3>4.3 LIMIT + OFFSET</h3>
    <pre><code>SELECT * FROM employees
LIMIT 10 OFFSET 20;</code></pre>

    <h3>4.4 Pagination example</h3>
    <pre><code>-- Page number = 3, page size = 10
SELECT * FROM employees
LIMIT 10 OFFSET 20;</code></pre>

    <hr>

    <!-- DISTINCT -->
    <h2>5. DISTINCT</h2>

    <h3>5.1 Remove duplicates</h3>
    <pre><code>SELECT DISTINCT dept
FROM employees;</code></pre>

    <h3>5.2 DISTINCT on multiple columns</h3>
    <pre><code>SELECT DISTINCT dept, salary
FROM employees;</code></pre>

    <h3>5.3 DISTINCT ON (PostgreSQL only)</h3>
    <pre><code>SELECT DISTINCT ON (dept) dept, name, salary
FROM employees
ORDER BY dept, salary DESC;</code></pre>
    <p>→ Keeps the row with highest salary per department.</p>

</section>

<hr>

<section>
  <h2>🔹 Full SQL Conditions (Comparison + Logical + Pattern + NULL + Subquery Operators)</h2>

  <p>This section covers all important SQL conditional operators used inside WHERE clauses.</p>

  <!-- Comparison Operators -->
  <h3>1️⃣ Comparison Operators</h3>
  <pre>
=     → Equal  
>     → Greater than  
<     → Less than  
>=    → Greater than or equal  
<=    → Less than or equal  
!= or <> → Not equal  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM employees
WHERE salary >= 30000;
  </pre>

  <hr>

  <!-- Logical Operators -->
  <h3>2️⃣ Logical Operators</h3>
  <pre>
AND   → All conditions must be TRUE  
OR    → At least one condition is TRUE  
NOT   → Negates a condition
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM employees
WHERE department = 'IT' AND salary > 40000;
  </pre>

  <hr>

  <!-- BETWEEN -->
  <h3>3️⃣ BETWEEN & NOT BETWEEN</h3>
  <p>Checks if a value lies inside a range (inclusive).</p>

  <pre>
BETWEEN      → value in range  
NOT BETWEEN  → value outside range  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM products
WHERE price BETWEEN 100 AND 500;

SELECT * FROM products
WHERE price NOT BETWEEN 100 AND 500;
  </pre>

  <hr>

  <!-- LIKE and ILIKE -->
  <h3>4️⃣ LIKE & ILIKE</h3>
  <p>
  LIKE → Case-sensitive pattern match<br>
  ILIKE → Case-insensitive pattern match (PostgreSQL)
  </p>

  <h4>Wildcards:</h4>
  <pre>
%  → zero or more characters  
_  → one character  
  </pre>

  <h4>Examples:</h4>
  <pre>
SELECT * FROM customers WHERE name LIKE 'A%';
SELECT * FROM customers WHERE name ILIKE '%john%';
  </pre>

  <hr>

  <!-- IN -->
  <h3>5️⃣ IN & NOT IN</h3>
  <p>Checks if a value exists inside a list.</p>

  <pre>
IN      → value exists in list  
NOT IN  → value NOT in list  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM orders
WHERE status IN ('Pending', 'Shipped');

SELECT * FROM orders
WHERE status NOT IN ('Cancelled', 'Returned');
  </pre>

  <hr>

  <!-- EXISTS -->
  <h3>6️⃣ EXISTS & NOT EXISTS</h3>
  <p>Checks if a subquery returns at least one row.</p>

  <pre>
EXISTS      → TRUE if subquery returns ≥1 row  
NOT EXISTS  → TRUE if subquery returns 0 rows  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT name FROM customers c
WHERE EXISTS (
  SELECT 1 FROM orders o
  WHERE o.customer_id = c.id
);

SELECT name FROM customers c
WHERE NOT EXISTS (
  SELECT 1 FROM orders o
  WHERE o.customer_id = c.id
);
  </pre>

  <hr>

  <!-- NULL Check -->
  <h3>7️⃣ IS NULL & IS NOT NULL</h3>
  <p>Used to check NULL values ( = or != cannot be used ).</p>

  <pre>
IS NULL       → value is NULL  
IS NOT NULL   → value is NOT NULL  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM employees WHERE bonus IS NULL;
SELECT * FROM employees WHERE bonus IS NOT NULL;
  </pre>

  <hr>

  <!-- ANY & SOME -->
  <h3>8️⃣ ANY & SOME (same meaning)</h3>
  <p>Used with subqueries — condition is TRUE if it matches **any value** returned.</p>

  <pre>
ANY → TRUE if condition matches at least one value  
SOME → SAME as ANY  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM products
WHERE price > ANY (SELECT price FROM products WHERE category='Electronics');
  </pre>

  <hr>

  <!-- ALL -->
  <h3>9️⃣ ALL Operator</h3>
  <p>Condition must be TRUE for **all values** in the subquery.</p>

  <h4>Example:</h4>
  <pre>
SELECT * FROM products
WHERE price > ALL (SELECT price FROM products WHERE category='Mobile');
  </pre>

  <hr>

  <!-- Extra -->
  <h3>🔟 Other Important Operators (Extra)</h3>
  <pre>
= ANY(...)       → Same as IN  
!= ALL(...)      → No value should match  
value IS TRUE    → Boolean check (PostgreSQL)  
value IS FALSE  
value IS UNKNOWN  
  </pre>

  <h4>Example:</h4>
  <pre>
SELECT * FROM flags WHERE is_active IS TRUE;
  </pre>

</section>

<hr>

<section>
  <h2>🔹 SQL Joins & Set Operations</h2>
  <p>
    Joins are used to combine rows from two or more tables based on a related column.
    Below are all common joins with examples and outputs.
  </p>

  <!-- Sample Tables -->
  <h3>Sample Tables Used in Examples</h3>

  <h4>Employees Table</h4>
  <pre>
 id | name     | dept_id
----+----------+---------
 1  | Aathi    |   10
 2  | John     |   20
 3  | Kumar    |   10
 4  | Priya    |   30
 5  | David    |  NULL
  </pre>

  <h4>Departments Table</h4>
  <pre>
 dept_id | dept_name
---------+-----------
   10    | IT
   20    | HR
   40    | Sales
  </pre>

  <hr>

  <!-- 1. INNER JOIN -->
  <h3>1️⃣ INNER JOIN</h3>
  <p>Returns rows where matching values exist in both tables.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
INNER JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
  </pre>

  <hr>

  <!-- 2. LEFT JOIN -->
  <h3>2️⃣ LEFT JOIN</h3>
  <p>Returns all rows from LEFT table + matching rows from RIGHT table.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
LEFT JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
 Priya | NULL
 David | NULL
  </pre>

  <hr>

  <!-- 3. RIGHT JOIN -->
  <h3>3️⃣ RIGHT JOIN</h3>
  <p>Returns all rows from RIGHT table + matching rows from LEFT table.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
RIGHT JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
 NULL  | Sales     -- dept 40 has no employees
  </pre>

  <hr>

  <!-- 4. FULL OUTER JOIN -->
  <h3>4️⃣ FULL OUTER JOIN</h3>
  <p>Returns ALL rows from both tables (matched + unmatched).</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
FULL JOIN departments d
ON e.dept_id = d.dept_id;
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Kumar | IT
 John  | HR
 Priya | NULL
 David | NULL
 NULL  | Sales
  </pre>

  <hr>

  <!-- 5. CROSS JOIN -->
  <h3>5️⃣ CROSS JOIN</h3>
  <p>Creates a Cartesian product (every row combined with every row).</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
CROSS JOIN departments d;
  </pre>

  <h4>Output (Partial):</h4>
  <pre>
 name  | dept_name
-------+-----------
 Aathi | IT
 Aathi | HR
 Aathi | Sales
 John  | IT
 John  | HR
 ... many more rows ...
  </pre>

  <hr>

  <!-- 6. SELF JOIN -->
  <h3>6️⃣ SELF JOIN</h3>
  <p>A table joins with itself. Example: employees reporting to managers.</p>

  <pre>
SELECT e.name AS employee, m.name AS manager
FROM employees e
LEFT JOIN employees m
ON e.manager_id = m.id;
  </pre>

  <h4>Output (Example):</h4>
  <pre>
 employee | manager
----------+---------
 Kumar    | Aathi
 Priya    | John
 David    | NULL
  </pre>

  <hr>

  <!-- 7. NATURAL JOIN -->
  <h3>7️⃣ NATURAL JOIN</h3>
  <p>
    Automatically joins tables using columns with the SAME NAME.<br>
    ⚠ Not recommended for production because unpredictable.
  </p>

  <pre>
SELECT *
FROM employees
NATURAL JOIN departments;
  </pre>

  <hr>

  <!-- 8. USING clause -->
  <h3>8️⃣ USING Clause</h3>
  <p>Cleaner join when both tables share the same column name.</p>

  <pre>
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d
USING (dept_id);
  </pre>

  <hr>

  <!-- 9. LATERAL JOIN -->
  <h3>9️⃣ LATERAL JOIN (PostgreSQL Only)</h3>
  <p>
    Allows a subquery to depend on each row of the outer table.<br>
    Super useful for JSON, arrays, and complex calculations.
  </p>

  <pre>
SELECT e.name, x.skill
FROM employees e,
LATERAL unnest(e.skills) AS x(skill);
  </pre>

  <h4>Output:</h4>
  <pre>
 name  | skill
-------+--------
 Aathi | Java
 Aathi | SQL
 John  | Python
  </pre>

  <hr>

  <!-- Set Operators -->
  <h2>🔹 Set Operators</h2>

  <p>Used to combine results of two SELECT queries.</p>

  <!-- UNION -->
  <h3>1️⃣ UNION</h3>
  <p>Removes duplicates (distinct).</p>

  <pre>
SELECT name FROM table1
UNION
SELECT name FROM table2;
  </pre>

  <!-- UNION ALL -->
  <h3>2️⃣ UNION ALL</h3>
  <p>Keeps duplicates.</p>

  <pre>
SELECT name FROM table1
UNION ALL
SELECT name FROM table2;
  </pre>

  <!-- INTERSECT -->
  <h3>3️⃣ INTERSECT</h3>
  <p>Returns only common rows.</p>

  <pre>
SELECT name FROM table1
INTERSECT
SELECT name FROM table2;
  </pre>

  <!-- EXCEPT -->
  <h3>4️⃣ EXCEPT</h3>
  <p>Returns rows from first query that are NOT in second.</p>

  <pre>
SELECT name FROM table1
EXCEPT
SELECT name FROM table2;
  </pre>

  <hr>

  <!-- Extra -->
  <h3>5️⃣ Important Rules for Set Operators</h3>
  <pre>
✔ Both SELECT queries must have same number of columns  
✔ Column order must match  
✔ Data types must be compatible  
✔ ORDER BY only allowed at end  
  </pre>

</section>

<hr>

<section>
  <h2>🔹 SQL Subqueries</h2>

  <p>
    A subquery is a query inside another query. It can return a single value,
    a row, multiple rows, or a complete table.
  </p>

  <hr>

  <!-- Scalar Subquery -->
  <h3>1️⃣ Scalar Subquery (Returns ONE value)</h3>
  <p>Used when subquery returns exactly one value.</p>

  <pre>
SELECT name, salary
FROM employees
WHERE salary > (
    SELECT AVG(salary) FROM employees
);
  </pre>

  <h4>Output:</h4>
  <pre>
 name   | salary
--------+---------
 Aathi  | 60000
 Kumar  | 55000
  </pre>

  <hr>

  <!-- Row Subquery -->
  <h3>2️⃣ Row Subquery (Returns ONE complete row)</h3>

  <pre>
SELECT * FROM employees
WHERE (dept_id, salary) = (
    SELECT dept_id, MAX(salary)
    FROM employees
    GROUP BY dept_id
    LIMIT 1
);
  </pre>

  <hr>

  <!-- Table Subquery -->
  <h3>3️⃣ Table Subquery (Used like a table)</h3>

  <pre>
SELECT * FROM (
    SELECT name, salary FROM employees
    WHERE salary > 50000
) AS high_salary;
  </pre>

  <hr>

  <!-- Single Row -->
  <h3>4️⃣ Single-Row Subquery</h3>

  <pre>
SELECT name
FROM employees
WHERE salary = (
    SELECT MAX(salary) FROM employees
);
  </pre>

  <hr>

  <!-- Multi Row -->
  <h3>5️⃣ Multi-Row Subquery</h3>
  <p>Uses IN, ANY, SOME, ALL.</p>

  <pre>
SELECT name
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments
    WHERE location = 'Chennai'
);
  </pre>

  <hr>

  <!-- Multi Column -->
  <h3>6️⃣ Multi-Column Subquery</h3>

  <pre>
SELECT name
FROM employees
WHERE (dept_id, salary) IN (
    SELECT dept_id, MAX(salary)
    FROM employees
    GROUP BY dept_id
);
  </pre>

  <hr>

  <!-- Correlated Subquery -->
  <h3>7️⃣ Correlated Subquery</h3>
  <p>
    Subquery depends on outer query. Runs once for each row of outer query.
  </p>

  <pre>
SELECT e1.name, e1.salary
FROM employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM employees e2
    WHERE e2.dept_id = e1.dept_id
);
  </pre>

  <h4>Output:</h4>
  <pre>
 name   | salary
--------+---------
 Aathi  | 60000
 John   | 55000
  </pre>

  <hr>

  <!-- EXISTS vs IN -->
  <h3>8️⃣ EXISTS vs IN (Deep Explanation)</h3>

  <h4>IN → Compares VALUES</h4>
  <p>Used when subquery returns a list of scalar values.</p>

  <pre>
SELECT name
FROM employees
WHERE dept_id IN (
    SELECT dept_id FROM departments
);
  </pre>

  <h4>EXISTS → Checks if at least one row exists</h4>

  <pre>
SELECT name
FROM employees e
WHERE EXISTS (
    SELECT 1
    FROM departments d
    WHERE d.dept_id = e.dept_id
);
  </pre>

  <h4>Performance:</h4>
  <pre>
✔ EXISTS → faster for large tables  
✔ IN → loads all values, slower  
✔ EXISTS stops as soon as ONE match is found  
  </pre>

  <h4>NOT EXISTS vs NOT IN:</h4>
  <pre>
NOT IN fails if NULL exists  
NOT EXISTS is safe with NULLs → always preferred
  </pre>

  <hr>

  <!-- Subquery inside SELECT -->
  <h3>9️⃣ Subquery inside SELECT</h3>

  <pre>
SELECT
    name,
    salary,
    (SELECT AVG(salary) FROM employees) AS avg_salary
FROM employees;
  </pre>

  <h4>Output:</h4>
  <pre>
 name   | salary | avg_salary
--------+--------+------------
 Aathi  | 60000  | 45000
 John   | 55000  | 45000
 Priya  | 30000  | 45000
  </pre>

  <hr>

  <!-- Subquery inside FROM -->
  <h3>🔟 Subquery inside FROM (Inline View)</h3>

  <pre>
SELECT name, salary
FROM (
    SELECT name, salary
    FROM employees
    WHERE salary > 40000
) AS temp;
  </pre>

  <hr>

  <!-- ANY SOME ALL -->
  <h3>1️⃣1️⃣ ANY / SOME / ALL</h3>

  <h4>ANY / SOME → match ANY value</h4>
  <pre>
SELECT name
FROM employees
WHERE salary > ANY (
    SELECT salary FROM employees WHERE dept_id = 10
);
  </pre>

  <h4>ALL → must be true for all values</h4>
  <pre>
SELECT name
FROM employees
WHERE salary > ALL (
    SELECT salary FROM employees WHERE dept_id = 10
);
  </pre>

</section>

<hr>

<section>
  <h2>🔹 SQL Constraints</h2>

  <p>
    Constraints are rules applied on table columns to maintain data integrity.
    Below are all major PostgreSQL constraints with examples.
  </p>

  <hr>

  <!-- PRIMARY KEY -->
  <h3>1️⃣ PRIMARY KEY</h3>
  <p>
    Ensures column has UNIQUE and NOT NULL values.  
    A table can have only one primary key (can be single or composite).
  </p>

  <h4>Example:</h4>
  <pre>
CREATE TABLE students (
    id INT PRIMARY KEY,
    name TEXT
);
  </pre>

  <h4>Composite Primary Key:</h4>
  <pre>
CREATE TABLE enrollment (
    student_id INT,
    course_id INT,
    PRIMARY KEY(student_id, course_id)
);
  </pre>

  <hr>

  <!-- FOREIGN KEY -->
  <h3>2️⃣ FOREIGN KEY</h3>
  <p>
    Links two tables. Ensures referenced value exists in parent table.
  </p>

  <h4>Example:</h4>
  <pre>
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name TEXT
);

CREATE TABLE employees (
    id INT PRIMARY KEY,
    name TEXT,
    dept_id INT REFERENCES departments(dept_id)
);
  </pre>

  <h4>Foreign Key with Cascade Options:</h4>
  <pre>
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name TEXT,
    dept_id INT,
    FOREIGN KEY(dept_id)
      REFERENCES departments(dept_id)
      ON DELETE SET NULL
      ON UPDATE CASCADE
);
  </pre>

  <pre>
ON DELETE CASCADE     → delete related rows
ON DELETE SET NULL    → set dept_id = NULL when parent deleted
ON UPDATE CASCADE     → update child automatically
  </pre>

  <hr>

  <!-- UNIQUE -->
  <h3>3️⃣ UNIQUE</h3>
  <p>
    Ensures all column values are different. NULL is allowed.
  </p>

  <pre>
CREATE TABLE users (
    email TEXT UNIQUE,
    username TEXT UNIQUE
);
  </pre>

  <h4>Composite UNIQUE key:</h4>
  <pre>
CREATE TABLE orders (
    order_id INT,
    item_id INT,
    UNIQUE(order_id, item_id)
);
  </pre>

  <hr>

  <!-- NOT NULL -->
  <h3>4️⃣ NOT NULL</h3>
  <p>Column cannot contain NULL values.</p>

  <pre>
CREATE TABLE products (
    id INT PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC NOT NULL
);
  </pre>

  <hr>

  <!-- CHECK -->
  <h3>5️⃣ CHECK Constraint</h3>
  <p>Ensures values meet a condition.</p>

  <pre>
CREATE TABLE employees (
    id INT PRIMARY KEY,
    age INT CHECK (age >= 18),
    salary NUMERIC CHECK (salary > 0)
);
  </pre>

  <h4>Multiple CHECK Constraints:</h4>
  <pre>
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    balance NUMERIC,
    CHECK (balance >= 0 AND balance <= 100000)
);
  </pre>

  <hr>

  <!-- DEFAULT -->
  <h3>6️⃣ DEFAULT</h3>
  <p>Assigns a default value if no value is provided.</p>

  <pre>
CREATE TABLE orders (
    id INT PRIMARY KEY,
    status TEXT DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT NOW()
);
  </pre>

  <hr>

  <!-- AUTO-INCREMENT -->
  <h3>7️⃣ AUTO-INCREMENT</h3>

  <h4>1. SERIAL (older method)</h4>
  <pre>
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    name TEXT
);
  </pre>

  <p>Automatically creates:</p>
  <pre>
id integer NOT NULL DEFAULT nextval('students_id_seq')
  </pre>

  <h4>2. IDENTITY (preferred modern method)</h4>
  <pre>
CREATE TABLE students (
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name TEXT
);
  </pre>

  <h4>Identity Options:</h4>
  <pre>
GENERATED ALWAYS AS IDENTITY
  → cannot manually insert values

GENERATED BY DEFAULT AS IDENTITY
  → allows manual insert if needed
  </pre>

  <hr>

  <!-- Add Constraints Later -->
  <h3>8️⃣ Adding Constraints AFTER Table Creation</h3>

  <!-- Add PK -->
  <h4>Add Primary Key:</h4>
  <pre>
ALTER TABLE students
ADD CONSTRAINT pk_students PRIMARY KEY(id);
  </pre>

  <!-- Add Unique -->
  <h4>Add Unique:</h4>
  <pre>
ALTER TABLE users
ADD CONSTRAINT unique_email UNIQUE(email);
  </pre>

  <!-- Add Foreign Key -->
  <h4>Add Foreign Key:</h4>
  <pre>
ALTER TABLE employees
ADD CONSTRAINT fk_dept
FOREIGN KEY(dept_id) REFERENCES departments(dept_id);
  </pre>

  <!-- Add Check -->
  <h4>Add Check:</h4>
  <pre>
ALTER TABLE employees
ADD CONSTRAINT check_salary CHECK(salary > 0);
  </pre>

  <hr>

  <!-- Remove Constraints -->
  <h3>9️⃣ Dropping Constraints</h3>

  <pre>
ALTER TABLE table_name DROP CONSTRAINT constraint_name;
  </pre>

  <h4>Examples:</h4>
  <pre>
ALTER TABLE employees DROP CONSTRAINT fk_dept;
ALTER TABLE users DROP CONSTRAINT unique_email;
ALTER TABLE students DROP CONSTRAINT pk_students;
  </pre>

</section>

<hr>

<section id="referential-integrity">
  <h2>🔗 Referential Integrity Actions (ON DELETE / ON UPDATE)</h2>

  <p>
    Referential actions define what should happen to the child table when the referenced row in the parent
    table is <b>deleted</b> or <b>updated</b>. These options apply to FOREIGN KEY constraints.
  </p>

  <h3>📝 Syntax</h3>
  <pre>
CREATE TABLE child_table (
    ...
    column REFERENCES parent_table(id)
        ON DELETE action
        ON UPDATE action
);
  </pre>

  <h3>📌 Available Actions</h3>

  <h3>1️⃣ ON DELETE / ON UPDATE CASCADE</h3>
  <p>Automatically deletes or updates the child rows when the parent row is deleted or updated.</p>

  <h4>Example</h4>
  <pre>
CREATE TABLE parent (
    id INT PRIMARY KEY
);

CREATE TABLE child (
    cid INT PRIMARY KEY,
    pid INT REFERENCES parent(id) ON DELETE CASCADE
);

INSERT INTO parent VALUES (1);
INSERT INTO child VALUES (101, 1);

DELETE FROM parent WHERE id = 1;
-- Child row with pid = 1 is also deleted.
  </pre>

  <h4>Output</h4>
  <pre>
child table → empty (child row deleted)
  </pre>

  <hr>

  <h3>2️⃣ ON DELETE / ON UPDATE SET NULL</h3>
  <p>Sets the foreign key column to NULL when the parent row is deleted/updated.</p>

  <pre>
CREATE TABLE child (
    cid INT PRIMARY KEY,
    pid INT REFERENCES parent(id) ON DELETE SET NULL
);

-- After deleting parent row: pid becomes NULL
  </pre>

  <pre>Output:
cid | pid
------------
101 | NULL
  </pre>

  <hr>

  <h3>3️⃣ ON DELETE / ON UPDATE SET DEFAULT</h3>
  <p>Sets the child FK to its DEFAULT value.</p>

  <pre>
CREATE TABLE child (
    cid INT PRIMARY KEY,
    pid INT DEFAULT 0 REFERENCES parent(id) ON DELETE SET DEFAULT
);
  </pre>

  <pre>Output:
cid | pid
------------
101 | 0
  </pre>

  <hr>

  <h3>4️⃣ ON DELETE / ON UPDATE RESTRICT</h3>
  <p>
    Prevents deletion or update of the parent row if it is referenced in the child table.
    (Check happens immediately.)
  </p>

  <pre>
DELETE FROM parent WHERE id = 1;
-- ERROR: update or delete on table "parent" violates foreign key constraint
  </pre>

  <hr>

  <h3>5️⃣ ON DELETE / ON UPDATE NO ACTION (DEFAULT)</h3>
  <p>
    Similar to RESTRICT, but constraint check happens at end of transaction.
  </p>

  <pre>
-- If child exists, deletion is blocked at commit time.
  </pre>

  <hr>

  <h3>📌 Summary Table</h3>

  <table>
    <tr>
      <th>Action</th>
      <th>Effect</th>
    </tr>
    <tr>
      <td>CASCADE</td>
      <td>Child rows auto-deleted/updated</td>
    </tr>
    <tr>
      <td>SET NULL</td>
      <td>Child FK becomes NULL</td>
    </tr>
    <tr>
      <td>SET DEFAULT</td>
      <td>Child FK gets its default value</td>
    </tr>
    <tr>
      <td>RESTRICT</td>
      <td>Stops parent deletion if child exists (immediate check)</td>
    </tr>
    <tr>
      <td>NO ACTION</td>
      <td>Stops parent deletion (checked at end of transaction)</td>
    </tr>
  </table>

  <hr>

  <h3>🎯 Best Practices</h3>
  <ul>
    <li>Use <b>CASCADE</b> when child rows depend entirely on parent.</li>
    <li>Use <b>SET NULL</b> when child should survive independently.</li>
    <li>Use <b>RESTRICT</b> to prevent accidental deletion of important data.</li>
    <li>Use <b>SET DEFAULT</b> only when default makes logical sense.</li>
  </ul>
</section>

<hr>

<section id="keys-concepts">
  <h2>🔑 Keys in Relational Databases</h2>
  <p>
    Keys help uniquely identify rows and maintain consistency in relational databases.  
    Below are all important keys you must know in PostgreSQL & SQL.
  </p>

  <hr>

  <h3>1️⃣ Candidate Key</h3>
  <p>
    A <b>candidate key</b> is a minimal set of attributes that can uniquely identify a record.  
    A table can have multiple candidate keys.
  </p>

  <h4>Example</h4>
  <pre>
STUDENT
---------------------------------------
roll_no (unique)
email   (unique)
phone   (unique)

Candidate keys → roll_no, email, phone
  </pre>

  <p>All qualified to become PRIMARY KEY, but only one is chosen.</p>

  <hr>

  <h3>2️⃣ Composite Key</h3>
  <p>
    A <b>composite key</b> is a key made of <b>two or more columns</b> used together to uniquely identify a row.
  </p>

  <h4>Example</h4>
  <pre>
ENROLLMENT(student_id, course_id, date)

Composite key → (student_id, course_id)
  </pre>

  <p>No single column uniquely identifies a row — but both together do.</p>

  <hr>

  <h3>3️⃣ Super Key</h3>
  <p>
    A <b>super key</b> is any set of attributes that uniquely identifies a row.  
    It can contain extra/unnecessary attributes.
  </p>

  <h4>Example</h4>
  <pre>
Candidate keys:
    roll_no
    email

Super keys:
    roll_no
    email
    (roll_no, name)
    (email, phone)
  </pre>

  <p>👉 A candidate key is a <b>minimal super key</b>.</p>

  <hr>

  <h3>4️⃣ Alternative Key</h3>
  <p>
    All candidate keys except the one chosen as PRIMARY KEY are called <b>alternative keys</b>.
  </p>

  <h4>Example</h4>
  <pre>
Candidate keys: roll_no, email, phone
PRIMARY KEY = roll_no

Alternative keys → email, phone
  </pre>

  <hr>

  <h3>5️⃣ Unique Key</h3>
  <p>
    A <b>unique key</b> ensures all values in a column are unique.  
    Unlike PRIMARY KEY:
  </p>
  <ul>
    <li>Unique key allows <b>NULL values</b>.</li>
    <li>Table can have many UNIQUE constraints.</li>
  </ul>

  <h4>Syntax</h4>
  <pre>
CREATE TABLE users (
    email TEXT UNIQUE,
    phone TEXT UNIQUE
);
  </pre>

  <hr>

  <h3>6️⃣ Referential Integrity (Foreign Key)</h3>
  <p>
    Referential integrity ensures the relationship between two tables remains valid using a <b>FOREIGN KEY</b>.
  </p>

  <h4>Example</h4>
  <pre>
CREATE TABLE department (
    id INT PRIMARY KEY,
    name TEXT
);

CREATE TABLE employee (
    emp_id INT PRIMARY KEY,
    dept_id INT REFERENCES department(id)
);
  </pre>

  <p>
    dept_id must exist in department(id).  
    Prevents inserting invalid data and maintains consistency.
  </p>

  <h4>Referential Actions</h4>
  <ul>
    <li>ON DELETE CASCADE</li>
    <li>ON UPDATE CASCADE</li>
    <li>ON DELETE SET NULL</li>
    <li>ON UPDATE SET DEFAULT</li>
    <li>RESTRICT</li>
    <li>NO ACTION (default)</li>
  </ul>

  <a href="#referential-integrity">Click here for full detailed explanation →</a>

  <hr>

  <h3>📌 Summary Table</h3>

  <table>
    <tr>
      <th>Key Type</th>
      <th>Description</th>
    </tr>

    <tr>
      <td>Candidate Key</td>
      <td>Minimal attributes that uniquely identify a record</td>
    </tr>

    <tr>
      <td>Composite Key</td>
      <td>Key made of multiple columns</td>
    </tr>

    <tr>
      <td>Super Key</td>
      <td>Any attributes that uniquely identify a record</td>
    </tr>

    <tr>
      <td>Alternative Key</td>
      <td>Candidate keys that are not primary key</td>
    </tr>

    <tr>
      <td>Unique Key</td>
      <td>Ensures all values are unique (allows NULL)</td>
    </tr>

    <tr>
      <td>Referential Integrity</td>
      <td>Maintains parent-child consistency using foreign keys</td>
    </tr>
  </table>

</section>

<hr>

<section id="tcl">
  <h2>🔹 TCL (Transaction Control Language)</h2>

  <p>
    TCL is used to manage <b>transactions</b> in a database.  
    A transaction is a group of SQL statements that are executed as a single unit.
  </p>

  <p><b>ACID Properties:</b></p>
  <ul>
    <li><b>A</b>tomicity – all or nothing</li>
    <li><b>C</b>onsistency – database moves from one valid state to another</li>
    <li><b>I</b>solation – transactions do not affect each other</li>
    <li><b>D</b>urability – once committed, data is permanent</li>
  </ul>

  <hr>

  <!-- BEGIN / START TRANSACTION -->
  <h3>1️⃣ BEGIN / START TRANSACTION</h3>
  <p>Starts a new transaction.</p>

  <pre>
BEGIN;
-- or
START TRANSACTION;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts
SET balance = balance - 1000
WHERE id = 1;

UPDATE accounts
SET balance = balance + 1000
WHERE id = 2;

-- Decide later: COMMIT or ROLLBACK
  </pre>

  <hr>

  <!-- COMMIT -->
  <h3>2️⃣ COMMIT</h3>
  <p>
    Saves all changes made in the current transaction permanently to the database.
  </p>

  <pre>
COMMIT;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

COMMIT;   -- Money transfer is successful
  </pre>

  <hr>

  <!-- ROLLBACK -->
  <h3>3️⃣ ROLLBACK</h3>
  <p>
    Cancels all changes made in the current transaction and restores data to the previous committed state.
  </p>

  <pre>
ROLLBACK;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;
UPDATE accounts SET balance = balance + 500 WHERE id = 2;

-- Something went wrong
ROLLBACK;   -- All updates are undone
  </pre>

  <hr>

  <!-- SAVEPOINT -->
  <h3>4️⃣ SAVEPOINT</h3>
  <p>
    SAVEPOINT creates a <b>checkpoint</b> inside a transaction.  
    You can rollback only up to that point instead of full transaction.
  </p>

  <pre>
SAVEPOINT savepoint_name;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 1000 WHERE id = 1;
SAVEPOINT sp1;

UPDATE accounts SET balance = balance + 1000 WHERE id = 2;
UPDATE accounts SET balance = balance + 500 WHERE id = 3;

-- Mistake in second part
ROLLBACK TO SAVEPOINT sp1;  -- Undo changes after sp1

COMMIT; -- First update (id=1) remains
  </pre>

  <hr>

  <!-- ROLLBACK TO SAVEPOINT -->
  <h3>5️⃣ ROLLBACK TO SAVEPOINT</h3>
  <p>Undo changes done after a specific savepoint, but keep earlier changes.</p>

  <pre>
ROLLBACK TO SAVEPOINT sp1;
  </pre>

  <hr>

  <!-- RELEASE SAVEPOINT -->
  <h3>6️⃣ RELEASE SAVEPOINT</h3>
  <p>Removes a savepoint (cannot ROLLBACK to it after release).</p>

  <pre>
RELEASE SAVEPOINT sp1;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
SAVEPOINT sp1;

UPDATE accounts SET balance = balance + 100 WHERE id = 2;

RELEASE SAVEPOINT sp1;

COMMIT;
  </pre>

  <hr>

  <!-- SET TRANSACTION -->
  <h3>7️⃣ SET TRANSACTION</h3>
  <p>Sets properties for the current transaction like isolation level, read/write mode.</p>

  <pre>
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION READ ONLY;
  </pre>

  <h4>Example:</h4>
  <pre>
BEGIN;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- Safe, fully isolated transaction
UPDATE accounts SET balance = balance - 200 WHERE id = 1;

COMMIT;
  </pre>

  <hr>

  <!-- AUTOCOMMIT -->
  <h3>8️⃣ Auto-Commit in PostgreSQL (psql)</h3>
  <p>
    In <b>psql</b>, every statement is automatically committed by default.  
    To use transactions, you must explicitly write:
  </p>

  <pre>
BEGIN;
-- your queries here
COMMIT;
-- or
ROLLBACK;
  </pre>

  <p>You can also turn off autocommit in some GUI tools (like DBeaver, pgAdmin) to control transactions manually.</p>

</section>

<hr>

<section id="dcl">
  <h2>🔹 DCL (Data Control Language)</h2>

  <p>
    DCL is used to control access and permissions on database objects such as tables, schemas, views, and sequences.
    It helps maintain database security.
  </p>

  <hr>

  <!-- GRANT -->
  <h3>1️⃣ GRANT</h3>
  <p>
    <b>GRANT</b> gives permissions to users or roles.
  </p>

  <h4>Syntax:</h4>
  <pre>
GRANT privilege_list
ON object_name
TO user_or_role;
  </pre>

  <h4>Example: Give SELECT to a user</h4>
  <pre>
GRANT SELECT ON employees TO user1;
  </pre>

  <h4>Example: Give multiple permissions</h4>
  <pre>
GRANT SELECT, INSERT, UPDATE
ON employees
TO hr_team;
  </pre>

  <h4>Example: Grant all privileges</h4>
  <pre>
GRANT ALL PRIVILEGES ON employees TO admin_user;
  </pre>

  <hr>

  <!-- Privilege Types -->
  <h3>2️⃣ Common Privileges in PostgreSQL</h3>

  <ul>
    <li><b>SELECT</b> – read rows</li>
    <li><b>INSERT</b> – insert rows</li>
    <li><b>UPDATE</b> – update rows</li>
    <li><b>DELETE</b> – delete rows</li>
    <li><b>TRUNCATE</b> – truncate table</li>
    <li><b>REFERENCES</b> – create foreign keys</li>
    <li><b>TRIGGER</b> – create triggers</li>
    <li><b>USAGE</b> – use sequences, languages</li>
    <li><b>EXECUTE</b> – run functions</li>
    <li><b>CREATE</b> – create objects in schema</li>
  </ul>

  <p><b>Note:</b> Permissions differ for tables, schemas, sequences, functions, etc.</p>

  <hr>

  <!-- WITH GRANT OPTION -->
  <h3>3️⃣ WITH GRANT OPTION</h3>
  <p>
    Allows the user to <b>give the same privilege to others</b>.
  </p>

  <h4>Example:</h4>
  <pre>
GRANT SELECT ON employees TO manager WITH GRANT OPTION;
  </pre>

  <p>manager can now grant SELECT to others.</p>

  <hr>

  <!-- REVOKE -->
  <h3>4️⃣ REVOKE</h3>
  <p>
    <b>REVOKE</b> removes permissions previously granted.
  </p>

  <h4>Syntax:</h4>
  <pre>
REVOKE privilege_list
ON object_name
FROM user_or_role;
  </pre>

  <h4>Example: Remove SELECT from user</h4>
  <pre>
REVOKE SELECT ON employees FROM user1;
  </pre>

  <h4>Example: Remove all privileges</h4>
  <pre>
REVOKE ALL PRIVILEGES ON employees FROM hr_team;
  </pre>

  <hr>

  <!-- COLUMN LEVEL -->
  <h3>5️⃣ Column-level Privileges</h3>

  <pre>
GRANT SELECT (name, salary)
ON employees
TO auditor;
  </pre>

  <pre>
REVOKE UPDATE (salary)
ON employees
FROM hr_intern;
  </pre>

  <hr>

  <!-- SCHEMA LEVEL -->
  <h3>6️⃣ Schema-level Permissions</h3>
  <p>
    Schema privileges control access to create objects inside a schema.
  </p>

  <pre>
GRANT USAGE ON SCHEMA public TO user1;
GRANT CREATE ON SCHEMA hr TO developer;
  </pre>

  <hr>

  <!-- SEQUENCE -->
  <h3>7️⃣ Sequence Privileges</h3>

  <pre>
GRANT USAGE, SELECT, UPDATE
ON SEQUENCE emp_id_seq
TO app_user;
  </pre>

  <hr>

  <!-- CREATE ROLE -->
  <h3>8️⃣ Roles (User Groups)</h3>

  <pre>
CREATE ROLE hr_team;
GRANT hr_team TO user1;  -- adds user1 to hr_team
  </pre>

  <p>
    Roles can hold permissions, making it easy to manage groups.
  </p>

  <hr>

  <!-- ROLE INHERITANCE -->
  <h3>9️⃣ Role Inheritance</h3>

  <p>
    By default, roles inherit permissions from the roles they belong to.
  </p>

  <h4>Example:</h4>
  <pre>
CREATE ROLE manager;
GRANT SELECT, UPDATE ON employees TO manager;

GRANT manager TO user1;
-- user1 now has SELECT & UPDATE privileges
  </pre>

  <hr>

  <!-- REMOVE ROLE -->
  <h3>🔟 Removing Role</h3>

  <pre>
DROP ROLE hr_team;
  </pre>

  <hr>

  <!-- Summary -->
  <h3>📌 Summary Table</h3>

  <table>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>

    <tr>
      <td>GRANT</td>
      <td>Give permissions to user or role</td>
    </tr>

    <tr>
      <td>REVOKE</td>
      <td>Remove permissions</td>
    </tr>

    <tr>
      <td>WITH GRANT OPTION</td>
      <td>User can re-grant permissions to others</td>
    </tr>

    <tr>
      <td>ROLE</td>
      <td>Group of users with same privileges</td>
    </tr>

    <tr>
      <td>USAGE</td>
      <td>Allows using sequences/languages/schemas</td>
    </tr>

    <tr>
      <td>EXECUTE</td>
      <td>Execute functions</td>
    </tr>
  </table>

</section>

<hr>

<div class="section">
    <h2>Performance Tuning (EXPLAIN, ANALYZE, VACUUM)</h2>

    <!-- EXPLAIN -->
    <h3>1. EXPLAIN</h3>
    <p><b>EXPLAIN</b> is used to see how PostgreSQL <b>will execute</b> a query.  
       It shows the <b>query plan</b> but does not run the query.</p>

    <h4>Why use EXPLAIN?</h4>
    <ul>
        <li>Check if query uses <b>index</b> or <b>sequential scan</b></li>
        <li>Identify slow operations</li>
        <li>Improve performance before running the query</li>
    </ul>

    <h4>Syntax:</h4>
    <pre>
EXPLAIN SELECT * FROM employees WHERE id = 10;
    </pre>

    <h4>Output Example:</h4>
    <pre>
Seq Scan on employees  (cost=0.00..12.50 rows=1 width=100)
  Filter: (id = 10)
    </pre>

    <!-- EXPLAIN ANALYZE -->
    <h3>2. EXPLAIN ANALYZE</h3>
    <p><b>EXPLAIN ANALYZE</b> runs the query and shows both the <b>plan + actual execution time</b>.</p>

    <h4>Why use EXPLAIN ANALYZE?</h4>
    <ul>
        <li>Shows real performance timings</li>
        <li>Compare estimated vs actual time</li>
        <li>Detect slow parts of query</li>
    </ul>

    <h4>Syntax:</h4>
    <pre>
EXPLAIN ANALYZE SELECT * FROM employees WHERE id = 10;
    </pre>

    <h4>Output Example:</h4>
    <pre>
Seq Scan on employees (actual time=0.040..0.080 rows=1 loops=1)
  Filter: (id = 10)
Planning Time: 0.20 ms
Execution Time: 0.10 ms
    </pre>

    <!-- VACUUM -->
    <h3>3. VACUUM</h3>
    <p><b>VACUUM</b> removes dead rows created by UPDATE and DELETE, reduces table size, and improves performance.</p>

    <h4>VACUUM Types:</h4>
    <ul>
        <li><b>VACUUM</b> – non-blocking background cleanup</li>
        <li><b>VACUUM FULL</b> – frees max space but <b>locks table</b></li>
    </ul>

    <h4>Syntax:</h4>
    <pre>
VACUUM employees;
VACUUM FULL employees;
    </pre>

    <!-- ANALYZE -->
    <h3>4. ANALYZE</h3>
    <p><b>ANALYZE</b> updates statistics so PostgreSQL can make better query plans.</p>

    <h4>Syntax:</h4>
    <pre>
ANALYZE employees;
    </pre>

    <h4>Combined Command:</h4>
    <pre>
VACUUM ANALYZE employees;
    </pre>

    <!-- Summary -->
    <h3>Summary Table</h3>
    <table  cellpadding="8">
        <tr>
            <th>Command</th>
            <th>Purpose</th>
            <th>Runs Query?</th>
            <th>Use Case</th>
        </tr>
        <tr>
            <td><b>EXPLAIN</b></td>
            <td>Shows query plan</td>
            <td>No</td>
            <td>Check how query will run</td>
        </tr>
        <tr>
            <td><b>EXPLAIN ANALYZE</b></td>
            <td>Plan + actual execution time</td>
            <td>Yes</td>
            <td>Find slow operations</td>
        </tr>
        <tr>
            <td><b>VACUUM</b></td>
            <td>Remove dead rows</td>
            <td>No</td>
            <td>Improve space & speed</td>
        </tr>
        <tr>
            <td><b>VACUUM FULL</b></td>
            <td>Rebuild table</td>
            <td>No</td>
            <td>Maximum cleanup (locks table)</td>
        </tr>
        <tr>
            <td><b>ANALYZE</b></td>
            <td>Update statistics</td>
            <td>No</td>
            <td>Better query planning</td>
        </tr>
    </table>
</div>

<hr>

<div class="section">
    <h2>Indexes in PostgreSQL</h2>

    <p>An <b>index</b> improves search performance by allowing PostgreSQL to quickly locate rows
    without scanning the entire table.</p>

    <h3>Why indexes?</h3>
    <ul>
        <li>Speed up SELECT queries</li>
        <li>Useful for large tables</li>
        <li>Improve JOIN performance</li>
        <li>Useful in WHERE, ORDER BY, GROUP BY</li>
    </ul>

    <h3>General Syntax</h3>
    <pre>
CREATE INDEX index_name ON table_name(column_name);
DROP INDEX index_name;
    </pre>

    <hr>

    <!-- B-Tree Index -->
    <h3>1. B-Tree Index (Default)</h3>
    <p>This is the <b>default index type</b> in PostgreSQL.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Equality (=)</li>
        <li>Inequality (&lt;, &gt;, &lt;=, &gt;=)</li>
        <li>Sorting (ORDER BY)</li>
        <li>Range searches (BETWEEN)</li>
        <li>Most common cases</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_emp_salary ON employees(salary);
    </pre>

    <hr>

    <!-- Hash Index -->
    <h3>2. Hash Index</h3>
    <p>Optimized only for <b>equality (=)</b> comparisons.</p>

    <h4>Best For:</h4>
    <ul>
        <li>WHERE column = value</li>
        <li>Fast exact match lookups</li>
    </ul>

    <p><b>Not good for:</b> range queries, ordering</p>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_emp_email_hash ON employees USING hash(email);
    </pre>

    <hr>

    <!-- GIN Index -->
    <h3>3. GIN Index (Generalized Inverted Index)</h3>
    <p>Used for indexing complex data types.</p>

    <h4>Best For:</h4>
    <ul>
        <li>JSONB</li>
        <li>Arrays</li>
        <li>Full-text search</li>
        <li>hstore</li>
        <li>Multiple values in a single column</li>
    </ul>

    <h4>Example (JSONB):</h4>
    <pre>
CREATE INDEX idx_data_json_gin ON logs USING gin(data);
    </pre>

    <h4>Example (Array):</h4>
    <pre>
CREATE INDEX idx_tags_gin ON posts USING gin(tags);
    </pre>

    <hr>

    <!-- GiST Index -->
    <h3>4. GiST Index (Generalized Search Tree)</h3>
    <p>Supports custom indexing for complex data types.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Geometric data (PostGIS)</li>
        <li>Ranges</li>
        <li>Fuzzy search</li>
        <li>Similarity search</li>
        <li>Full-text search (alternative to GIN)</li>
    </ul>

    <h4>Example (range type):</h4>
    <pre>
CREATE INDEX idx_numrange_gist ON items USING gist(price_range);
    </pre>

    <hr>

    <!-- BRIN Index -->
    <h3>5. BRIN Index (Block Range Index)</h3>
    <p>Very small index size and good for very large tables that are <b>naturally ordered</b>.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Timestamp columns (inserted in order)</li>
        <li>Auto-increment ID columns</li>
        <li>Large log or event tables</li>
        <li>Tables with millions/billions of rows</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_log_time_brin ON logs USING brin(created_at);
    </pre>

    <hr>

    <!-- Full Text Search Index -->
    <h3>6. Full-Text Search Index (GIN/GiST)</h3>
    <p>Used for text searching with <b>to_tsvector</b> and <b>to_tsquery</b>.</p>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_article_search 
ON articles USING gin(to_tsvector('english', content));
    </pre>

    <hr>

    <!-- Expression Index -->
    <h3>7. Expression Index</h3>
    <p>Index based on an expression, not a raw column.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Lowercase search</li>
        <li>Computed expressions</li>
        <li>Partial transformations</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_lower_email ON users (LOWER(email));
    </pre>

    <hr>

    <!-- Partial Index -->
    <h3>8. Partial Index</h3>
    <p>Index created on only a part of the table.</p>

    <h4>Best For:</h4>
    <ul>
        <li>Frequently filtered subset</li>
        <li>Active users, recent records, non-null values</li>
    </ul>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_active_users 
ON users(status) WHERE status = 'active';
    </pre>

    <hr>

    <!-- Unique Index -->
    <h3>9. Unique Index</h3>
    <p>Ensures that no two rows have the same value.</p>

    <h4>Example:</h4>
    <pre>
CREATE UNIQUE INDEX idx_unique_email ON users(email);
    </pre>

    <hr>

    <!-- Covering Index -->
    <h3>10. Covering Index (INCLUDE)</h3>
    <p>Index stores extra columns so PostgreSQL can answer queries <b>without reading table</b>.</p>

    <h4>Example:</h4>
    <pre>
CREATE INDEX idx_orders_covering 
ON orders(customer_id) INCLUDE(order_date, amount);
    </pre>

    <hr>

    <h3>Summary Table</h3>
    <table  cellpadding="8">
        <tr>
            <th>Index Type</th>
            <th>Best Use Case</th>
            <th>Supports</th>
        </tr>
        <tr>
            <td><b>B-Tree</b></td>
            <td>General-purpose, ranges, sorting</td>
            <td>=, <, >, BETWEEN, ORDER BY</td>
        </tr>
        <tr>
            <td><b>Hash</b></td>
            <td>Exact match</td>
            <td>= only</td>
        </tr>
        <tr>
            <td><b>GIN</b></td>
            <td>JSONB, arrays, FTS</td>
            <td>Multiple values, key→value lookup</td>
        </tr>
        <tr>
            <td><b>GiST</b></td>
            <td>Geometric, fuzzy, ranges</td>
            <td>Custom operators</td>
        </tr>
        <tr>
            <td><b>BRIN</b></td>
            <td>Very large sequential tables</td>
            <td>Block ranges</td>
        </tr>
        <tr>
            <td><b>Expression Index</b></td>
            <td>On expressions</td>
            <td>Computed values</td>
        </tr>
        <tr>
            <td><b>Partial Index</b></td>
            <td>Filtered data</td>
            <td>Conditional WHERE</td>
        </tr>
        <tr>
            <td><b>Covering Index</b></td>
            <td>Speed up SELECT</td>
            <td>INCLUDE extra columns</td>
        </tr>
    </table>
</div>

<hr>

<div class="section">

    <h2>Views in PostgreSQL</h2>

    <p>A <b>VIEW</b> is a virtual table based on a query.  
    It does not store data physically (except materialized views).  
    It helps simplify complex queries and improve security.</p>

    <h3>Why use Views?</h3>
    <ul>
        <li>Hide complex SQL logic</li>
        <li>Improve security (restrict access to specific columns)</li>
        <li>Reusable SQL queries</li>
        <li>Reduce code duplication</li>
    </ul>

    <hr>

    <!-- Create View -->
    <h3>1. CREATE VIEW</h3>
    <p>Creates a virtual table from a SELECT query.</p>

    <h4>Syntax</h4>
    <pre>
CREATE VIEW view_name AS
SELECT columns
FROM table
WHERE condition;
    </pre>

    <h4>Example</h4>
    <pre>
CREATE VIEW high_salary_emps AS
SELECT name, salary
FROM employees
WHERE salary > 50000;
    </pre>

    <hr>

    <!-- Using a View -->
    <h3>2. Using a View</h3>
    <pre>
SELECT * FROM high_salary_emps;
    </pre>

    <hr>

    <!-- Replace View -->
    <h3>3. CREATE OR REPLACE VIEW</h3>
    <p>Updates a view without dropping it.</p>

    <pre>
CREATE OR REPLACE VIEW high_salary_emps AS
SELECT name, salary, department
FROM employees
WHERE salary > 50000;
    </pre>

    <hr>

    <!-- Update View -->
    <h3>4. Updatable Views</h3>
    <p>A view is <b>updatable</b> if it is based on:</p>
    <ul>
        <li>Single table</li>
        <li>No aggregate functions</li>
        <li>No GROUP BY, ORDER BY</li>
        <li>No DISTINCT</li>
    </ul>

    <h4>Example</h4>
    <pre>
UPDATE high_salary_emps
SET salary = 70000
WHERE name = 'John';
    </pre>

    <hr>

    <!-- Check Option -->
    <h3>5. WITH CHECK OPTION</h3>
    <p>Prevents inserting/updating rows that do not match view condition.</p>

    <h4>Example</h4>
    <pre>
CREATE VIEW sales_team AS
SELECT * FROM employees
WHERE department = 'Sales'
WITH CHECK OPTION;
    </pre>

    <p><b>This prevents:</b></p>
    <pre>
INSERT INTO sales_team (name, department)
VALUES ('Alex', 'HR');   -- ❌ Not allowed
    </pre>

    <hr>

    <!-- Drop View -->
    <h3>6. DROP VIEW</h3>
    <pre>
DROP VIEW sales_team;
DROP VIEW IF EXISTS sales_team;
    </pre>

    <hr>

    <!-- Materialized View -->
    <h3>7. Materialized View</h3>
    <p>A <b>materialized view</b> stores data physically.  
    Faster for large queries but must be refreshed.</p>

    <h4>Create Materialized View</h4>
    <pre>
CREATE MATERIALIZED VIEW sales_summary AS
SELECT department, SUM(amount) AS total_sales
FROM sales
GROUP BY department;
    </pre>

    <h4>Refresh Materialized View</h4>
    <pre>
REFRESH MATERIALIZED VIEW sales_summary;
    </pre>

    <h4>Refresh without locking</h4>
    <pre>
REFRESH MATERIALIZED VIEW CONCURRENTLY sales_summary;
    </pre>

    <p>(Requires a unique index on the MV)</p>

    <hr>

    <!-- View vs Materialized View -->
    <h3>8. View vs Materialized View</h3>

    <table  cellpadding="8">
        <tr>
            <th>Feature</th>
            <th>View</th>
            <th>Materialized View</th>
        </tr>
        <tr>
            <td>Stores Data</td>
            <td>No</td>
            <td>Yes</td>
        </tr>
        <tr>
            <td>Speed</td>
            <td>Slower (runs query every time)</td>
            <td>Faster for repeated reads</td>
        </tr>
        <tr>
            <td>Refresh Needed?</td>
            <td>No</td>
            <td>Yes (REFRESH MATERIALIZED VIEW)</td>
        </tr>
        <tr>
            <td>Use Case</td>
            <td>Simplify queries</td>
            <td>Store precomputed results</td>
        </tr>
    </table>

</div>

<hr>

<div class="section">

    <h2>CTE (WITH Clause)</h2>

    <p>A <b>CTE (Common Table Expression)</b> is a temporary result set 
    defined using the <b>WITH</b> keyword.  
    It makes queries cleaner and reusable inside a SELECT.</p>

    <h3>Syntax</h3>
    <pre>
WITH cte_name AS (
    SELECT ...
)
SELECT * FROM cte_name;
    </pre>

    <h3>Example</h3>
    <pre>
WITH high_salary AS (
    SELECT name, salary
    FROM employees
    WHERE salary > 50000
)
SELECT * FROM high_salary;
    </pre>

    <hr>

    <h2>Recursive CTE</h2>

    <p>Recursive queries are used for hierarchical or tree-structured data
    (employees, categories, parent-child relationships).</p>

    <h3>Syntax</h3>
    <pre>
WITH RECURSIVE cte_name AS (
    -- Anchor part
    SELECT ...

    UNION ALL

    -- Recursive part
    SELECT ...
    FROM cte_name
)
SELECT * FROM cte_name;
    </pre>

    <h3>Example: Employee Hierarchy</h3>
    <pre>
WITH RECURSIVE emp_tree AS (
    -- anchor member
    SELECT id, name, manager_id, 1 AS level
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- recursive member
    SELECT e.id, e.name, e.manager_id, t.level + 1
    FROM employees e
    INNER JOIN emp_tree t ON e.manager_id = t.id
)
SELECT * FROM emp_tree;
    </pre>

    <hr>

    <h2>JSON Data Type</h2>

    <p>PostgreSQL supports two JSON types:</p>
    <ul>
        <li><b>json</b> – stored as plain text</li>
        <li><b>jsonb</b> – stored in binary form (faster for search)</li>
    </ul>

    <h3>Create JSON Column</h3>
    <pre>
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    details JSONB
);
    </pre>

    <h3>Insert JSON</h3>
    <pre>
INSERT INTO products(details) VALUES (
    '{"name": "Laptop", "price": 50000, "specs": {"ram": "16GB"}}'
);
    </pre>

    <h3>Extract JSON Fields</h3>

    <ul>
        <li><b>-></b> returns JSON object</li>
        <li><b>->></b> returns text value</li>
    </ul>

    <pre>
SELECT details->'name'        FROM products;  -- JSON
SELECT details->>'name'       FROM products;  -- TEXT
SELECT details->'specs'->>'ram' FROM products;
    </pre>

    <hr>

    <h3>Search Inside JSONB</h3>
    <pre>
SELECT * FROM products
WHERE details @> '{"name": "Laptop"}';
    </pre>

    <p><b>@></b> checks if JSON contains another JSON.</p>

    <hr>

    <h3>jsonb_set (update JSON)</h3>
    <pre>
UPDATE products
SET details = jsonb_set(details, '{price}', '55000');
    </pre>

    <hr>

    <h3>jsonb_array_elements()</h3>

    <pre>
SELECT jsonb_array_elements('["red", "blue", "green"]'::jsonb);
    </pre>

    <hr>

    <h2>Arrays in PostgreSQL</h2>

    <p>PostgreSQL supports <b>multi-value arrays</b> inside a column.</p>

    <h3>Create Array Column</h3>
    <pre>
CREATE TABLE students (
    id SERIAL PRIMARY KEY,
    subjects TEXT[]
);
    </pre>

    <h3>Insert Array</h3>
    <pre>
INSERT INTO students(subjects)
VALUES ('{math,science,english}');
    </pre>

    <h3>Select Array Values</h3>
    <pre>
SELECT subjects[1] FROM students;     -- first element
SELECT subjects FROM students;
    </pre>

    <hr>

    <h3>Array Functions</h3>

    <h4>1. array_length()</h4>
    <pre>
SELECT array_length('{1,2,3,4}'::int[], 1);  -- output: 4
    </pre>

    <h4>2. array_append()</h4>
    <pre>
SELECT array_append('{1,2,3}'::int[], 4);  -- {1,2,3,4}
    </pre>

    <h4>3. array_remove()</h4>
    <pre>
SELECT array_remove('{1,2,3,2}'::int[], 2);  -- {1,3}
    </pre>

    <h4>4. array_cat()</h4>
    <pre>
SELECT array_cat('{a,b}'::text[], '{c,d}'::text[]);  
-- {a,b,c,d}
    </pre>

    <h4>5. ANY & ALL operators</h4>
    <pre>
SELECT 3 = ANY('{1,2,3}'::int[]);  -- true
SELECT 3 > ALL('{1,2}'::int[]);    -- true
    </pre>

    <hr>

    <h2>JSON vs Array</h2>

    <table  cellpadding="8">
        <tr>
            <th>Feature</th>
            <th>JSON</th>
            <th>Array</th>
        </tr>
        <tr>
            <td>Structure</td>
            <td>Key–value</td>
            <td>List of values</td>
        </tr>
        <tr>
            <td>Flexibility</td>
            <td>High (nested)</td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Best Use</td>
            <td>Semi-structured data</td>
            <td>Ordered lists</td>
        </tr>
    </table>

</div>


<hr>

<h1>PostgreSQL SEQUENCES</h1>

<p>A sequence is a database object that generates unique numbers. Mostly used for primary keys.</p>

<hr>

<h2>1. CREATE SEQUENCE</h2>

<h3>Syntax:</h3>
<pre>
CREATE SEQUENCE sequence_name
START WITH start_value
INCREMENT BY step_value
MINVALUE min_value
MAXVALUE max_value
CACHE cache_value
CYCLE | NO CYCLE
OWNED BY table.column;   -- optional
</pre>

<h3>Example:</h3>
<pre>
CREATE SEQUENCE emp_seq
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 99999
CACHE 1
NO CYCLE;
</pre>

<hr>

<h2>2. USING THE SEQUENCE</h2>

<p>Use <b>nextval()</b> to get next number:</p>
<pre>
INSERT INTO employee(id, name)
VALUES (nextval('emp_seq'), 'Aathi');
</pre>

<hr>

<h2>3. SEQUENCE FUNCTIONS</h2>

<table  cellpadding="8">
<tr><th>Function</th><th>Description</th></tr>
<tr><td>nextval('seq')</td><td>Get next value and increment the sequence</td></tr>
<tr><td>currval('seq')</td><td>Returns current value (after nextval is called)</td></tr>
<tr><td>setval('seq', value)</td><td>Set the sequence to a specific number</td></tr>
</table>

<h3>Examples:</h3>
<pre>
SELECT nextval('emp_seq');   -- 1
SELECT currval('emp_seq');   -- 1
SELECT setval('emp_seq', 50);
SELECT nextval('emp_seq');   -- 51
</pre>

<hr>

<h2>4. ALTER SEQUENCE</h2>

<p><b>Common Syntax:</b></p>
<pre>
ALTER SEQUENCE sequence_name
    INCREMENT BY value
    MINVALUE value
    MAXVALUE value
    START WITH value
    RESTART [WITH value]
    CACHE value
    CYCLE | NO CYCLE
    OWNED BY table.column | NONE;
</pre>

<h3>Examples:</h3>

<h4>Change increment:</h4>
<pre>
ALTER SEQUENCE emp_seq INCREMENT BY 5;
</pre>

<h4>Restart sequence:</h4>
<pre>
ALTER SEQUENCE emp_seq RESTART WITH 1;
</pre>

<h4>Change minimum/maximum:</h4>
<pre>
ALTER SEQUENCE emp_seq MINVALUE 10;
ALTER SEQUENCE emp_seq MAXVALUE 999999;
</pre>

<h4>Assign sequence ownership:</h4>
<pre>
ALTER SEQUENCE emp_seq OWNED BY employee.id;
</pre>

<h4>Remove ownership:</h4>
<pre>
ALTER SEQUENCE emp_seq OWNED BY NONE;
</pre>

<hr>

<h2>5. DROP SEQUENCE</h2>

<h3>Syntax:</h3>
<pre>
DROP SEQUENCE sequence_name;
</pre>

<h3>Example:</h3>
<pre>
DROP SEQUENCE emp_seq;
</pre>

<hr>

<h2>6. SET DEFAULT using Sequence</h2>

<p>Automatically fill column using sequence:</p>
<pre>
ALTER TABLE employee
ALTER COLUMN id SET DEFAULT nextval('emp_seq');
</pre>

<p>Now insert without ID:</p>
<pre>
INSERT INTO employee(name) VALUES ('John');
</pre>

<hr>

<h2>7. Sequence with Multiple Tables</h2>

<p>A single sequence can be used by many tables. All will share the same counter.</p>

<pre>
CREATE SEQUENCE global_seq START 1;
</pre>

<h3>Table 1:</h3>
<pre>
CREATE TABLE customer(
    cid INT DEFAULT nextval('global_seq'),
    name TEXT
);
</pre>

<h3>Table 2:</h3>
<pre>
CREATE TABLE orders(
    oid INT DEFAULT nextval('global_seq'),
    amount INT
);
</pre>

<h3>Inserts:</h3>
<pre>
INSERT INTO customer(name) VALUES ('Aathi');
INSERT INTO orders(amount) VALUES (500);
INSERT INTO customer(name) VALUES ('Kavi');
</pre>

<h3>Generated Values:</h3>
<pre>
customer -> 1
orders   -> 2
customer -> 3
</pre>

<hr>

<h2>8. Quick Revision Table</h2>

<table  cellpadding="8">
<tr><th>Command</th><th>Purpose</th></tr>
<tr><td>CREATE SEQUENCE</td><td>Create new counter object</td></tr>
<tr><td>ALTER SEQUENCE</td><td>Modify sequence properties</td></tr>
<tr><td>DROP SEQUENCE</td><td>Delete sequence</td></tr>
<tr><td>nextval()</td><td>Get next number</td></tr>
<tr><td>currval()</td><td>Current number</td></tr>
<tr><td>setval()</td><td>Set sequence number manually</td></tr>
<tr><td>OWNED BY</td><td>Attach sequence to table column</td></tr>
</table>

<hr>

<h1>PostgreSQL – Advanced Topics</h1>
<hr>

<!-- ========================================================= -->
<!--                    STORED FUNCTIONS                       -->
<!-- ========================================================= -->

<h2>1. Stored Functions</h2>
<p>A stored function returns a value and can be used inside SELECT.</p>

<h3>Syntax:</h3>
<pre>
CREATE OR REPLACE FUNCTION function_name(param datatype)
RETURNS return_type AS $$
BEGIN
    -- logic
    RETURN value;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION add_numbers(a INT, b INT)
RETURNS INT AS $$
BEGIN
    RETURN a + b;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Call Function:</h3>
<pre>
SELECT add_numbers(10, 20);
-- Output: 30
</pre>

<hr>

<!-- ========================================================= -->
<!--                    STORED PROCEDURES                      -->
<!-- ========================================================= -->

<h2>2. Stored Procedures</h2>
<p>Stored procedures do NOT return values. Called using CALL.</p>

<h3>Syntax:</h3>
<pre>
CREATE OR REPLACE PROCEDURE procedure_name(param datatype)
LANGUAGE plpgsql AS $$
BEGIN
    -- logic
END;
$$;
</pre>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE PROCEDURE insert_student(name TEXT, age INT)
LANGUAGE plpgsql AS $$
BEGIN
    INSERT INTO students(name, age) VALUES (name, age);
END;
$$;

CALL insert_student('Aathi', 22);
</pre>

<hr>

<!-- ========================================================= -->
<!--                          TRIGGERS                         -->
<!-- ========================================================= -->

<h2>3. Triggers</h2>
<p>Triggers execute automatically on INSERT, UPDATE, DELETE.</p>

<h3>Steps:</h3>
<ol>
<li>Create function</li>
<li>Create trigger</li>
</ol>

<h3>Trigger Function:</h3>
<pre>
CREATE OR REPLACE FUNCTION log_employee_changes()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO employee_log(emp_id, action_time)
    VALUES (NEW.id, NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Create Trigger:</h3>
<pre>
CREATE TRIGGER emp_after_insert
AFTER INSERT ON employee
FOR EACH ROW
EXECUTE FUNCTION log_employee_changes();
</pre>

<h3>Example Insert:</h3>
<pre>
INSERT INTO employee(id, name) VALUES (1, 'John');

-- Automatically inserts into employee_log
</pre>

<hr>

<!-- ========================================================= -->
<!--                          CURSOR                           -->
<!-- ========================================================= -->

<h2>4. Cursors</h2>
<p>Cursors allow row-by-row processing inside a function or procedure.</p>

<h3>Syntax:</h3>
<pre>
DECLARE cursor_name CURSOR FOR SELECT ...;
FETCH NEXT FROM cursor_name;
CLOSE cursor_name;
</pre>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION process_students()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur CURSOR FOR SELECT id, name FROM students;
BEGIN
    OPEN cur;
    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Student: %, %', rec.id, rec.name;
    END LOOP;
    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT process_students();
</pre>

<hr>

<!-- ========================================================= -->
<!--                 LOCKS & CONCURRENCY                       -->
<!-- ========================================================= -->

<h2>5. Locks & Concurrency</h2>
<p>PostgreSQL uses MVCC (Multi-Version Concurrency Control) for safe parallel operations.</p>

<h3>Types of Locks:</h3>

<table  cellpadding="8">
<tr><th>Lock Type</th><th>Description</th></tr>
<tr><td>ROW SHARE</td><td>Used for SELECT ... FOR SHARE</td></tr>
<tr><td>ROW EXCLUSIVE</td><td>INSERT, UPDATE, DELETE</td></tr>
<tr><td>SHARE</td><td>Blocks writes</td></tr>
<tr><td>SHARE ROW EXCLUSIVE</td><td>Heavier lock on table</td></tr>
<tr><td>EXCLUSIVE</td><td>No parallel reads or writes</td></tr>
<tr><td>ACCESS EXCLUSIVE</td><td>DROP/ALTER TABLE</td></tr>
</table>

<h3>Important Commands:</h3>

<h4>1. SELECT FOR UPDATE</h4>
<pre>
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
</pre>

<h4>2. SELECT FOR SHARE</h4>
<pre>
SELECT * FROM products WHERE id = 10 FOR SHARE;
</pre>

<h4>3. Deadlock Example</h4>
<pre>
-- Session 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- Session 2
BEGIN;
UPDATE accounts SET balance = balance + 50 WHERE id = 2;
</pre>

<p>If both try to update each other's rows — a deadlock happens.</p>

<h4>Check current locks</h4>
<pre>
SELECT * FROM pg_locks;
</pre>

<h4>Check waiting queries</h4>
<pre>
SELECT * FROM pg_stat_activity WHERE wait_event IS NOT NULL;
</pre>

<hr>

<!-- ========================================================= -->
<!--                      QUICK REVISION                       -->
<!-- ========================================================= -->

<h2>6. Quick Revision Table</h2>

<table  cellpadding="8">
<tr><th>Feature</th><th>Purpose</th></tr>
<tr><td>Stored Function</td><td>Returns value, used in SELECT</td></tr>
<tr><td>Stored Procedure</td><td>No return, use CALL</td></tr>
<tr><td>Trigger</td><td>Auto execute on DML</td></tr>
<tr><td>Cursor</td><td>Row-by-row processing</td></tr>
<tr><td>Locks</td><td>Control multi-user access</td></tr>
</table>

<hr>

<h1>PostgreSQL – Cursors & Triggers</h1>
<hr>

<!-- ========================================================= -->
<!--                           CURSORS                          -->
<!-- ========================================================= -->

<h2>1. CURSORS</h2>
<p>Cursors allow row-by-row processing of a result set inside a PL/pgSQL block.</p>

<h3>Why Cursors?</h3>
<ul>
<li>Used when you must process rows one-by-one</li>
<li>Needed in loops (FOR, WHILE, LOOP)</li>
<li>Used for complex business logic</li>
<li>Used when you can't operate using normal SQL set-based operations</li>
</ul>

<hr>

<h2>Types of Cursors</h2>

<table  cellpadding="8">
<tr><th>Type</th><th>Description</th></tr>
<tr><td>Implicit Cursor</td><td>Used automatically in FOR loops</td></tr>
<tr><td>Explicit Cursor</td><td>Manually declared, opened, fetched, and closed</td></tr>
<tr><td>Bound Cursor</td><td>Cursor with parameters</td></tr>
<tr><td>Unbound Cursor</td><td>Cursor created without a predefined query</td></tr>
</table>

<hr>

<h2>1.1 Implicit Cursor (Simplest)</h2>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION print_students()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
BEGIN
    FOR rec IN SELECT id, name FROM students LOOP
        RAISE NOTICE 'ID: %, Name: %', rec.id, rec.name;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT print_students();
</pre>

<hr>

<h2>1.2 Explicit Cursor</h2>

<h3>Syntax:</h3>
<pre>
DECLARE cursor_name CURSOR FOR SELECT ...;
OPEN cursor_name;
FETCH cursor_name INTO variable;
CLOSE cursor_name;
</pre>

<h3>Full Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION read_students()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur CURSOR FOR SELECT id, name FROM students ORDER BY id;
BEGIN
    OPEN cur;
    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'Student: %, %', rec.id, rec.name;
    END LOOP;
    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT read_students();
</pre>

<hr>

<h2>1.3 Cursor WITH PARAMETERS (Bound Cursor)</h2>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION list_students(min_id INT)
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur CURSOR (x INT) FOR SELECT id, name FROM students WHERE id >= x;
BEGIN
    OPEN cur(min_id);
    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;

        RAISE NOTICE 'ID: %, Name: %', rec.id, rec.name;
    END LOOP;
    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT list_students(5);
</pre>

<hr>

<h2>1.4 Unbound Cursor (Assign Query Later)</h2>

<h3>Example:</h3>
<pre>
CREATE OR REPLACE FUNCTION dynamic_cursor()
RETURNS VOID AS $$
DECLARE
    rec RECORD;
    cur REFCURSOR;
BEGIN
    cur := 'mycursor';

    OPEN cur FOR SELECT id, name FROM students WHERE age > 20;

    LOOP
        FETCH cur INTO rec;
        EXIT WHEN NOT FOUND;
        RAISE NOTICE 'Student: %, %', rec.id, rec.name;
    END LOOP;

    CLOSE cur;
END;
$$ LANGUAGE plpgsql;

SELECT dynamic_cursor();
</pre>

<hr>

<h2>1.5 Cursor Output</h2>
<pre>
NOTICE: Student: 1, John
NOTICE: Student: 2, Ram
NOTICE: Student: 3, Kavi
</pre>

<hr>

<!-- ========================================================= -->
<!--                           TRIGGERS                         -->
<!-- ========================================================= -->

<h1>2. TRIGGERS</h1>
<p>Triggers automatically execute a function when INSERT, UPDATE or DELETE happens.</p>

<h2>Steps to create a trigger</h2>

<ol>
<li>Create trigger function (must return NEW or OLD)</li>
<li>Create trigger and attach it to a table</li>
</ol>

<hr>

<h2>2.1 Types of Triggers</h2>

<table  cellpadding="8">
<tr><th>Type</th><th>Description</th></tr>
<tr><td>BEFORE INSERT</td><td>Validates / modifies data before inserting</td></tr>
<tr><td>AFTER INSERT</td><td>Logs data after insert</td></tr>
<tr><td>BEFORE UPDATE</td><td>Modify values before update</td></tr>
<tr><td>AFTER UPDATE</td><td>History/audit logs</td></tr>
<tr><td>BEFORE DELETE</td><td>Check conditions before deleting</td></tr>
<tr><td>AFTER DELETE</td><td>Log removed rows</td></tr>
<tr><td>INSTEAD OF</td><td>Used with views</td></tr>
</table>

<hr>

<h2>2.2 AFTER INSERT Trigger (Log New Rows)</h2>

<h3>Trigger Function</h3>
<pre>
CREATE OR REPLACE FUNCTION log_insert()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO employee_log(emp_id, name, inserted_at)
    VALUES (NEW.id, NEW.name, NOW());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
</pre>

<h3>Create Trigger</h3>
<pre>
CREATE TRIGGER trg_after_insert
AFTER INSERT ON employee
FOR EACH ROW
EXECUTE FUNCTION log_insert();
</pre>

<h3>Insert Example:</h3>
<pre>
INSERT INTO employee(id, name) VALUES (1, 'Aathi');
</pre>

<h3>Output:</h3>
<pre>
employee_log table:
id | name  | inserted_at
1  | Aathi | 2025-01-20 10:20:00
</pre>

<hr>

<h2>2.3 BEFORE UPDATE Trigger (Modify Values)</h2>

<h3>Example: Auto-update modified date</h3>

<pre>
CREATE OR REPLACE FUNCTION update_modified()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_update
BEFORE UPDATE ON employee
FOR EACH ROW
EXECUTE FUNCTION update_modified();
</pre>

<hr>

<h2>2.4 BEFORE DELETE Trigger (Prevent Deletion)</h2>

<pre>
CREATE OR REPLACE FUNCTION prevent_delete()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Deletion not allowed!';
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_before_delete
BEFORE DELETE ON employee
FOR EACH ROW
EXECUTE FUNCTION prevent_delete();
</pre>

<hr>

<h2>2.5 AFTER DELETE Trigger (Audit)</h2>

<pre>
CREATE OR REPLACE FUNCTION log_delete()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO deleted_users(id, name, deleted_at)
    VALUES (OLD.id, OLD.name, NOW());
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_after_delete
AFTER DELETE ON employee
FOR EACH ROW
EXECUTE FUNCTION log_delete();
</pre>

<hr>

<h2>2.6 INSTEAD OF Trigger (For VIEWS)</h2>

<pre>
CREATE VIEW emp_names AS
SELECT id, name FROM employee;

CREATE OR REPLACE FUNCTION insert_view_fn()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO employee(id, name) VALUES (NEW.id, NEW.name);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_instead_insert
INSTEAD OF INSERT ON emp_names
FOR EACH ROW
EXECUTE FUNCTION insert_view_fn();
</pre>

<hr>

<h1>3. Quick Revision Table</h1>

<table  cellpadding="8">
<tr><th>Feature</th><th>Used For</th></tr>
<tr><td>Cursor</td><td>Row-by-row processing</td></tr>
<tr><td>Trigger</td><td>Auto actions on INSERT/UPDATE/DELETE</td></tr>
<tr><td>BEFORE</td><td>Validate or modify NEW data</td></tr>
<tr><td>AFTER</td><td>Logging, audit, history</td></tr>
<tr><td>INSTEAD OF</td><td>Triggers on views</td></tr>
</table>

<h1>PL/pgSQL – IF, LOOP, WHILE, CASE</h1>
<hr>

<!-- ========================================================= -->
<!--                          INTRO                             -->
<!-- ========================================================= -->

<p>PL/pgSQL is PostgreSQL’s procedural language used to write functions, triggers, loops, conditional logic, and more.</p>

<h2>Topics Covered</h2>
<ul>
<li>IF / ELSIF / ELSE</li>
<li>Simple IF</li>
<li>IF with expressions</li>
<li>LOOP / EXIT / CONTINUE</li>
<li>WHILE loop</li>
<li>FOR loops</li>
<li>CASE expressions</li>
</ul>

<hr>

<!-- ========================================================= -->
<!--                           IF STATEMENT                     -->
<!-- ========================================================= -->

<h1>1. IF Statements</h1>

<h3>Syntax:</h3>
<pre>
IF condition THEN
    statements;
ELSIF condition THEN
    statements;
ELSE
    statements;
END IF;
</pre>

<hr>

<h2>1.1 Simple IF</h2>
<pre>
CREATE OR REPLACE FUNCTION check_age(a INT)
RETURNS TEXT AS $$
BEGIN
    IF a >= 18 THEN
        RETURN 'Adult';
    END IF;

    RETURN 'Minor';
END;
$$ LANGUAGE plpgsql;

SELECT check_age(20);  -- Adult
</pre>

<hr>

<h2>1.2 IF – ELSIF – ELSE</h2>
<pre>
CREATE OR REPLACE FUNCTION grade(score INT)
RETURNS TEXT AS $$
BEGIN
    IF score >= 90 THEN
        RETURN 'A';
    ELSIF score >= 75 THEN
        RETURN 'B';
    ELSIF score >= 50 THEN
        RETURN 'C';
    ELSE
        RETURN 'Fail';
    END IF;
END;
$$ LANGUAGE plpgsql;

SELECT grade(80); -- B
</pre>

<hr>

<h2>1.3 Nested IF</h2>
<pre>
IF salary > 50000 THEN
    IF experience > 5 THEN
        RETURN 'Senior';
    END IF;
END IF;
</pre>

<hr>

<!-- ========================================================= -->
<!--                            LOOPS                           -->
<!-- ========================================================= -->

<h1>2. LOOP Statements</h1>
<p>LOOP creates an infinite loop until EXIT is used.</p>

<h3>Syntax:</h3>
<pre>
LOOP
    statements;
    EXIT WHEN condition;
END LOOP;
</pre>

<hr>

<h2>2.1 Basic LOOP Example</h2>
<pre>
CREATE OR REPLACE FUNCTION loop_demo()
RETURNS VOID AS $$
DECLARE
    i INT := 1;
BEGIN
    LOOP
        RAISE NOTICE 'i = %', i;
        i := i + 1;

        EXIT WHEN i > 5;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT loop_demo();
</pre>

<h3>Output:</h3>
<pre>
NOTICE: i = 1
NOTICE: i = 2
NOTICE: i = 3
NOTICE: i = 4
NOTICE: i = 5
</pre>

<hr>

<h2>2.2 CONTINUE</h2>
<pre>
LOOP
    i := i + 1;
    CONTINUE WHEN i = 3;
    RAISE NOTICE 'Value: %', i;
    EXIT WHEN i > 5;
END LOOP;
</pre>

<h3>Skips printing when i = 3</h3>

<hr>

<!-- ========================================================= -->
<!--                           WHILE LOOP                       -->
<!-- ========================================================= -->

<h1>3. WHILE Loop</h1>

<h3>Syntax:</h3>
<pre>
WHILE condition LOOP
    statements;
END LOOP;
</pre>

<hr>

<h2>Example:</h2>
<pre>
CREATE OR REPLACE FUNCTION while_demo()
RETURNS VOID AS $$
DECLARE
    x INT := 1;
BEGIN
    WHILE x <= 5 LOOP
        RAISE NOTICE 'x = %', x;
        x := x + 1;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT while_demo();
</pre>

<hr>

<!-- ========================================================= -->
<!--                            FOR LOOP                        -->
<!-- ========================================================= -->

<h1>4. FOR Loop</h1>

<p>PostgreSQL supports 3 types of FOR loops:</p>
<ul>
<li>Integer FOR loop</li>
<li>Reverse integer FOR loop</li>
<li>FOR-IN-SELECT loop</li>
</ul>

<hr>

<h2>4.1 Integer FOR Loop</h2>
<pre>
FOR i IN 1..5 LOOP
    RAISE NOTICE 'Number: %', i;
END LOOP;
</pre>

<hr>

<h2>4.2 Reverse Loop</h2>
<pre>
FOR i IN REVERSE 5..1 LOOP
    RAISE NOTICE 'i = %', i;
END LOOP;
</pre>

<hr>

<h2>4.3 FOR-IN-SELECT Loop</h2>
<pre>
FOR rec IN SELECT id, name FROM employees LOOP
    RAISE NOTICE 'Employee: %, %', rec.id, rec.name;
END LOOP;
</pre>

<hr>

<!-- ========================================================= -->
<!--                            CASE STATEMENT                  -->
<!-- ========================================================= -->

<h1>5. CASE Statement</h1>

<h2>5.1 Simple CASE</h2>
<pre>
CREATE OR REPLACE FUNCTION check_day(day INT)
RETURNS TEXT AS $$
BEGIN
    CASE day
        WHEN 1 THEN RETURN 'Monday';
        WHEN 2 THEN RETURN 'Tuesday';
        WHEN 3 THEN RETURN 'Wednesday';
        ELSE RETURN 'Unknown';
    END CASE;
END;
$$ LANGUAGE plpgsql;

SELECT check_day(2); -- Tuesday
</pre>

<hr>

<h2>5.2 Searched CASE</h2>
<pre>
CASE
    WHEN marks >= 90 THEN 'High'
    WHEN marks >= 60 THEN 'Medium'
    ELSE 'Low'
END
</pre>

<hr>

<h2>5.3 CASE inside SELECT</h2>
<pre>
SELECT name,
       CASE 
            WHEN salary > 50000 THEN 'High Salary'
            WHEN salary > 30000 THEN 'Medium Salary'
            ELSE 'Low Salary'
       END AS category
FROM employees;
</pre>

<hr>

<h1>Quick Revision Table</h1>

<table  cellpadding="7">
<tr><th>Feature</th><th>Use</th></tr>
<tr><td>IF / ELSIF</td><td>Conditional logic</td></tr>
<tr><td>LOOP</td><td>Infinite loop with EXIT</td></tr>
<tr><td>WHILE</td><td>Loop while condition true</td></tr>
<tr><td>FOR</td><td>Numeric range or SELECT loop</td></tr>
<tr><td>CASE</td><td>Multiple condition evaluation</td></tr>
</table>

<hr>

<section>
    <h2>Backup & Restore in PostgreSQL</h2>
    <p>PostgreSQL provides powerful tools for backing up and restoring databases using <code>pg_dump</code>, <code>pg_restore</code>, and <code>psql</code>. These tools support full, custom, table-level, and schema-level backups.</p>

    <h3>1. Backup Using pg_dump</h3>

    <h4>📌 A) Full Database Backup (Plain SQL File)</h4>
    <pre><code>pg_dump -U username dbname > backup.sql</code></pre>

    <p><b>Restores using:</b> psql</p>
    <pre><code>psql -U username -d dbname -f backup.sql</code></pre>

    <h4>📌 B) Backup Specific Table</h4>
    <pre><code>pg_dump -U username -t table_name dbname > table_backup.sql</code></pre>

    <h4>📌 C) Backup Specific Schema</h4>
    <pre><code>pg_dump -U username -n schema_name dbname > schema_backup.sql</code></pre>

    <h4>📌 D) Custom Format Backup (.dump / .backup)</h4>
    <pre><code>pg_dump -U username -F c -f backup.dump dbname</code></pre>

    <p>This custom format requires <code>pg_restore</code> to restore.</p>

    <h4>📌 E) Directory Format Backup</h4>
    <pre><code>pg_dump -U username -F d -f backup_dir dbname</code></pre>

    <h4>📌 F) Backup Only Schema (No Data)</h4>
    <pre><code>pg_dump -U username -s dbname > schema_only.sql</code></pre>

    <h4>📌 G) Backup Only Data (No Schema)</h4>
    <pre><code>pg_dump -U username -a dbname > data_only.sql</code></pre>

    <hr>

    <h3>2. Restore Using pg_restore (for custom/directory format)</h3>

    <h4>📌 A) Restore Into Existing Database</h4>
    <pre><code>pg_restore -U username -d dbname backup.dump</code></pre>

    <h4>📌 B) Restore with Clean (Drop existing objects)</h4>
    <pre><code>pg_restore -U username --clean -d dbname backup.dump</code></pre>

    <h4>📌 C) Restore Only Schema</h4>
    <pre><code>pg_restore -U username -s -d dbname backup.dump</code></pre>

    <h4>📌 D) Restore Only Data</h4>
    <pre><code>pg_restore -U username -a -d dbname backup.dump</code></pre>

    <h4>📌 E) List Contents of a Backup File</h4>
    <pre><code>pg_restore -l backup.dump</code></pre>

    <hr>

    <h3>3. Restore Using psql (for plain .sql backups)</h3>

    <h4>📌 A) Restore Full Database</h4>
    <pre><code>psql -U username -d dbname -f backup.sql</code></pre>

    <h4>📌 B) Restore a Schema Only</h4>
    <pre><code>psql -U username -d dbname -f schema_only.sql</code></pre>

    <h4>📌 C) Restore Data Only</h4>
    <pre><code>psql -U username -d dbname -f data_only.sql</code></pre>

    <hr>

    <h3>4. Backup & Restore All Databases</h3>

    <h4>📌 Backup all databases</h4>
    <pre><code>pg_dumpall -U username > alldb_backup.sql</code></pre>

    <h4>📌 Restore all databases</h4>
    <pre><code>psql -U username -f alldb_backup.sql</code></pre>

    <hr>

    <h3>5. Backup Roles & Permissions</h3>

    <h4>📌 Backup roles only</h4>
    <pre><code>pg_dumpall -U username --globals-only > roles.sql</code></pre>

    <h4>📌 Restore roles</h4>
    <pre><code>psql -U username -f roles.sql</code></pre>

    <hr>

    <h3>6. Important Notes</h3>
    <ul>
        <li><code>pg_dump</code> does NOT block other operations — no downtime.</li>
        <li><code>pg_restore</code> requires a database created beforehand.</li>
        <li>For large DBs, custom format (<code>-F c</code>) is best.</li>
        <li>Plain SQL backups restore slower but are human-readable.</li>
    </ul>
</section>

<hr>

<section>
    <h2>Backup Strategies in PostgreSQL (Full, Incremental, WAL)</h2>
    <p>PostgreSQL supports multiple backup strategies to ensure data safety, fast recovery, and minimal downtime. These strategies include Full backups, Incremental backups, and WAL (Write-Ahead Log) archiving.</p>

    <hr>
    <h3>1. Full Backup</h3>
    <p>A full backup takes a complete snapshot of the entire database at a point in time.</p>

    <h4>📌 Full Backup Using pg_dump</h4>
    <pre><code>pg_dump -U username dbname > full_backup.sql</code></pre>

    <h4>📌 Full Backup of All Databases</h4>
    <pre><code>pg_dumpall -U username > alldb_full_backup.sql</code></pre>

    <h4>✔ Advantages</h4>
    <ul>
        <li>Easy to create and restore</li>
        <li>Readable .sql files</li>
        <li>No dependency on WAL logs</li>
    </ul>

    <h4>✘ Disadvantages</h4>
    <ul>
        <li>Slow for large databases</li>
        <li>Consumes more storage space</li>
    </ul>

    <hr>
    <h3>2. Incremental Backup</h3>
    <p>PostgreSQL does NOT support true incremental backups using pg_dump.  
    Incremental backups are achieved using <b>File System Level backup + WAL Archiving + Continuous Archiving</b>.</p>

    <p>This allows restoring the database up to any moment in time.</p>

    <h4>📌 Incremental Logic</h4>
    <ol>
        <li>Take a base backup (file-system level)</li>
        <li>Enable WAL archiving</li>
        <li>Store all WAL files that record every database change</li>
        <li>Restore base backup + replay WAL → Recover database state</li>
    </ol>

    <hr>

    <h3>3. WAL Archiving (Write-Ahead Logging)</h3>
    <p>WAL files store every database change.  
    Enabling WAL archiving allows:
        <ul>
            <li>Incremental recovery</li>
            <li>Point-In-Time Recovery (PITR)</li>
            <li>Standby servers / replication</li>
        </ul>
    </p>

    <h4>📌 Enable WAL Archiving (postgresql.conf)</h4>
    <pre><code>wal_level = archive
archive_mode = on
archive_command = 'cp %p /path/to/archive/%f'</code></pre>

    <h4>✔ Base Backup Command (File System Backup)</h4>
    <pre><code>pg_basebackup -U username -D /backup/location -Ft -z -P</code></pre>

    <p>This produces a base backup + WAL files.</p>

    <hr>

    <h3>4. Point-In-Time Recovery (PITR)</h3>
    <p>Using WAL + base backup, PostgreSQL can reconstruct the database up to any timestamp.</p>

    <h4>📌 Recovery Example (recovery.signal)</h4>
    <pre><code>restore_command = 'cp /path/to/archive/%f %p'
recovery_target_time = '2025-01-01 10:00:00'</code></pre>

    <p>Place the above settings in <code>postgresql.auto.conf</code> for recovery.</p>

    <hr>

    <h3>5. Backup Strategy Comparison</h3>

    <table  cellpadding="6">
        <tr><th>Backup Type</th><th>Description</th><th>Speed</th><th>Storage</th><th>Use Case</th></tr>
        <tr><td>Full Backup</td><td>Complete copy of DB</td><td>Slow</td><td>High</td><td>Small/medium DB, simple restore</td></tr>
        <tr><td>Incremental</td><td>Base backup + WAL logs</td><td>Fast (after base)</td><td>Low</td><td>Large DB, enterprise backup</td></tr>
        <tr><td>WAL Archiving</td><td>Continuous log-based backup</td><td>Very fast</td><td>Medium</td><td>PITR, High availability</td></tr>
    </table>

    <hr>

    <h3>6. Recommended Best Practices</h3>
    <ul>
        <li>Daily full backup for small databases</li>
        <li>Weekly base backup + WAL archiving for large databases</li>
        <li>Store backups on remote/cloud storage</li>
        <li>Test restores regularly</li>
        <li>Enable WAL compression</li>
    </ul>
</section>


<section id="psql-functions">
  <h2>🛠️ PostgreSQL Functions</h2>

  <p>A <strong>function</strong> in PostgreSQL is a stored program that returns a value. Functions can be written in <code>SQL</code> or <code>PL/pgSQL</code>. They allow code reuse, logic implementation, calculations, and return results directly inside <code>SELECT</code> statements.</p>

  <hr>

  <!-- Basic Syntax -->
  <h3>📘 Basic Syntax (SQL Function)</h3>
  <pre><code>
CREATE FUNCTION function_name(param_name datatype, ...)
RETURNS return_datatype
AS $$
    SQL Query Here;
$$ LANGUAGE sql;
  </code></pre>

  <h4>✔ Example</h4>
  <pre><code>
CREATE FUNCTION get_price(pid INT)
RETURNS INT
AS $$
    SELECT price FROM products WHERE productid = pid;
$$ LANGUAGE sql;
  </code></pre>

  <hr>

  <!-- PLPGSQL Syntax -->
  <h3>📘 Basic Syntax (PL/pgSQL Function)</h3>
  <pre><code>
CREATE FUNCTION function_name(param datatype, ...)
RETURNS return_type
LANGUAGE plpgsql
AS $$
DECLARE
    variable datatype;
BEGIN
    -- logic here
    RETURN value;
END;
$$;
  </code></pre>

  <h4>✔ Example</h4>
  <pre><code>
CREATE FUNCTION discount(price INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN price - (price * 0.10);
END;
$$;
  </code></pre>

  <hr>

  <!-- Multiple Parameters -->
  <h3>📘 Function With Multiple Parameters</h3>
  <pre><code>
CREATE FUNCTION add_numbers(a INT, b INT)
RETURNS INT
AS $$
    SELECT a + b;
$$ LANGUAGE sql;
  </code></pre>

  <hr>

  <!-- Return Table -->
  <h3>📘 Function Returning a Table</h3>
  <pre><code>
CREATE FUNCTION top_products()
RETURNS TABLE(productid INT, total_quantity INT)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT productid, SUM(quantity)
    FROM orderitems
    GROUP BY productid
    ORDER BY SUM(quantity) DESC;
END;
$$;
  </code></pre>

  <h4>✔ Use</h4>
  <pre><code>
SELECT * FROM top_products();
  </code></pre>

  <hr>

  <!-- OUT Parameters -->
  <h3>📘 Function With OUT Parameters</h3>
  <pre><code>
CREATE FUNCTION double_value(IN num INT, OUT result INT)
LANGUAGE plpgsql
AS $$
BEGIN
    result := num * 2;
END;
$$;
  </code></pre>

  <h4>✔ Use</h4>
  <pre><code>
SELECT double_value(10);
  </code></pre>

  <hr>

  <!-- IF ELSE -->
  <h3>📘 Function With IF / ELSE</h3>
  <pre><code>
CREATE FUNCTION grade(marks INT)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
BEGIN
    IF marks >= 90 THEN
        RETURN 'A';
    ELSIF marks >= 70 THEN
        RETURN 'B';
    ELSE
        RETURN 'C';
    END IF;
END;
$$;
  </code></pre>

  <hr>

  <!-- LOOP -->
  <h3>📘 Function With LOOP</h3>
  <pre><code>
CREATE FUNCTION sum_upto(n INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
    total INT := 0;
    i INT := 1;
BEGIN
    WHILE i <= n LOOP
        total := total + i;
        i := i + 1;
    END LOOP;

    RETURN total;
END;
$$;
  </code></pre>

  <hr>

  <!-- CASE -->
  <h3>📘 Function Using CASE</h3>
  <pre><code>
CREATE FUNCTION day_type(dayname TEXT)
RETURNS TEXT
AS $$
    SELECT CASE 
             WHEN dayname IN ('Saturday','Sunday') THEN 'Weekend'
             ELSE 'Weekday'
           END;
$$ LANGUAGE sql;
  </code></pre>

  <hr>

  <!-- Exception Handling -->
  <h3>📘 Function With Exception Handling</h3>
  <pre><code>
CREATE FUNCTION safe_divide(a INT, b INT)
RETURNS INT
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN a / b;
EXCEPTION
    WHEN division_by_zero THEN
        RETURN NULL;
END;
$$;
  </code></pre>

  <hr>

  <!-- Replace Function -->
  <h3>📘 Create or Replace Function</h3>
  <pre><code>
CREATE OR REPLACE FUNCTION function_name(...)
RETURNS return_type
AS $$
BEGIN
    -- updated logic
END;
$$ LANGUAGE plpgsql;
  </code></pre>

  <hr>

  <!-- Drop Function -->
  <h3>📘 Drop Function</h3>
  <pre><code>
DROP FUNCTION function_name(argument_types);
  </code></pre>

  <h4>✔ Example</h4>
  <pre><code>
DROP FUNCTION get_price(INT);
  </code></pre>

  <hr>

  <!-- Function Limitations -->
  <h3>⚠️ Important Notes</h3>
  <ul>
    <li>Functions <strong>must return</strong> a value.</li>
    <li>Functions <strong>cannot</strong> use COMMIT or ROLLBACK.</li>
    <li>Functions <strong>can be used</strong> in SELECT queries.</li>
    <li>Functions are used for <strong>calculations, logic, returning results</strong>.</li>
  </ul>

</section>


<section id="procedures">

<h1>📘 PostgreSQL Procedures — Complete Notes</h1>

<h2>📌 What is a Procedure?</h2>
<p>
A <b>procedure</b> in PostgreSQL is a stored program that performs actions like 
INSERT, UPDATE, DELETE or calling other procedures.  
Unlike functions, procedures:
</p>
<ul>
  <li>do <b>not return</b> a value</li>
  <li>are executed using <code>CALL</code></li>
  <li>allow <b>transaction control</b> (COMMIT, ROLLBACK)</li>
</ul>

<hr>

<h2>📘 Syntax: Create a Procedure</h2>

<pre>
CREATE PROCEDURE procedure_name (parameters)
LANGUAGE plpgsql
AS $$
BEGIN
    -- body of procedure
END;
$$;
</pre>

<hr>

<h2>📘 Example 1 — Simple Procedure</h2>

<pre>
CREATE PROCEDURE hello_proc()
LANGUAGE plpgsql
AS $$
BEGIN
    RAISE NOTICE 'Hello from Procedure!';
END;
$$;

CALL hello_proc();
</pre>

<hr>

<h2>📘 Procedure With Parameters</h2>

<pre>
CREATE PROCEDURE add_product(pname TEXT, pprice INT)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO products(productname, price)
    VALUES (pname, pprice);
END;
$$;

CALL add_product('Laptop', 45000);
</pre>

<hr>

<h2>📘 IN, OUT, INOUT Parameters</h2>

<h3>✔ IN (default)</h3>
<p>Used to send input into procedure</p>

<h3>✔ OUT</h3>
<p>Used to return a value</p>

<h3>✔ INOUT</h3>
<p>Input → modified → returned</p>

<pre>
CREATE PROCEDURE update_price(INOUT p INT)
LANGUAGE plpgsql
AS $$
BEGIN
    p := p + 100;
END;
$$;

CALL update_price(900); 
-- result: 1000
</pre>

<hr>

<h2>📘 Procedure With Transaction Control (Allowed)</h2>

<pre>
CREATE PROCEDURE transaction_test()
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO logs VALUES ('Before Commit');

    COMMIT;

    INSERT INTO logs VALUES ('After Commit');
END;
$$;
</pre>

<hr>

<h2>📘 ALTER PROCEDURE</h2>

<h3>✔ Rename Procedure</h3>
<pre>
ALTER PROCEDURE hello_proc() RENAME TO hi_proc;
</pre>

<h3>✔ Change Owner</h3>
<pre>
ALTER PROCEDURE hello_proc() OWNER TO new_user;
</pre>

<h3>✔ Move to Another Schema</h3>
<pre>
ALTER PROCEDURE hello_proc() SET SCHEMA newschema;
</pre>

<hr>

<h2>📘 DROP PROCEDURE</h2>

<pre>
DROP PROCEDURE procedure_name(parameters);
</pre>

<h3>Example:</h3>
<pre>
DROP PROCEDURE add_product(TEXT, INT);
</pre>

<hr>

<h2>📘 Procedure vs Function — Comparison</h2>

<table border="1" cellpadding="5">
<tr>
  <th>Feature</th>
  <th>Function</th>
  <th>Procedure</th>
</tr>
<tr>
  <td>Returns value</td>
  <td>Yes</td>
  <td>No</td>
</tr>
<tr>
  <td>Execution</td>
  <td>SELECT function()</td>
  <td>CALL procedure()</td>
</tr>
<tr>
  <td>Transaction control</td>
  <td>❌ Not allowed</td>
  <td>✔ Allowed</td>
</tr>
<tr>
  <td>Main use</td>
  <td>Calculations</td>
  <td>Database operations</td>
</tr>
</table>

</section>

<section id="cte">

<h1>📘 CTE — Common Table Expressions (WITH Clause)</h1>

<p>
A CTE (Common Table Expression) is a temporary result set created using <code>WITH</code>.  
It is readable, reusable, and best for complex queries.
</p>

<hr>

<h2>📌 1. Basic CTE</h2>

<pre>
WITH temp AS (
    SELECT productid, price 
    FROM products
    WHERE price > 1000
)
SELECT * FROM temp;
</pre>

<p>✔ Creates CTE named <b>temp</b> and then selects from it.</p>

<hr>

<h2>📌 2. CTE With Joins</h2>

<pre>
WITH order_total AS (
    SELECT o.productid, SUM(o.quantity) AS total
    FROM orderitems o
    GROUP BY o.productid
)
SELECT p.productname, o.total
FROM products p
JOIN order_total o
    ON p.productid = o.productid;
</pre>

<hr>

<h2>📌 3. Multiple CTEs</h2>

<pre>
WITH 
high_price AS (
    SELECT * FROM products WHERE price > 2000
),
max_by_cat AS (
    SELECT category, MAX(price) AS maxprice
    FROM high_price
    GROUP BY category
)
SELECT p.category, p.productname, p.price
FROM high_price p
JOIN max_by_cat m
   ON p.category = m.category
  AND p.price = m.maxprice;
</pre>

<p>✔ Each CTE can use previous CTEs.</p>

<hr>

<h2>📌 4. CTE for UPDATE</h2>

<p>Update rows using a CTE result.</p>

<pre>
WITH price_raise AS (
    SELECT productid FROM products
    WHERE category = 'Electronics'
)
UPDATE products
SET price = price + 1000
WHERE productid IN (SELECT productid FROM price_raise);
</pre>

<p>✔ CTE simplifies complex UPDATE logic.</p>

<hr>

<h2>📌 5. CTE for DELETE</h2>

<pre>
WITH old_orders AS (
    SELECT orderid FROM orders
    WHERE orderdate < '2023-01-01'
)
DELETE FROM orders
WHERE orderid IN (SELECT orderid FROM old_orders);
</pre>

<hr>

<h2>📌 6. Recursive CTE Basics</h2>

<p>
A recursive CTE has two parts:
</p>

<ul>
  <li><b>Anchor member</b> → runs once</li>
  <li><b>Recursive member</b> → repeats until no rows returned</li>
</ul>

<pre>
WITH RECURSIVE numbers AS (
    SELECT 1 AS n            -- anchor
    UNION ALL
    SELECT n + 1             -- recursive
    FROM numbers
    WHERE n < 10
)
SELECT * FROM numbers;
</pre>

<p>Output: 1 to 10</p>

<hr>

<h2>📌 7. Recursive CTE — Factorial</h2>

<pre>
WITH RECURSIVE fact AS (
    SELECT 1 AS n, 1 AS value      -- anchor
    UNION ALL
    SELECT n + 1, value * (n + 1)
    FROM fact
    WHERE n < 5
)
SELECT * FROM fact;
</pre>

<p>✔ Shows factorial sequence.</p>

<hr>

<h2>📌 8. Recursive CTE — Tree / Hierarchy Example</h2>

<p>Employees table with manager relationships.</p>

<pre>
WITH RECURSIVE emp_tree AS (
    SELECT empid, name, managerid, 1 AS level
    FROM employees
    WHERE managerid IS NULL      -- top-most manager

    UNION ALL

    SELECT e.empid, e.name, e.managerid, t.level + 1
    FROM employees e
    JOIN emp_tree t
        ON e.managerid = t.empid
)
SELECT * FROM emp_tree ORDER BY level;
</pre>

<p>✔ Shows full reporting hierarchy.</p>

<hr>

<h2>📌 9. Recursive CTE — Parent → Child</h2>

<pre>
WITH RECURSIVE tree AS (
   SELECT id, parent_id, name
   FROM category
   WHERE parent_id IS NULL  -- parent

   UNION ALL

   SELECT c.id, c.parent_id, c.name
   FROM category c
   JOIN tree t ON c.parent_id = t.id
)
SELECT * FROM tree;
</pre>

<hr>

<h2>📌 10. Using CTE for INSERT</h2>

<pre>
WITH newprod AS (
    INSERT INTO products(productname, price)
    VALUES ('Tablet', 25000)
    RETURNING productid
)
INSERT INTO stock(productid, quantity)
SELECT productid, 100 FROM newprod;
</pre>

<hr>

<h2>📌 11. CTE + Window Functions</h2>

<pre>
WITH totals AS (
    SELECT productid, SUM(quantity) AS total
    FROM orderitems
    GROUP BY productid
)
SELECT *, 
       RANK() OVER (ORDER BY total DESC) AS rnk
FROM totals;
</pre>

<hr>

<h2>📌 12. Materialized CTE (CTE executed once)</h2>

<pre>
WITH MATERIALIZED temp AS (
    SELECT * FROM products WHERE price > 1000
)
SELECT * FROM temp;
</pre>

<hr>

<h2>📌 13. Inline CTE — Used Inside Subquery</h2>

<pre>
SELECT *
FROM (
    WITH x AS (SELECT 1 AS a)
    SELECT a FROM x
) t;
</pre>

</section>

<section id="psql-admin">

<h1>📘 PostgreSQL Administration Commands</h1>

<p>
This section covers important <b>psql meta-commands</b> and <b>PostgreSQL administration operations</b> 
such as databases, roles, privileges, schemas, backup/restore, and server information.
</p>

<hr>

<h2>🔹 1. Basic <code>psql</code> Meta-Commands</h2>

<pre>
\l              -- list all databases
\c dbname       -- connect to a database
\dt             -- list all tables
\di             -- list indexes
\dv             -- list views
\dn             -- list schemas
\df             -- list functions
\du             -- list roles/users
\d tablename    -- describe table
\q              -- quit psql
\copyright
\encoding
</pre>

<hr>

<h2>🔹 2. Describe Objects</h2>

<pre>
\d table        -- structure of table
\d+ table       -- with storage and size info
\df+            -- functions with details
\dx             -- list installed extensions
\det            -- list foreign tables
</pre>

<hr>

<h2>🔹 3. Database Management</h2>

<h3>⚡ Create Database</h3>
<pre>
CREATE DATABASE company;
</pre>

<h3>⚡ Drop Database</h3>
<pre>
DROP DATABASE company;
</pre>

<h3>⚡ Rename Database</h3>
<pre>
ALTER DATABASE company RENAME TO company_new;
</pre>

<h3>⚡ Set Default Encoding / Owner</h3>
<pre>
CREATE DATABASE salesdb OWNER aathi ENCODING 'UTF8';
</pre>

<hr>

<h2>🔹 4. User & Role Management</h2>

<h3>⚡ Create User</h3>
<pre>
CREATE USER aathi WITH PASSWORD '1234';
</pre>

<h3>⚡ Create Superuser</h3>
<pre>
CREATE ROLE admin SUPERUSER LOGIN PASSWORD 'pass';
</pre>

<h3>⚡ Grant Privileges</h3>
<pre>
GRANT ALL PRIVILEGES ON DATABASE salesdb TO aathi;
GRANT SELECT, INSERT ON products TO developer;
</pre>

<h3>⚡ Revoke Privileges</h3>
<pre>
REVOKE INSERT ON products FROM developer;
</pre>

<h3>⚡ Change Password</h3>
<pre>
ALTER USER postgres WITH PASSWORD 'newpass';
</pre>

<hr>

<h2>🔹 5. Role Attributes</h2>

<pre>
ALTER ROLE developer CREATEDB;
ALTER ROLE tester CREATEROLE;
ALTER ROLE analyst LOGIN;
ALTER ROLE support NOLOGIN;
</pre>

<hr>

<h2>🔹 6. Schema Administration</h2>

<h3>⚡ Create Schema</h3>
<pre>
CREATE SCHEMA sales;
</pre>

<h3>⚡ Drop Schema</h3>
<pre>
DROP SCHEMA sales CASCADE;
</pre>

<h3>⚡ Change Search Path</h3>
<pre>
SET search_path TO sales, public;
</pre>

<h3>⚡ Ownership</h3>
<pre>
ALTER SCHEMA sales OWNER TO manager;
</pre>

<hr>

<h2>🔹 7. Table & Column Level Admin Commands</h2>

<h3>⚡ Rename Table</h3>
<pre>
ALTER TABLE products RENAME TO items;
</pre>

<h3>⚡ Add/Drop Columns</h3>
<pre>
ALTER TABLE products ADD COLUMN stock INT DEFAULT 0;
ALTER TABLE products DROP COLUMN stock;
</pre>

<h3>⚡ Add Constraints</h3>
<pre>
ALTER TABLE products 
ADD CONSTRAINT price_check CHECK (price > 0);
</pre>

<hr>

<h2>🔹 8. Index Administration</h2>

<pre>
CREATE INDEX idx_price ON products(price);
DROP INDEX idx_price;
</pre>

<hr>

<h2>🔹 9. Server Information & Settings</h2>

<pre>
SHOW all;                   -- all PostgreSQL settings
SHOW port;                  -- port number
SHOW data_directory;        -- data directory
SELECT version();           -- PostgreSQL version
SELECT current_database();  
SELECT current_user();
</pre>

<hr>

<h2>🔹 10. Monitoring & Processes</h2>

<pre>
SELECT * FROM pg_stat_activity;
SELECT pid, query, state FROM pg_stat_activity;
SELECT * FROM pg_locks;
</pre>

<h3>Kill a Query</h3>
<pre>
SELECT pg_terminate_backend(pid);
</pre>

<hr>

<h2>🔹 11. Extensions</h2>

<pre>
\dx                              -- list extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION pgcrypto;
</pre>

<hr>

<h2>🔹 12. Backup & Restore</h2>

<h3>⚡ Backup Entire Database</h3>
<pre>
pg_dump -U postgres -F c -f backup.dump company;
</pre>

<h3>⚡ Restore</h3>
<pre>
pg_restore -U postgres -d company backup.dump;
</pre>

<h3>⚡ Export SQL Format</h3>
<pre>
pg_dump -U postgres company > company.sql
</pre>

<hr>

<h2>🔹 13. Import / Export CSV</h2>

<h3>Export</h3>
<pre>
COPY products TO '/tmp/products.csv' CSV HEADER;
</pre>

<h3>Import</h3>
<pre>
COPY products FROM '/tmp/products.csv' CSV HEADER;
</pre>

<hr>

<h2>🔹 14. Transaction Commands</h2>

<pre>
BEGIN;
UPDATE products SET price = price + 100;
COMMIT;

BEGIN;
DELETE FROM products WHERE productid = 10;
ROLLBACK;
</pre>

<hr>

<h2>🔹 15. Analyze & Vacuum</h2>

<pre>
VACUUM;                    -- cleanup
VACUUM FULL;               -- fully reclaim space
ANALYZE;                   -- update planner statistics
VACUUM ANALYZE;            -- both
</pre>

</section>

</body>
</html>



